diff --git a/src/infrastructure/orchestration/MetaOrchestratorAgent.py b/src/infrastructure/orchestration/MetaOrchestratorAgent.py
index 535e0e2..0f8bf9e 100644
--- a/src/infrastructure/orchestration/MetaOrchestratorAgent.py
+++ b/src/infrastructure/orchestration/MetaOrchestratorAgent.py
@@ -15,16 +15,26 @@
 from __future__ import annotations
 import logging
 import json
-from typing import Dict, List, Any, TYPE_CHECKING
+from typing import Any, TYPE_CHECKING
 from src.core.base.BaseAgent import BaseAgent
 
 if TYPE_CHECKING:
     from src.infrastructure.fleet.FleetManager import FleetManager
     from src.core.knowledge.GlobalContext import GlobalContext
 
+
+
+
+
+
+
+
+
+
+
 class MetaOrchestratorAgent(BaseAgent):
     """
-    Expert orchestrator that can decompose high-level objectives into 
+    Expert orchestrator that can decompose high-level objectives into
     multi-agent workflows and manage recursive resolution.
     """
 
@@ -36,17 +46,17 @@ class MetaOrchestratorAgent(BaseAgent):
 
     async def solve_complex_objective(self, objective: str, depth: int = 0) -> str:
         """
-        Decomposes an objective and executes it, handling sub-goals 
+        Decomposes an objective and executes it, handling sub-goals
         recursively if necessary.
         """
         if depth > self.max_depth:
             return f"Error: Maximum recursion depth ({self.max_depth}) exceeded for objective: {objective}"
 
         logging.info(f"MetaOrchestrator: Decomposing objective (Depth {depth}): {objective[:50]}...")
-        
+
         # Phase 1: Decomposition
         plan = await self._decompose_objective(objective)
-        
+
         results = []
         for step in plan:
             if step.get("type") == "complex":
@@ -58,11 +68,11 @@ class MetaOrchestratorAgent(BaseAgent):
             agent_name = step.get("agent")
             action = step.get("action")
             args = step.get("args", [])
-            
+
             # Execute via FleetManager (Phase 152: await)
             res = await self.fleet.execute_workflow(objective, [{"agent": agent_name, "action": action, "args": args}])
             results.append(res)
-            
+
         return f"# Objective Resolution Report (Depth {depth})\n\n" + "\n".join(results)
 
     async def _decompose_objective(self, objective: str) -> list[dict[str, Any]]:
@@ -70,20 +80,20 @@ class MetaOrchestratorAgent(BaseAgent):
         prompt = f"""
         Break down the following high-level objective into a JSON list of steps.
         Objective: {objective}
-        
+
         Each step should have:
         - "type": "simple" or "complex"
         - "agent": Optional, for simple steps (e.g., "Reasoning", "Coder", "Memory")
         - "action": Optional, for simple steps
         - "args": List of arguments for simple steps
         - "goal": Required for complex steps (a sub-objective string)
-        
+
         Return ONLY valid JSON.
         """
-        
+
         # Use an available agent for decomposition or internal logic
         res = await self.fleet.call_by_capability("Security.improve_content", prompt=prompt)
-        
+
         try:
             # Simple extractor for markdown
             if "```json" in res:
@@ -99,7 +109,7 @@ class MetaOrchestratorAgent(BaseAgent):
         """Injects global context into agent arguments."""
         enriched = []
         context_brief = self.global_context.get_summary()
-        
+
         for arg in args:
             if isinstance(arg, str) and "{context}" in arg:
                 enriched.append(arg.replace("{context}", context_brief))
@@ -109,4 +119,4 @@ class MetaOrchestratorAgent(BaseAgent):
 
     async def run(self, objective: str) -> str:
         """Entry point for the MetaOrchestrator agent."""
-        return await self.solve_complex_objective(objective)
\ No newline at end of file
+        return await self.solve_complex_objective(objective)
