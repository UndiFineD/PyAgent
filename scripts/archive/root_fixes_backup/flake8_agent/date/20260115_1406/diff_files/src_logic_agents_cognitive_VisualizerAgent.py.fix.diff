diff --git a/src/logic/agents/cognitive/VisualizerAgent.py b/src/logic/agents/cognitive/VisualizerAgent.py
index df4eb92..cc96b49 100644
--- a/src/logic/agents/cognitive/VisualizerAgent.py
+++ b/src/logic/agents/cognitive/VisualizerAgent.py
@@ -27,7 +27,7 @@ from src.core.base.version import VERSION
 import logging
 import time
 from pathlib import Path
-from typing import Dict, List, Any, Optional
+from typing import Any
 import json
 from src.core.base.BaseAgent import BaseAgent
 from src.core.base.utilities import as_tool
@@ -36,15 +36,25 @@ from src.logic.agents.cognitive.GraphMemoryAgent import GraphMemoryAgent
 
 __version__ = VERSION
 
+
+
+
+
+
+
+
+
+
+
 class VisualizerAgent(BaseAgent):
     """Maps relationships and handles Visual Workflow Export/Import (cc-wf-studio pattern)."""
-    
+
     def __init__(self, file_path: str) -> None:
         super().__init__(file_path)
         self.workspace_root = self.file_path.parent.parent.parent
         self.graph_engine = GraphContextEngine(str(self.workspace_root))
         self.memory_agent: GraphMemoryAgent | None = None
-        
+
         self._system_prompt = (
             "You are the Fleet Visualizer Agent. "
             "You follow the cc-wf-studio visual workflow format for export/import.\n"
@@ -60,7 +70,7 @@ class VisualizerAgent(BaseAgent):
             query: Spatial query (e.g., 'Is agent A closer to tool B than tool C?').
         """
         logging.info(f"VISUALIZER: Performing spatial reasoning for query: {query}")
-        
+
         # Simple heuristic or AI-based reasoning
         # For simplicity, we just format the objects for the LLM to reason about
         prompt = (
@@ -68,7 +78,7 @@ class VisualizerAgent(BaseAgent):
             f"Query: {query}\n"
             "Analyze the spatial relationships and provide a clear answer."
         )
-        
+
         return self.think(prompt)
 
     @as_tool
@@ -81,7 +91,7 @@ class VisualizerAgent(BaseAgent):
             event_query: Query about an event (e.g., 'When did the human pick up the tool?').
         """
         logging.info(f"VISUALIZER: Performing video grounding for query: {event_query}")
-        
+
         # Simulation: identify change between frames
         # For demonstration, we simply return a mocked temporal analysis
         return {
@@ -96,10 +106,10 @@ class VisualizerAgent(BaseAgent):
     def export_visual_workflow(self, workflow_name: str, tasks: list[dict[str, Any]]) -> str:
         """Exports a task sequence as a JSON visual workflow (cc-wf-studio format)."""
         logging.info(f"VISUALIZER: Exporting visual workflow '{workflow_name}'")
-        
+
         nodes = []
         edges = []
-        
+
         for i, task in enumerate(tasks):
             node_id = f"node_{i}"
             nodes.append({
@@ -115,17 +125,23 @@ class VisualizerAgent(BaseAgent):
                     "target": node_id,
                     "label": "sequence"
                 })
-        
+
         workflow_data = {
             "name": workflow_name,
             "version": "1.0.0",
             "canvas": {"nodes": nodes, "edges": edges}
         }
-        
+
         output_path = Path(str(self.workspace_root)) / "config" / f"{workflow_name}_visual.json"
-        with open(output_path, 'w') as f:
-            json.dump(workflow_data, f, indent=2)
-            
+        temp_path = output_path.with_suffix(".tmp")
+        try:
+            with open(temp_path, "w", encoding="utf-8") as f:
+                json.dump(workflow_data, f, indent=2)
+            temp_path.replace(output_path)
+        except Exception:
+            if temp_path.exists(): temp_path.unlink()
+            raise
+
         return f"Successfully exported visual workflow to {output_path}"
 
     @as_tool
@@ -133,13 +149,13 @@ class VisualizerAgent(BaseAgent):
         """Imports a JSON visual workflow and converts it to a Task Planner sequence."""
         logging.info(f"VISUALIZER: Importing visual workflow '{file_name}'")
         input_path = Path(str(self.workspace_root)) / "config" / file_name
-        
+
         if not input_path.exists():
             return {"error": f"File {file_name} not found in config/"}
-            
+
         with open(input_path) as f:
             data = json.load(f)
-            
+
         # Convert canvas nodes to fleet tasks
         tasks = []
         for node in data.get("canvas", {}).get("nodes", []):
@@ -148,7 +164,7 @@ class VisualizerAgent(BaseAgent):
                 "agent": node["data"]["agent"],
                 "status": "pending"
             })
-            
+
         return {"workflow_name": data.get("name"), "tasks": tasks}
 
     def set_memory_agent(self, agent: GraphMemoryAgent) -> None:
@@ -160,25 +176,25 @@ class VisualizerAgent(BaseAgent):
         """Generates a Mermaid graph from the GraphMemory triples."""
         if not self.memory_agent:
             return "Error: No GraphMemoryAgent connected to VisualizerAgent."
-            
+
         relationships = self.memory_agent.relationships
         if not relationships:
             return "## ðŸ§  Knowledge Graph\n\nNo relationships found in memory."
-            
+
         lines = ["graph LR"]
         for rel in relationships:
             s = rel['subject'].replace(" ", "_")
             p = rel['predicate'].replace(" ", "_")
             o = rel['object'].replace(" ", "_")
             lines.append(f"    {s} -- {p} --> {o}")
-            
+
         return "## ðŸ§  Knowledge Graph\n\n```mermaid\n" + "\n".join(lines) + "\n```"
 
     @as_tool
     def generate_fleet_map(self) -> str:
         """Generates a Mermaid class diagram of the entire agent fleet."""
         logging.info("VisualizerAgent generating fleet map...")
-        
+
         # We manually build the core fleet map for now
         diagram = [
             "classDiagram",
@@ -194,7 +210,7 @@ class VisualizerAgent(BaseAgent):
             "    SecurityGuardAgent --|> BaseAgent : inherits",
             "    MetaOrchestratorAgent --> FleetManager : uses"
         ]
-        
+
         return "## ðŸ—ºï¸ Fleet Architecture Map\n\n```mermaid\n" + "\n".join(diagram) + "\n```"
 
     @as_tool
@@ -202,20 +218,20 @@ class VisualizerAgent(BaseAgent):
         """Generates a Mermaid flowchart of function calls based on the graph engine."""
         self.graph_engine.scan_project()
         symbols = self.graph_engine.symbols
-        
+
         lines = ["graph TD"]
         count = 0
         for file, data in symbols.items():
             if filter_term and filter_term not in file:
                 continue
-            
+
             clean_file = file.replace("\\", "/").split("/")[-1]
             for call in data.get("calls", []):
                 if count > 20:
                     break # Keep it readable
                 lines.append(f"    {clean_file} --> {call}")
                 count += 1
-                
+
         return "## ðŸ”— Code Call Graph\n\n```mermaid\n" + "\n".join(lines) + "\n```"
 
     def generate_3d_swarm_data(self) -> dict[str, Any]:
@@ -236,7 +252,7 @@ class VisualizerAgent(BaseAgent):
             {"source": "SecurityAudit", "target": "PrivacyGuard", "value": 0.5},
             {"source": "CoderAgent", "target": "ByzantineConsensus", "value": 0.8}
         ]
-        
+
         return {
             "format": "v1-3d-swarm",
             "nodes": nodes,
@@ -249,4 +265,4 @@ class VisualizerAgent(BaseAgent):
 
     def improve_content(self, prompt: str) -> str:
         """Visualizes the workspace by default."""
-        return self.generate_call_graph()
\ No newline at end of file
+        return self.generate_call_graph()
