diff --git a/src/core/base/managers/PluginManager.py b/src/core/base/managers/PluginManager.py
index 1c904fc..2cabe1c 100644
--- a/src/core/base/managers/PluginManager.py
+++ b/src/core/base/managers/PluginManager.py
@@ -13,12 +13,13 @@
 # limitations under the License.
 
 from __future__ import annotations
+from typing import Any
 import importlib
 import json
 import logging
 from dataclasses import dataclass
 from pathlib import Path
-from typing import Dict, List, Optional, TYPE_CHECKING
+from typing import TYPE_CHECKING
 from src.core.base.version import SDK_VERSION
 
 if TYPE_CHECKING:
@@ -30,6 +31,16 @@ try:
 except ImportError:
     VersionGate = None
 
+
+
+
+
+
+
+
+
+
+
 @dataclass
 class PluginMetadata:
     """Strictly typed metadata for a plugin."""
@@ -38,17 +49,27 @@ class PluginMetadata:
     needs_fleet: bool = True
     min_sdk_version: str = "1.0.0"
     version: str = "0.1.0"
+
+
+
+
+
     author: str = "Unknown"
     description: str = ""
     permissions: list[str] = None
     restricted_mode: bool = False
 
+
+
+
+
+
 class PluginManager:
     """
     Modernized PluginManager (Phase 226).
     Handles discovery, manifest enforcement, health tracking, and graceful shutdown.
     """
-    
+
     def __init__(self, workspace_root: Path | None = None) -> None:
         self.workspace_root = workspace_root or Path.cwd()
         self.plugins_dir = self.workspace_root / "plugins"
@@ -56,7 +77,7 @@ class PluginManager:
         self.loaded_meta: dict[str, PluginMetadata] = {}
         self.active_plugins: dict[str, AgentPluginBase] = {}
         self.logger = logging.getLogger("PluginManager")
-        
+
         if not self.plugins_dir.exists():
             try:
                 self.plugins_dir.mkdir(parents=True, exist_ok=True)
@@ -66,7 +87,7 @@ class PluginManager:
     def discover(self) -> list[str]:
         """Scans manifest and directory for compatible plugins."""
         discovered = []
-        
+
         # 1. Manifest Enforcement (Priority)
         if self.registry_path.exists():
             try:
@@ -95,15 +116,15 @@ class PluginManager:
                             self.logger.error(f"Malformed metadata for '{key}': {e}")
             except Exception as e:
                 self.logger.error(f"Failed to read manifest: {e}")
-        
+
         # 2. Dynamic Directory Scan (Flexible Fallback)
         for item in self.plugins_dir.iterdir():
             if item.name == "manifest.json" or item.stem in discovered or item.name.startswith("__"):
                 continue
-            
+
             permissions = None
             restricted = False
-            
+
             # Phase 288: Check for permissions.json in plugin folder
             if item.is_dir():
                 perm_file = item / "permissions.json"
@@ -126,20 +147,20 @@ class PluginManager:
                     restricted_mode=restricted
                 )
                 self.logger.debug(f"Dynamically discovered '{plugin_name}' (Restricted: {restricted})")
-                
+
         return discovered
 
     def validate_version(self, required_version: str) -> bool:
         """Centralized semantic version gatekeeper."""
         if not VersionGate:
-            return True 
+            return True
         return VersionGate.is_compatible(SDK_VERSION, required_version)
 
     def load_plugin(self, plugin_name: str) -> AgentPluginBase | None:
         """Loads and initializes a plugin instance."""
         if plugin_name not in self.loaded_meta:
             return None
-        
+
         meta = self.loaded_meta[plugin_name]
         try:
             # Phase 288: Handle Restricted Mode
@@ -149,16 +170,16 @@ class PluginManager:
 
             module = importlib.import_module(meta.module_path)
             plugin_class = getattr(module, meta.class_name)
-            
+
             instance = plugin_class()
             instance.setup()
-            
+
             # Health check immediately after setup
             health = instance.health_check()
             if health.status != "healthy":
                 self.logger.error(f"Plugin '{plugin_name}' failed health check: {health.message}")
                 return None
-            
+
             self.active_plugins[plugin_name] = instance
             return instance
         except Exception as e:
@@ -185,7 +206,7 @@ class PluginManager:
         module = importlib.import_module(meta.module_path)
         plugin_class = getattr(module, meta.class_name)
         instance = plugin_class()
-        
+
         # Wrap the 'run' method to enforce permissions
         original_run = instance.run
         allowed_permissions = meta.permissions or []
@@ -195,7 +216,7 @@ class PluginManager:
             if "read:src" not in allowed_permissions and "src" in str(file_path):
                 self.logger.error(f"Permission Denied: Plugin '{name}' attempted to read 'src' path without 'read:src' permission.")
                 return False
-            
+
             # Enforce "write:temp" (Mock check)
             # In a real proxy, we would intercept OS calls, but here we check the file_path passed to run()
             return original_run(file_path, context)
@@ -226,4 +247,4 @@ class PluginManager:
                 self.active_plugins[name].shutdown()
                 del self.active_plugins[name]
             except Exception as e:
-                self.logger.error(f"Deactivation failed for '{name}': {e}")
\ No newline at end of file
+                self.logger.error(f"Deactivation failed for '{name}': {e}")
