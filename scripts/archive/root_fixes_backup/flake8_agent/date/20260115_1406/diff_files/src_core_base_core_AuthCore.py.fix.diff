diff --git a/src/core/base/core/AuthCore.py b/src/core/base/core/AuthCore.py
index 82c34a9..9f34d81 100644
--- a/src/core/base/core/AuthCore.py
+++ b/src/core/base/core/AuthCore.py
@@ -1,35 +1,77 @@
 
 from __future__ import annotations
+from typing import Any
 import hashlib
 import time
 from dataclasses import dataclass
 
+try:
+    import rust_core as rc
+except ImportError:
+    rc: Any = None  # type: ignore[no-redef]
+
+
+
+
+
+
+
+
+
+
+
 @dataclass(frozen=True)
 class AuthProof:
+
+
+
+
+
+    """Authentication proof container for agent validation."""
     timestamp: float
     challenge: str
     proof: str
 
+
+
+
+
+
 class AuthCore:
     """Pure logic for zero-knowledge-style agent authentication.
     Handles challenge-response generation without secret exposure.
     """
-    
+
     def generate_challenge(self, agent_id: str) -> str:
         """Generates a unique challenge for an agent."""
+        if rc:
+            try:
+                return rc.generate_challenge(agent_id)  # type: ignore[attr-defined]
+            except Exception:
+                pass
         seed = f"{agent_id}_{time.time()}_{hashlib.sha256(str(time.time()).encode()).hexdigest()}"
         return hashlib.sha256(seed.encode()).hexdigest()
 
     def generate_proof(self, challenge: str, secret_key: str) -> str:
         """Generates a proof for a challenge using a secret key."""
+        if rc:
+            try:
+                return rc.generate_auth_proof(challenge, secret_key)  # type: ignore[attr-defined]
+            except Exception:
+                pass
         return hashlib.sha512(f"{challenge}:{secret_key}".encode()).hexdigest()
 
     def verify_proof(self, challenge: str, proof: str, expected_secret_hash: str) -> bool:
         """Verifies proof against the expected secret hash without knowing the secret."""
+        if rc:
+            try:
+                return rc.verify_auth_proof(challenge, proof, expected_secret_hash)  # type: ignore[attr-defined]
+            except Exception:
+                pass
         # Simulated ZK verify: In a real ZK, we wouldn't even need the secret hash here.
         # But for this logic-isolation stage, we use hashed comparison.
         return proof == hashlib.sha512(f"{challenge}:{expected_secret_hash}".encode()).hexdigest()
 
     def is_proof_expired(self, proof_time: float, ttl: int = 60) -> bool:
         """Standard TTL check for authentication proofs."""
-        return (time.time() - proof_time) > ttl
\ No newline at end of file
+        return (time.time() - proof_time) > ttl
