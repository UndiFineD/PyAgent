diff --git a/src/infrastructure/orchestration/ConsensusOrchestrator.py b/src/infrastructure/orchestration/ConsensusOrchestrator.py
index ec739c0..4c5d779 100644
--- a/src/infrastructure/orchestration/ConsensusOrchestrator.py
+++ b/src/infrastructure/orchestration/ConsensusOrchestrator.py
@@ -21,19 +21,24 @@
 from __future__ import annotations
 from src.core.base.version import VERSION
 import logging
-from typing import Dict, List, Any, TYPE_CHECKING
+from typing import Any, TYPE_CHECKING
 
 __version__ = VERSION
 
 if TYPE_CHECKING:
     from src.infrastructure.fleet.FleetManager import FleetManager
 
+
+
+
+
+
 class ConsensusOrchestrator:
     """
     Advanced orchestrator for resolving conflicts between agents using weighted voting
     and a multi-turn debate system.
     """
-    
+
     def __init__(self, fleet: FleetManager) -> None:
         self.fleet = fleet
         self.reputation_scores: dict[str, float] = {} # Agent name -> score (0.0 to 1.0)
@@ -43,20 +48,20 @@ class ConsensusOrchestrator:
         Orchestrates a debate and weighted vote to reach consensus on a task.
         """
         logging.info(f"ConsensusOrchestrator: Resolving conflict for task: {task} using {agents}")
-        
+
         # 1. Gather initial proposals
         proposals = self._collect_proposals(task, agents)
-        
+
         # 2. Conduct Debate (if needed)
         if len(proposals) > 1:
             proposals = self._conduct_debate(task, proposals)
-            
+
         # 3. Weighted Voting
         final_decision = self._weighted_vote(proposals)
-        
+
         # 4. Phase 55: DBFT Block Verification
         self.verify_state_block(task, final_decision)
-        
+
         return final_decision
 
     def verify_state_block(self, task: str, decision: str) -> None:
@@ -68,22 +73,36 @@ class ConsensusOrchestrator:
         import hashlib
         block_content = f"{task}:{decision}"
         block_hash = hashlib.sha256(block_content.encode()).hexdigest()
-        
+
         logging.info(f"DBFT: State Block Signed. Hash: {block_hash}")
-        
+
         # Broadcast to Inter-Fleet Bridge for cross-fleet sync
         if hasattr(self.fleet, 'inter_fleet_bridge'):
             self.fleet.inter_fleet_bridge.broadcast_signal(
-                "CONSENSUS_CRYPTO_VERIFIED", 
+                "CONSENSUS_CRYPTO_VERIFIED",
                 {"task": task, "hash": block_hash}
             )
 
     def _collect_proposals(self, task: str, agents: list[str]) -> list[dict[str, Any]]:
         proposals = []
+        import asyncio
+        loop = None
+        try:
+            loop = asyncio.get_event_loop()
+        except RuntimeError:
+            loop = asyncio.new_event_loop()
+            asyncio.set_event_loop(loop)
+
         for agent_name in agents:
             try:
                 # Call agent to generate a solution
-                res = self.fleet.call_by_capability(f"{agent_name}.process", task=task)
+                coro = self.fleet.call_by_capability(f"{agent_name}.process", task=task)
+                if loop.is_running():
+                    coro.close()
+                    res = f"[DEFERRED] {agent_name} process"
+                else:
+                    res = loop.run_until_complete(coro)
+
                 proposals.append({
                     "agent": agent_name,
                     "content": res,
@@ -104,10 +123,16 @@ class ConsensusOrchestrator:
             for i, p in enumerate(current_proposals):
                 competitors = [cp for j, cp in enumerate(current_proposals) if i != j]
                 context = f"Task: {task}\nYour Proposal: {p['content']}\nOther Proposals: {[cp['content'] for cp in competitors]}"
-                
+
                 try:
                     # Agent critiques and improves its own proposal based on others
-                    refined = self.fleet.call_by_capability(f"{p['agent']}.refine", context=context)
+                    coro = self.fleet.call_by_capability(f"{p['agent']}.refine", context=context)
+                    if loop.is_running():
+                        coro.close()
+                        refined = f"[DEFERRED] {p['agent']} refine"
+                    else:
+                        refined = loop.run_until_complete(coro)
+
                     new_proposals.append({
                         "agent": p["agent"],
                         "content": refined,
@@ -121,7 +146,7 @@ class ConsensusOrchestrator:
     def _weighted_vote(self, proposals: list[dict[str, Any]]) -> str:
         if not proposals:
             return "Consensus failed: No proposals."
-            
+
         # For simplicity in this implementation, we pick the one with highest weight.
         # In a real system, we'd use semantic similarity to group proposals and sum weights.
         best_proposal = max(proposals, key=lambda x: x["weight"])
@@ -134,4 +159,4 @@ class ConsensusOrchestrator:
         """
         current = self.reputation_scores.get(agent_name, 0.5)
         # Moving average update
-        self.reputation_scores[agent_name] = (current * 0.7) + (feedback_score * 0.3)
\ No newline at end of file
+        self.reputation_scores[agent_name] = (current * 0.7) + (feedback_score * 0.3)
