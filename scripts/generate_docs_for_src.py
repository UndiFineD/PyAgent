#!/usr/bin/env python3
"""
Generate description, splice (if multiple classes), improvements, and a basic pytest for each .py in src/.
Skips files that already have the generated outputs to avoid overwriting.
"""
from __future__ import annotations

import ast
import os
from pathlib import Path
import textwrap

ROOT = Path(__file__).resolve().parents[1]
SRC = ROOT / "src"

IMPROVEMENTS_TEMPLATE = textwrap.dedent(
    """
# Improvements: {rel_path}

Suggested improvements (automatically generated):
- Add unit tests covering core behavior and edge cases.
- Break large modules into smaller, testable components.
- Avoid heavy imports at module import time; import lazily where appropriate.
- Add type hints and explicit return types for public functions.
- Add logging and better error handling for file and IO operations.
- Consider dependency injection for filesystem and environment interactions.
"""
)

DESCRIPTION_TEMPLATE = """# Description: {rel_path}

Module docstring (if present):

{module_doc}

Top-level members:
{members}

Notes:
- This description was auto-generated by scripts/generate_docs_for_src.py
"""

SPLICE_TEMPLATE = """# Splice: {rel_path}

This module contains multiple top-level classes/functions which could be split into separate modules:

{splice_items}

Suggested split:
- Separate data models, core logic, and helpers into their own modules to improve testability.
"""

TEST_TEMPLATE = """import importlib


def test_import_{safe_mod_name}():
    mod = importlib.import_module("{import_path}")
    # Basic smoke tests
    assert mod is not None
"""


def summarize_module(path: Path) -> tuple[str, list[str], list[str]]:
    """Return module docstring, list of class names, list of function names."""
    try:
        src = path.read_text(encoding="utf-8")
    except Exception:
        return ("", [], [])
    try:
        tree = ast.parse(src)
    except Exception:
        return ("(unparseable)", [], [])
    doc = ast.get_docstring(tree) or "(No module docstring)"
    classes = [n.name for n in tree.body if isinstance(n, ast.ClassDef)]
    funcs = [n.name for n in tree.body if isinstance(n, ast.FunctionDef)]
    return (doc, classes, funcs)


def write_if_missing(path: Path, content: str) -> None:
    if path.exists():
        return
    path.write_text(content, encoding="utf-8")


def main() -> None:
    count = 0
    for py in SRC.rglob("*.py"):
        # skip __pycache__ and compiled or generated files under target directories
        if "__pycache__" in py.parts:
            continue
        rel = py.relative_to(ROOT)
        rel_path = str(rel).replace('\\', '/')

        module_doc, classes, funcs = summarize_module(py)

        members = []
        if classes:
            members.append("Classes: " + ", ".join(classes))
        if funcs:
            members.append("Functions: " + ", ".join(funcs[:10]))
        members_text = "\n".join(["- " + m for m in members]) if members else "- (no top-level classes or functions)"

        descr = DESCRIPTION_TEMPLATE.format(rel_path=rel_path, module_doc=textwrap.indent(module_doc, '    '), members=members_text)
        descr_path = py.with_name(py.name + ".description.md")
        write_if_missing(descr_path, descr)

        # splice if multiple classes
        if len(classes) > 1:
            splice_items = "\n".join([f"- {c}" for c in classes])
            splice = SPLICE_TEMPLATE.format(rel_path=rel_path, splice_items=splice_items)
            splice_path = py.with_name(py.name + ".splice.md")
            write_if_missing(splice_path, splice)

        improvements = IMPROVEMENTS_TEMPLATE.format(rel_path=rel_path)
        imp_path = py.with_name(py.name + ".improvements.md")
        write_if_missing(imp_path, improvements)

        # Test
        # Build import path: src/<pkg...>/<module>.py -> src.<pkg>.<module>
        parts = py.with_suffix("").parts
        # find index of 'src' in parts
        try:
            idx = parts.index('src')
            mod_parts = parts[idx:]
        except ValueError:
            mod_parts = parts
        import_path = ".".join(mod_parts)
        safe_mod_name = "_".join(mod_parts).replace('.', '_')
        test_content = TEST_TEMPLATE.format(safe_mod_name=safe_mod_name, import_path=import_path)
        test_path = py.with_name(py.stem + "_generated_test.py")
        write_if_missing(test_path, test_content)

        count += 1
    print(f"Generated docs/tests for {count} modules (skipped existing outputs).")


if __name__ == '__main__':
    main()
