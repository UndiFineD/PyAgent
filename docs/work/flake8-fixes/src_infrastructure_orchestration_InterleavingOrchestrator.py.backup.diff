diff --git a/src/infrastructure/orchestration/InterleavingOrchestrator.py b/src/infrastructure/orchestration/InterleavingOrchestrator.py
index f0fe27c..40f28dc 100644
--- a/src/infrastructure/orchestration/InterleavingOrchestrator.py
+++ b/src/infrastructure/orchestration/InterleavingOrchestrator.py
@@ -21,19 +21,24 @@
 from __future__ import annotations
 from src.core.base.version import VERSION
 import logging
-from typing import Dict, List, Any, TYPE_CHECKING
+from typing import Any, TYPE_CHECKING
 
 __version__ = VERSION
 
 if TYPE_CHECKING:
     from src.infrastructure.fleet.FleetManager import FleetManager
 
+
+
+
+
+
 class InterleavingOrchestrator:
     """
-    Advanced orchestrator that implements 'Neural Interleaving' - 
+    Advanced orchestrator that implements 'Neural Interleaving' -
     switching between different reasoning models or agent tiers based on task complexity.
     """
-    
+
     def __init__(self, fleet: FleetManager) -> None:
         self.fleet = fleet
         self.step_history: list[dict[str, Any]] = []
@@ -43,27 +48,39 @@ class InterleavingOrchestrator:
         Executes a task by interleaving different agent capabilities based on dynamic complexity analysis.
         """
         logging.info(f"InterleavingOrchestrator: Beginning interleaved execution for: {task}")
-        
+
         # 1. Complexity Assessment (Uses a lightweight reasoning step)
         complexity_score = self._assess_complexity(task)
         logging.info(f"Complexity Score: {complexity_score}/10")
-        
+
         # 2. Strategy Selection
         strategy = self._select_strategy(complexity_score)
-        
+
         # 3. Interleaved Execution
         results = []
         for stage in strategy["stages"]:
             agent_tier = stage["tier"]
             phase = stage["phase"]
-            
+
             logging.info(f"Interleaving: Routing {phase} to {agent_tier} model tier.")
-            
+
             # Simulate routing to different 'tiers' in FleetManager
             # Tier 1: Small/Fast (Flash), Tier 2: Mid (Pro), Tier 3: Ultra/Deep Reasoning
-            res = self.fleet.call_by_capability(f"{phase}.process", task=task, tier=agent_tier)
+            coro = self.fleet.call_by_capability(f"{phase}.process", task=task, tier=agent_tier)
+            import asyncio
+            try:
+                loop = asyncio.get_event_loop()
+                if loop.is_running():
+                    coro.close()
+                    res = f"[DEFERRED] {phase} process"
+                else:
+                    res = loop.run_until_complete(coro)
+            except Exception:
+                coro.close()
+                res = f"[ERROR] {phase} process"
+
             results.append(f"### {phase} ({agent_tier} tier)\n{res}\n")
-            
+
         return "\n".join(results)
 
     def _assess_complexity(self, task: str) -> int:
@@ -112,7 +129,7 @@ class InterleavingOrchestrator:
                     {"phase": "Execute", "tier": "Standard"}
                 ]
             }
-            
+
     def record_tier_performance(self, task_id: str, tier: str, latency: float, success: bool) -> None:
         """
         Saves performance data to refine future interleaving decisions (Reinforcement Learning signal).
@@ -123,4 +140,4 @@ class InterleavingOrchestrator:
             "latency": latency,
             "success": success
         })
-        # In a real system, this would update RLSelector.py
\ No newline at end of file
+        # In a real system, this would update RLSelector.py
