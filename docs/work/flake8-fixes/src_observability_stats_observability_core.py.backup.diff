diff --git a/src/observability/stats/observability_core.py b/src/observability/stats/observability_core.py
index 5cb9c33..eef5f71 100644
--- a/src/observability/stats/observability_core.py
+++ b/src/observability/stats/observability_core.py
@@ -10,18 +10,23 @@ import zlib
 from enum import Enum
 from datetime import datetime, timedelta
 from dataclasses import dataclass, field
-from typing import Dict, List, Any, Optional, Tuple, Union
+from typing import Any
 
 try:
     import matplotlib.pyplot as plt
     has_matplotlib = True
 except ImportError:
-    plt = None
+    plt = None  # type: ignore[assignment]
     has_matplotlib = False
 from src.core.base.version import VERSION
 
 __version__ = VERSION
 
+
+
+
+
+
 class MetricType(Enum):
     """Types of metrics."""
     COUNTER = "counter"
@@ -29,6 +34,11 @@ class MetricType(Enum):
     HISTOGRAM = "histogram"
     SUMMARY = "summary"
 
+
+
+
+
+
 @dataclass
 class Metric:
     """A single metric."""
@@ -47,6 +57,11 @@ class Metric:
     def __getitem__(self, index: int) -> Any:
         return (self.timestamp, self.value)[index]
 
+
+
+
+
+
 class AlertSeverity(Enum):
     """Alert severity levels."""
     CRITICAL = 5
@@ -55,6 +70,11 @@ class AlertSeverity(Enum):
     LOW = 2
     INFO = 1
 
+
+
+
+
+
 @dataclass
 class Alert:
     """An alert triggered by a threshold breach."""
@@ -66,6 +86,11 @@ class Alert:
     message: str
     timestamp: str
 
+
+
+
+
+
 @dataclass
 class Threshold:
     """Threshold configuration for alerting."""
@@ -81,6 +106,11 @@ class Threshold:
         if self.severity is None:
             self.severity = AlertSeverity.MEDIUM
 
+
+
+
+
+
 @dataclass
 class RetentionPolicy:
     """Policy for data retention."""
@@ -93,6 +123,11 @@ class RetentionPolicy:
     max_points: int = 0
     compression_after_days: int = 7
 
+
+
+
+
+
 @dataclass
 class MetricSnapshot:
     """A snapshot of metrics at a point in time."""
@@ -102,6 +137,11 @@ class MetricSnapshot:
     metrics: dict[str, float]
     tags: dict[str, str] = field(default_factory=lambda: {})
 
+
+
+
+
+
 class AggregationType(Enum):
     """Types of metric aggregation for rollups."""
     SUM = "sum"
@@ -113,6 +153,11 @@ class AggregationType(Enum):
     P95 = "percentile_95"
     P99 = "percentile_99"
 
+
+
+
+
+
 @dataclass
 class MetricNamespace:
     """Namespace for organizing metrics."""
@@ -122,6 +167,11 @@ class MetricNamespace:
     tags: dict[str, str] = field(default_factory=lambda: {})
     retention_days: int = 30
 
+
+
+
+
+
 @dataclass
 class MetricAnnotation:
     """Annotation or comment on a metric."""
@@ -131,6 +181,11 @@ class MetricAnnotation:
     author: str = ""
     annotation_type: str = "info"  # info, warning, milestone
 
+
+
+
+
+
 @dataclass
 class MetricCorrelation:
     """Correlation between two metrics."""
@@ -140,6 +195,11 @@ class MetricCorrelation:
     sample_size: int
     significance: float = 0.0
 
+
+
+
+
+
 @dataclass
 class MetricSubscription:
     """Subscription for metric change notifications."""
@@ -149,6 +209,11 @@ class MetricSubscription:
     notify_on: list[str] = field(default_factory=lambda: ["threshold", "anomaly"])
     min_interval_seconds: int = 60
 
+
+
+
+
+
 class ExportDestination(Enum):
     """Cloud monitoring export destinations."""
     DATADOG = "datadog"
@@ -157,6 +222,11 @@ class ExportDestination(Enum):
     CLOUDWATCH = "cloudwatch"
     STACKDRIVER = "stackdriver"
 
+
+
+
+
+
 @dataclass
 class FederatedSource:
     """A source repository for stats federation."""
@@ -167,12 +237,22 @@ class FederatedSource:
     enabled: bool = True
     metrics: dict[str, float] = field(default_factory=dict)
 
+
+
+
+
+
 class FederationMode(Enum):
     """Federation modes for multi-repo aggregation."""
     PULL = "pull"
     PUSH = "push"
     HYBRID = "hybrid"
 
+
+
+
+
+
 @dataclass
 class RollupConfig:
     """Configuration for metric rollups."""
@@ -182,6 +262,11 @@ class RollupConfig:
     interval_minutes: int = 60
     keep_raw: bool = True
 
+
+
+
+
+
 @dataclass
 class StreamingConfig:
     """Configuration for real-time stats streaming."""
@@ -193,6 +278,11 @@ class StreamingConfig:
     reconnect_attempts: int = 3
     buffer_size: int = 1000
 
+
+
+
+
+
 class StreamingProtocol(Enum):
     """Protocols for real-time stats streaming."""
     WEBSOCKET = "websocket"
@@ -200,6 +290,11 @@ class StreamingProtocol(Enum):
     GRPC = "grpc"
     MQTT = "mqtt"
 
+
+
+
+
+
 @dataclass
 class AgentMetric:
     agent_name: str
@@ -214,9 +309,14 @@ class AgentMetric:
     model: str = "unknown"
     metadata: dict[str, Any] = field(default_factory=dict)
 
+
+
+
+
+
 class ObservabilityCore:
     """Pure logic for processing agent telemetry data."""
-    
+
     def __init__(self) -> None:
         self.metrics_history: list[AgentMetric] = []
 
@@ -228,11 +328,11 @@ class ObservabilityCore:
         """Calculates aggregate stats from history."""
         if not self.metrics_history:
             return {"count": 0, "avg_duration": 0, "total_cost": 0}
-            
+
         total_duration = sum(m.duration_ms for m in self.metrics_history)
         total_cost = sum(m.estimated_cost for m in self.metrics_history)
         count = len(self.metrics_history)
-        
+
         # Breakdown by agent
         by_agent = {}
         for m in self.metrics_history:
@@ -241,7 +341,7 @@ class ObservabilityCore:
             stats = by_agent[m.agent_name]
             stats["count"] += 1
             stats["total_cost"] += m.estimated_cost
-            
+
         return {
             "total_count": count,
             "avg_duration_ms": total_duration / count,
@@ -264,7 +364,7 @@ class ObservabilityCore:
         If no history, defaults to 0.5 (neutral).
         """
         scores: list[float] = []
-        
+
         # Aggregate history per agent
         stats: dict[str, dict[str, int]] = {}
         for m in self.metrics_history:
@@ -273,7 +373,7 @@ class ObservabilityCore:
             stats[m.agent_name]["total"] += 1
             if m.status == "success":
                 stats[m.agent_name]["success"] += 1
-                
+
         for name in agent_names:
             if name in stats and stats[name]["total"] > 0:
                 score = stats[name]["success"] / stats[name]["total"]
@@ -281,9 +381,14 @@ class ObservabilityCore:
             else:
                 # Neutral default for new/unknown agents
                 scores.append(0.5)
-                
+
         return scores
 
+
+
+
+
+
 class StatsCore:
     """Core logic for statistics processing, separated from the Agent shell."""
 
@@ -296,7 +401,7 @@ class StatsCore:
         """Detect if a value is anomalous using standard deviation."""
         if len(history) < 2:
             return False, 0.0
-            
+
         values = [m.value for m in history]
         mean = sum(values) / len(values)
         variance = sum((x - mean) ** 2 for x in values) / len(values)
@@ -367,7 +472,7 @@ class StatsCore:
 
     @staticmethod
     def apply_retention(
-        metrics_dict: dict[str, list[Metric]], 
+        metrics_dict: dict[str, list[Metric]],
         policies: dict[str, RetentionPolicy]
     ) -> int:
         """Apply retention policies to metrics."""
@@ -378,18 +483,23 @@ class StatsCore:
             policy = policies.get(key) or policies.get(namespace)
             if not policy:
                 continue
-            
+
             if policy.max_age_days > 0:
                 cutoff = now - timedelta(days=policy.max_age_days)
                 orig = len(metrics)
                 metrics_dict[key] = [m for m in metrics if datetime.fromisoformat(m.timestamp) > cutoff]
                 removed += orig - len(metrics_dict[key])
-                
+
             if policy.max_points > 0 and len(metrics_dict[key]) > policy.max_points:
                 removed += len(metrics_dict[key]) - policy.max_points
                 metrics_dict[key] = metrics_dict[key][-policy.max_points:]
         return removed
 
+
+
+
+
+
 class StatsNamespace:
     """Represents a namespace for metric isolation."""
     def __init__(self, name: str) -> None:
@@ -415,6 +525,11 @@ class StatsNamespace:
         """Get all metrics in namespace."""
         return self.metrics
 
+
+
+
+
+
 class StatsNamespaceManager:
     """Manages multiple namespaces."""
     def __init__(self) -> None:
@@ -434,6 +549,11 @@ class StatsNamespaceManager:
         """Get a namespace."""
         return self.namespaces.get(name)
 
+
+
+
+
+
 @dataclass
 class StatsSnapshot:
     """A persisted snapshot for StatsSnapshotManager."""
@@ -442,6 +562,11 @@ class StatsSnapshot:
     data: dict[str, Any]
     timestamp: str
 
+
+
+
+
+
 @dataclass
 class StatsSubscription:
     """A subscription entry for StatsSubscriptionManager."""
@@ -452,6 +577,11 @@ class StatsSubscription:
     delivery_method: str
     created_at: str
 
+
+
+
+
+
 @dataclass
 class ThresholdAlert:
     """A single threshold alert emitted by ThresholdAlertManager."""
@@ -461,9 +591,14 @@ class ThresholdAlert:
     severity: str
     threshold: float
 
+
+
+
+
+
 @dataclass
 class DerivedMetric:
     name: str
     dependencies: list[str]
     formula: str
-    description: str = ""
\ No newline at end of file
+    description: str = ""
