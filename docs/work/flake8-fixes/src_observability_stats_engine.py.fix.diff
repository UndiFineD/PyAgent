diff --git a/src/observability/stats/engine.py b/src/observability/stats/engine.py
index 6fe3b39..46bc1a2 100644
--- a/src/observability/stats/engine.py
+++ b/src/observability/stats/engine.py
@@ -6,14 +6,25 @@ from __future__ import annotations
 import logging
 import time
 from pathlib import Path
-from typing import Any, Dict, List, Optional
+from typing import Any
 from .alerting import ThresholdAlertManager
-from .analysis import StatsQueryEngine, StatsRollupCalculator, TokenCostEngine
+from .analysis import TokenCostEngine
+from .rollup_engine import StatsQueryEngine, StatsRollupCalculator
 from .exporters import MetricsExporter, OTelManager, PrometheusExporter
 from .metrics import AgentMetric, Metric
 
 logger = logging.getLogger(__name__)
 
+
+
+
+
+
+
+
+
+
+
 class ObservabilityCore:
     """Pure logic for processing agent telemetry data."""
     def __init__(self) -> None:
@@ -26,11 +37,21 @@ class ObservabilityCore:
     def summarize_performance(self) -> dict[str, Any]:
         if not self.metrics_history:
             return {"count": 0, "avg_duration": 0, "total_cost": 0}
+
+
+
+
+
         total_d = sum(m.duration_ms for m in self.metrics_history)
         total_c = sum(m.estimated_cost for m in self.metrics_history)
         count = len(self.metrics_history)
         return {"total_count": count, "avg_duration_ms": total_d / count, "total_cost_usd": round(total_c, 6)}
 
+
+
+
+
+
 class ObservabilityEngine:
     """Provides telemetry and performance tracking for the agent fleet."""
     def __init__(self, workspace_root:
@@ -56,24 +77,44 @@ class ObservabilityEngine:
         if trace_id not in self._start_times:
             return
         duration = (time.time() - self._start_times.pop(trace_id)) * 1000
+
+
+
+
+
         span_id = self._otel_spans.pop(trace_id, None)
         if span_id:
             self.otel.end_span(span_id, status=status, attributes=metadata)
-        
+
         cost = self.cost_engine.calculate_cost(model, in_t, out_t)
-        metric = AgentMetric(agent_name=agent, operation=op, duration_ms=duration, status=status, 
+        metric = AgentMetric(agent_name=agent, operation=op, duration_ms=duration, status=status,
                              input_tokens=in_t, output_tokens=out_t, estimated_cost=cost, model=model, metadata=metadata or {})
         self.core.process_metric(metric)
         self.metrics_exporter.record_agent_call(agent, duration, status == "success")
 
+
+
+
+
+
 class StatsCore:
     """Core logic for statistics processing."""
     def __init__(self) -> None:
+
+
+
+
+
         self.namespaces: dict[str, list[Metric]] = {}
         self.rollup = StatsRollupCalculator()
         self.query = StatsQueryEngine()
         self.alerts = ThresholdAlertManager()
 
+
+
+
+
+
     def record(self, metric:
         Metric) -> None:
         ns = metric.namespace
@@ -84,13 +125,23 @@ class StatsCore:
         self.query.add_metric(metric.name, metric)
         self.alerts.check(metric.name, metric.value)
 
+
+
+
+
+
 class StatsNamespaceManager:
     """Manages multiple namespaces (backward compat)."""
     def __init__(self) -> None:
         self.namespaces: dict[str, Any] = {}
+
+
+
+
+
     def create(self, name:
         str) -> Any:
         from .metrics import StatsNamespace
         ns = StatsNamespace(name)
         self.namespaces[name] = ns
-        return ns
\ No newline at end of file
+        return ns
