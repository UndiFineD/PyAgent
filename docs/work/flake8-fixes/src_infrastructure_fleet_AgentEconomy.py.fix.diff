diff --git a/src/infrastructure/fleet/AgentEconomy.py b/src/infrastructure/fleet/AgentEconomy.py
index 04739c0..a1699dc 100644
--- a/src/infrastructure/fleet/AgentEconomy.py
+++ b/src/infrastructure/fleet/AgentEconomy.py
@@ -28,30 +28,50 @@ import logging
 import time
 import hashlib
 import json
-from typing import Dict, List, Any, Optional
+from typing import Any
 from src.infrastructure.fleet.core.EconomyCore import EconomyCore
 
+
+
+
+
+
+
+
+
+
+
 class MarketPricingEngine:
     """Calculates dynamic pricing based on system load and hardware specs."""
-    
+
     @staticmethod
     def calculate_price(base_price: float, resource_stats: dict[str, Any]) -> float:
         """Applies multipliers based on CPU/GPU demand."""
         multiplier = 1.0
-        
+
         # Load-based surcharge
         if resource_stats.get("status") == "CRITICAL":
             multiplier *= 2.5
         elif resource_stats.get("status") == "WARNING":
             multiplier *= 1.5
-            
+
         # Hardware-based premium
         gpu = resource_stats.get("gpu", {})
+
+
+
+
+
         if gpu.get("available"):
             multiplier *= 2.0 # GPU turns are premium
-            
+
         return base_price * multiplier
 
+
+
+
+
+
 class AgentEconomy:
     """Manages internal marketplace credits and task bidding."""
 
@@ -84,10 +104,10 @@ class AgentEconomy:
         if s_bal < amount:
             logging.warning(f"Transfer failed: {sender} has insufficient funds ({s_bal} < {amount})")
             return False
-            
+
         self.balances[sender] = s_bal - amount
         self.balances[receiver] = self.get_balance(receiver) + amount
-        
+
         # Record to immutable log
         self._record_transaction(sender, receiver, amount, reason)
         return True
@@ -97,10 +117,10 @@ class AgentEconomy:
         balance = self.get_balance(agent_id)
         if bid_amount > balance:
             return False
-            
+
         priority = EconomyCore.calculate_bid_priority(bid_amount, importance, 0.5)
         logging.info(f"AgentEconomy: Agent {agent_id} bidding {bid_amount} credits. Priority: {priority:.2f}")
-        
+
         # Threshold for high priority
         if priority > 100.0:
             self.transfer_credits(agent_id, "SYSTEM_GPU_POOL", bid_amount, "GPU_PRIORITY_BID")
@@ -115,7 +135,7 @@ class AgentEconomy:
             "reason": reason,
             "timestamp": time.time()
         }
-        
+
         prev_block: dict[str, Any] = self.blockchain[-1]
         new_block = {
             "index": len(self.blockchain),
@@ -127,6 +147,11 @@ class AgentEconomy:
         self.blockchain.append(new_block)
         logging.info(f"Transaction recorded: {sender} -> {receiver} ({amount} credits)")
 
+
+
+
+
+
     def place_bid(self, agent_id: str, task_id: str, bid_amount: float) -> dict[str, Any]:
         """Submits a bid for a task."""
         return {
@@ -136,9 +161,14 @@ class AgentEconomy:
             "timestamp": time.time()
         }
 
+
+
+
+
+
 class AuctionOrchestrator:
     """Orchestrates auctions for task allocation across the swarm."""
-    
+
     def __init__(self, economy: AgentEconomy) -> None:
         self.economy = economy
         self.active_auctions: dict[str, dict[str, Any]] = {}
@@ -161,7 +191,7 @@ class AuctionOrchestrator:
         auction = self.active_auctions.get(task_id)
         if not auction or auction["type"] != "dutch":
             return 0.0
-            
+
         elapsed = time.time() - auction["start_time"]
         decay_rate = 0.1 # Price drops by 10% per second
         current_price = auction["initial_price"] * (1.0 - (elapsed * decay_rate))
@@ -171,9 +201,9 @@ class AuctionOrchestrator:
         """Submits a bid to an active auction."""
         if task_id not in self.active_auctions or self.active_auctions[task_id]["status"] != "active":
             return False
-            
+
         auction = self.active_auctions[task_id]
-        
+
         # Dutch auction special handling
         if auction["type"] == "dutch":
             current_price = self.get_current_dutch_price(task_id)
@@ -192,7 +222,7 @@ class AuctionOrchestrator:
         # Verify balance for sealed-bid
         if self.economy.get_balance(agent_id) < bid_amount:
             return False
-            
+
         auction["bids"].append({
             "agent_id": agent_id,
             "amount": bid_amount,
@@ -217,27 +247,37 @@ class AuctionOrchestrator:
         """Resolves the auction and returns the winner and the price to pay."""
         if task_id not in self.active_auctions:
             return None
-            
+
         auction = self.active_auctions[task_id]
         if not auction["bids"]:
             auction["status"] = "failed"
             return None
-            
+
         # Sort by effective bid
         sorted_bids = sorted(auction["bids"], key=lambda x: x["effective_bid"], reverse=True)
+
+
+
+
+
         winner = sorted_bids[0]
-        
+
         # In a Vickrey auction, winner pays the second-highest bid price
         payment_price = sorted_bids[1]["amount"] if len(sorted_bids) > 1 else auction["reserve_price"]
-        
+
         auction["status"] = "closed"
         auction["winner"] = winner["agent_id"]
         auction["final_price"] = payment_price
-        
+
         return {
             "task_id": task_id,
             "winner": winner["agent_id"],
             "payment": payment_price
         }
 
-__version__ = VERSION
\ No newline at end of file
+
+
+
+
+
+__version__ = VERSION
