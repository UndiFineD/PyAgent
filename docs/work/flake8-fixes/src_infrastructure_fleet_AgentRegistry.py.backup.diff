diff --git a/src/infrastructure/fleet/AgentRegistry.py b/src/infrastructure/fleet/AgentRegistry.py
index e0876ef..3b4aa65 100644
--- a/src/infrastructure/fleet/AgentRegistry.py
+++ b/src/infrastructure/fleet/AgentRegistry.py
@@ -26,7 +26,7 @@ import importlib
 import logging
 import os
 import json
-from typing import Dict, Any, Tuple, Optional, List
+from typing import Any
 from collections.abc import Iterable
 from pathlib import Path
 from .ResilientStubs import ResilientStub
@@ -38,6 +38,11 @@ from src.core.base.version import SDK_VERSION
 # Import local version for gatekeeping
 __version__ = VERSION
 
+
+
+
+
+
 class LazyAgentMap(dict):
     """A dictionary that instantiates agents only when they are first accessed."""
     def __init__(self, workspace_root: Path, registry_configs: dict[str, tuple] = None, fleet_instance=None) -> None:
@@ -48,10 +53,10 @@ class LazyAgentMap(dict):
         self._instances: dict[str, Any] = {}
         # Refactored: Logic delegated to Core (Rust-ready)
         self.core = AgentRegistryCore(SDK_VERSION)
-        
+
         # 1. Load Manifest (Plugins)
         self._manifest_configs = self._load_manifests()
-        
+
         # 2. Dynamic Discovery (The most lazy/flexible)
         # Pre-scan ensures we know what's available without guessing inside __getitem__
         discovered_files = self._scan_workspace_for_agents()
@@ -61,13 +66,16 @@ class LazyAgentMap(dict):
     def _scan_workspace_for_agents(self) -> list[str]:
         """Performs the I/O-bound scanning of the workspace."""
         subdirs = [
-            "src/logic/agents/cognitive", 
-            "src/logic/agents/development", 
+            "src/logic/agents/cognitive",
+            "src/logic/agents/development",
             "src/logic/agents/infrastructure",
             "src/logic/agents/security",
             "src/logic/agents/swarm",
             "src/logic/agents/system",
             "src/logic/agents/specialized",
+            "src/logic/agents/intelligence",
+            "src/logic/agents/compliance",
+            "src/logic/agents/documentation",
             "plugins"
         ]
         found_paths = []
@@ -75,11 +83,18 @@ class LazyAgentMap(dict):
             search_root = self.workspace_root / subdir
             if not search_root.exists():
                 continue
-            # Phase 116: Fast Scan Logic
             # Optimization: Only list files to avoid deep recursion if not needed,
             # but keep os.walk for legacy plugin support.
             for root, _, files in os.walk(search_root):
+                # Phase 117: Exclude non-agent directories
+                if "context" in Path(root).parts or "models" in Path(root).parts or "utils" in Path(root).parts:
+                    continue
+
                 for file in files:
+                    # Phase 130: Exclude known data classes/enums/utilities
+                    if file in ["ValidationRule.py", "ChangelogEntry.py", "VersioningStrategy.py"]:
+                        continue
+
                     if file.endswith(".py") and not file.startswith("__"):
                         full_path = Path(root) / file
                         rel_path = full_path.relative_to(self.workspace_root)
@@ -127,7 +142,7 @@ class LazyAgentMap(dict):
         # Build dependency graph from all configs
         all_configs = {**self.registry_configs, **self._manifest_configs, **self._discovered_configs}
         dep_graph: dict[str, list[str]] = {}
-        
+
         # Simple heuristic: look for agent names in the config string/list
         for agent_name, cfg in all_configs.items():
             deps = []
@@ -136,7 +151,7 @@ class LazyAgentMap(dict):
                 if other_name.lower() in cfg_str and other_name != agent_name:
                     deps.append(other_name)
             dep_graph[agent_name] = deps
-            
+
         cycles = self.core.detect_circular_dependencies(dep_graph)
         if cycles:
             for cycle in cycles:
@@ -172,23 +187,23 @@ class LazyAgentMap(dict):
         # 0. Check for manual overrides/instances first
         if key in self._instances:
             return self._instances[key]
-        
+
         # Also check dict itself (if manually assigned)
         if super().__contains__(key):
             return super().__getitem__(key)
-            
+
         # 1. Priority 1: Hardcoded configs (Essential bootstrap functions)
         if key in self.registry_configs:
             return self._instantiate(key, self.registry_configs[key])
-        
+
         # Priority 2: Manifest configs (Registered plugins)
         if key in self._manifest_configs:
             return self._instantiate(key, self._manifest_configs[key])
-            
+
         # Priority 3: Discovered from File System (Dynamic/Flexible)
         if key in self._discovered_configs:
             return self._instantiate(key, self._discovered_configs[key])
-        
+
         # Priority 4: Case-insensitive fallback for discovered agents (Phase 104: underscore tolerant)
         k_norm = key.lower().replace("_", "")
         for d_key, d_cfg in self._discovered_configs.items():
@@ -200,7 +215,7 @@ class LazyAgentMap(dict):
     def _instantiate(self, key: str, config: tuple[str, str, str | None]) -> Any:
         """Standard instantiation logic with dependency injection and version checks."""
         module_path, class_name, arg_path_suffix = config
-        
+
         # Special Logic for MCP Bridge
         if module_path == "mcp":
             try:
@@ -215,7 +230,7 @@ class LazyAgentMap(dict):
 
         try:
             module: importlib.ModuleType = importlib.import_module(module_path)
-            
+
             # Version Gatekeeping (Shell layer check using Core logic)
             min_sdk: Any | str = getattr(module, "SDK_REQUIRED", getattr(module, "__min_sdk__", "1.0.0"))
             if not self.core.is_compatible(min_sdk):
@@ -236,7 +251,7 @@ class LazyAgentMap(dict):
                         agent_class = getattr(module, "Agent")
                     except AttributeError:
                         raise AttributeError(f"Module '{module_path}' has no attribute '{class_name}' or variants.")
-            
+
             # Phase 105: Default to workspace root if no specific arg provided (BaseAgent compatibility)
             arg = None
             if arg_path_suffix:
@@ -244,18 +259,18 @@ class LazyAgentMap(dict):
                 arg = str(potential_p) if potential_p.exists() else arg_path_suffix
             else:
                 arg = str(self.workspace_root)
-            
+
             # Attempt instantiation with arg, fallback to no-arg if it fails (not all are BaseAgents)
             try:
                 instance = agent_class(arg)
             except TypeError:
                 instance = agent_class()
-            
+
             # Fleet Injection and Tool Registration
             if self.fleet:
                 if hasattr(instance, 'fleet') and getattr(instance, 'fleet', None) is None:
                     instance.fleet = self.fleet
-                
+
                 # Check for tool registration capability
                 if hasattr(instance, 'register_tools') and hasattr(self.fleet, 'registry'):
                     try:
@@ -285,9 +300,14 @@ class LazyAgentMap(dict):
         # Allow manual overrides or additions (like SignalBus)
         self._instances.update(other)
 
+
+
+
+
+
 class AgentRegistry:
     """Registry for mapping agent names to their implementations via lazy loading."""
-    
+
     @staticmethod
     def get_agent_map(workspace_root: Path, fleet_instance=None) -> LazyAgentMap:
         """
@@ -295,4 +315,4 @@ class AgentRegistry:
         Most agents are now dynamically discovered via AgentRegistryCore.scan_directory_for_agents().
         Only bootstrap-critical agents in BootstrapConfigs.py remain relatively static.
         """
-        return LazyAgentMap(workspace_root, BOOTSTRAP_AGENTS, fleet_instance)
\ No newline at end of file
+        return LazyAgentMap(workspace_root, BOOTSTRAP_AGENTS, fleet_instance)
