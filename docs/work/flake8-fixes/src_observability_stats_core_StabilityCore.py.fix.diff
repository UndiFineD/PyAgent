diff --git a/src/observability/stats/core/StabilityCore.py b/src/observability/stats/core/StabilityCore.py
index 16368da..27d9128 100644
--- a/src/observability/stats/core/StabilityCore.py
+++ b/src/observability/stats/core/StabilityCore.py
@@ -1,36 +1,78 @@
 
 from __future__ import annotations
-from typing import List
 from dataclasses import dataclass
 
+try:
+    import rust_core as rc
+except ImportError:
+    rc = None  # type: ignore[assignment]
+
+
+
+
+
+
+
+
+
+
+
 @dataclass(frozen=True)
 class FleetMetrics:
+
+
+
+
+
     avg_error_rate: float
     total_token_out: int
     active_agent_count: int
     latency_p95: float
 
+
+
+
+
+
 class StabilityCore:
     """Pure logic for calculating fleet stability and reasoning coherence.
     Integrates SAE activation metrics and error trends into a unified score.
     """
-    
+
     def calculate_stability_score(self, metrics: FleetMetrics, sae_anomalies: int) -> float:
         """Calculates a stability score from 0.0 to 1.0."""
+        if rc:
+            try:
+                # Passing dataclass fields manually or as dict
+                m_dict = {
+                    "avg_error_rate": metrics.avg_error_rate,
+                    "total_token_out": metrics.total_token_out,
+                    "active_agent_count": metrics.active_agent_count,
+                    "latency_p95": metrics.latency_p95
+                }
+                return rc.calculate_stability_score(m_dict, sae_anomalies)  # type: ignore[attr-defined]
+            except Exception:
+                pass
+
         # Baseline: 1.0
         # Deductions: error_rate * 5.0, sae_anomalies * 0.05, latency_p95 overhead
-        
+
         score = 1.0
         score -= (metrics.avg_error_rate * 5.0)
         score -= (sae_anomalies * 0.05)
-        
+
         latency_penalty = max(0.0, (metrics.latency_p95 - 2000) / 10000)
         score -= latency_penalty
-        
+
         return min(max(score, 0.0), 1.0)
 
     def is_in_stasis(self, score_history: list[float]) -> bool:
         """Determines if the swarm is in 'Digital Stasis' (too rigid)."""
+        if rc:
+            try:
+                return rc.is_in_stasis(score_history)  # type: ignore[attr-defined]
+            except Exception:
+                pass
         if len(score_history) < 10:
             return False
         variance = sum((x - sum(score_history)/len(score_history))**2 for x in score_history) / len(score_history)
@@ -38,6 +80,11 @@ class StabilityCore:
 
     def get_healing_threshold(self, stability_score: float) -> float:
         """Returns the threshold for triggering self-healing subroutines."""
+        if rc:
+            try:
+                return rc.get_healing_threshold(stability_score)  # type: ignore[attr-defined]
+            except Exception:
+                pass
         if stability_score < 0.3:
             return 0.9 # Aggressive healing
-        return 0.5
\ No newline at end of file
+        return 0.5
