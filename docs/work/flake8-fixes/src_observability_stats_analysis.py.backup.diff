diff --git a/src/observability/stats/analysis.py b/src/observability/stats/analysis.py
index b722027..ba0184f 100644
--- a/src/observability/stats/analysis.py
+++ b/src/observability/stats/analysis.py
@@ -11,7 +11,7 @@ import re
 import time
 from dataclasses import dataclass
 from pathlib import Path
-from typing import Any, Dict, List, Optional, Tuple
+from typing import Any
 from .metrics import (
     DerivedMetric,
     MetricCorrelation,
@@ -33,7 +33,7 @@ try:
     import matplotlib.pyplot as plt
     has_matplotlib = True
 except ImportError:
-    plt = None
+    plt = None  # type: ignore[assignment]
 
 # Model costs for TokenCostEngine
 MODEL_COSTS = {
@@ -46,6 +46,11 @@ MODEL_COSTS = {
     "default": {"input": 0.002, "output": 0.006, "total": 0.004}
 }
 
+
+
+
+
+
 @dataclass(frozen=True)
 class ProfileStats:
     function_name: str
@@ -53,11 +58,16 @@ class ProfileStats:
     total_time: float
     per_call: float
 
+
+
+
+
+
 class ProfilingCore:
     """Pure logic for cProfile aggregation and bottleneck analysis."""
     def analyze_stats(self, pstats_obj:
         Any, limit: int = 10) -> list[ProfileStats]:
-        results = []
+        results: list[Any] = []
         pstats_obj.sort_stats('cumulative')
         for func, (cc, nc, tt, ct, callers) in pstats_obj.stats.items():
             if len(results) >= limit:
@@ -78,6 +88,11 @@ class ProfilingCore:
         ProfileStats) -> float:
         return stats.total_time * stats.call_count
 
+
+
+
+
+
 @dataclass(frozen=True)
 class FleetMetrics:
     avg_error_rate: float
@@ -85,6 +100,11 @@ class FleetMetrics:
     active_agent_count: int
     latency_p95: float
 
+
+
+
+
+
 class StabilityCore:
     """Pure logic for calculating fleet stability and reasoning coherence."""
     def calculate_stability_score(self, metrics:
@@ -110,6 +130,11 @@ class StabilityCore:
             return 0.9
         return 0.5
 
+
+
+
+
+
 class TracingCore:
     """distributed tracing and latency breakdown logic."""
     def create_span_context(self, trace_id:
@@ -130,6 +155,11 @@ class TracingCore:
         str, attributes: dict[str, Any]) -> dict[str, Any]:
         return {"timestamp": time.time_ns(), "name": name, "attributes": attributes, "kind": "INTERNAL"}
 
+
+
+
+
+
 class DerivedMetricCalculator:
     """Calculate derived metrics from dependencies using safe AST evaluation."""
     def __init__(self) -> None:
@@ -197,6 +227,11 @@ class DerivedMetricCalculator:
             logger.error(f"Failed to calculate {name}: {e}")
             return None
 
+
+
+
+
+
 class CorrelationAnalyzer:
     """Analyze correlations between metrics."""
     def __init__(self) -> None:
@@ -226,6 +261,21 @@ class CorrelationAnalyzer:
         self.correlations.append(res)
         return res
 
+
+
+
+
+
+try:
+    import rust_core as rc
+except ImportError:
+    rc = None  # type: ignore[assignment]
+
+
+
+
+
+
 class FormulaEngineCore:
     """Pure logic core for formula calculations."""
     def __init__(self) -> None:
@@ -249,6 +299,14 @@ class FormulaEngineCore:
 
     def calculate_logic(self, formula:
         str, variables: dict[str, Any]) -> float:
+        if rc and "AVG(" not in formula:
+            try:
+                # Convert variables to dict[str, float] for Rust (excludes list/complex types)
+                float_vars = {k: float(v) for k, v in variables.items() if isinstance(v, (int, float))}
+                return rc.evaluate_formula(formula, float_vars)  # type: ignore[attr-defined]
+            except Exception:
+                pass
+
         if "AVG(" in formula:
             match = re.search(r'AVG\(\{(\w+)\}\)', formula)
             if match and match.group(1) in variables:
@@ -278,10 +336,20 @@ class FormulaEngineCore:
         except Exception as e:
             return {"is_valid": False, "error": str(e)}
 
+
+
+
+
+
 class FormulaEngine:
     def __init__(self) -> None:
         self.formulas: dict[str, str] = {}
         self.core = FormulaEngineCore()
+
+
+
+
+
     def define(self, name:
         str, formula: str) -> None:
         self.formulas[name] = formula
@@ -290,6 +358,11 @@ class FormulaEngine:
         f = self.formulas.get(f_or_n, f_or_n)
         return self.core.calculate_logic(f, variables or {})
 
+
+
+
+
+
 class TokenCostCore:
     def compute_usd(self, model:
         str, in_t: int, out_t: int) -> float:
@@ -297,6 +370,11 @@ class TokenCostCore:
         p = MODEL_COSTS.get(mk) or next((MODEL_COSTS[k] for k in MODEL_COSTS if k != "default" and k in mk), MODEL_COSTS["default"])
         return round((in_t/1000)*p["input"] + (out_t/1000)*p["output"], 6)
 
+
+
+
+
+
 class TokenCostEngine:
     def __init__(self) -> None:
         self.core = TokenCostCore()
@@ -304,6 +382,11 @@ class TokenCostEngine:
         str, input_tokens: int = 0, output_tokens: int = 0) -> float:
         return self.core.compute_usd(model_name, input_tokens, output_tokens)
 
+
+
+
+
+
 class ModelFallbackCore:
     def __init__(self, chains:
         dict[str, list[str]] | None = None) -> None:
@@ -319,6 +402,11 @@ class ModelFallbackCore:
                 return c[c.index(cur)+1]
         return self.chains["economy"][0]
 
+
+
+
+
+
 class ModelFallbackEngine:
     def __init__(self, cost_engine:
         TokenCostEngine | None = None) -> None:
@@ -328,9 +416,19 @@ class ModelFallbackEngine:
         str, research: str = "") -> str | None:
         return self.core.determine_next_model(current_model)
 
+
+
+
+
+
 class StatsRollupCalculator:
     def __init__(self) -> None:
         self._points: dict[str, list[tuple[float, float]]] = {}
+
+
+
+
+
     def add_point(self, m:
         str, ts: float, v: float) -> None:
         if m not in self._points:
@@ -345,11 +443,23 @@ class StatsRollupCalculator:
         amt = int(interval[:-1]) if interval[:-1].isdigit() else 1
         mult = {"m": 60, "h": 3600, "d": 86400}.get(unit, 3600)
         bucket = mult * amt
+
+        if rc:
+            try:
+                return rc.calculate_stats_rollup(pts, bucket)  # type: ignore[attr-defined]
+            except Exception:
+                pass
+
         bkts: dict[int, list[float]] = {}
         for t, v in pts:
             bkts.setdefault(int(t)//int(bucket), []).append(float(v))
         return [sum(bkts[k])/len(bkts[k]) for k in sorted(bkts.keys())]
 
+
+
+
+
+
 class StatsForecaster:
     def predict(self, hist:
         list[float], periods: int = 3) -> list[float]:
@@ -361,6 +471,11 @@ class StatsForecaster:
         diff = last_val - prev_val
         return [last_val + diff * (i + 1) for i in range(periods)]
 
+
+
+
+
+
 class ABComparator:
     def compare(self, a:
         dict[str, float], b: dict[str, float]) -> ABComparisonResult:
@@ -376,13 +491,23 @@ class ABComparator:
         p = 0.01 if abs(eff) >= 1.0 else 0.5
         return ABSignificanceResult(p, p < alpha, eff)
 
+
+
+
+
+
 class ResourceMonitor:
     def __init__(self, workspace_root:
         str) -> None:
         self.workspace_root = Path(workspace_root)
+
+
+
+
+
     def get_current_stats(self) -> dict[str, Any]:
         stats = {"cpu_usage_pct": 0, "memory_usage_pct": 0, "status": "HEALTHY"}
         if HAS_PSUTIL:
             stats["cpu_usage_pct"] = psutil.cpu_percent()
             stats["memory_usage_pct"] = psutil.virtual_memory().percent
-        return stats
\ No newline at end of file
+        return stats
