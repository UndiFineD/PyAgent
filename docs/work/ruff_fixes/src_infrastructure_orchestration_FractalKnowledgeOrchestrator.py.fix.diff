diff --git a/src/infrastructure/orchestration/FractalKnowledgeOrchestrator.py b/src/infrastructure/orchestration/FractalKnowledgeOrchestrator.py
index 5b7b379..45ec3df 100644
--- a/src/infrastructure/orchestration/FractalKnowledgeOrchestrator.py
+++ b/src/infrastructure/orchestration/FractalKnowledgeOrchestrator.py
@@ -21,7 +21,7 @@
 from __future__ import annotations
 from src.core.base.version import VERSION
 import logging
-from typing import Dict, List, Any
+from typing import Any
 
 __version__ = VERSION
 
@@ -36,18 +36,27 @@ class FractalKnowledgeOrchestrator:
         self.fleet = fleet
         self.wisdom_cache: dict[str, Any] = {}
 
-    def synthesize(self, topic: str, agent_names: list[str]) -> dict[str, Any]:
+    async def synthesize(self, topic: str, agent_names: list[str]) -> dict[str, Any]:
         """
         Gathers insights from specific agents and merges them into a fractal summary.
         """
         logging.info(f"FractalKnowledge: Synthesizing wisdom for '{topic}' across {len(agent_names)} agents...")
         
         raw_insights = {}
+        # Use gather for parallel execution
+        import asyncio
+        tasks = []
+        valid_names = []
+        
         for name in agent_names:
             if name in self.fleet.agents:
-                # Consult the agent's expertise
                 agent = self.fleet.agents[name]
-                raw_insights[name] = agent.improve_content(f"Analyze data regarding topic: {topic}")
+                tasks.append(agent.improve_content(f"Analyze data regarding topic: {topic}"))
+                valid_names.append(name)
+        
+        results = await asyncio.gather(*tasks) if tasks else []
+        for name, res in zip(valid_names, results):
+             raw_insights[name] = res
         
         # Real Conflict Resolution logic using AI
         consultation_text = "\n".join([f"Agent {name}: {insight}" for name, insight in raw_insights.items()])
@@ -61,11 +70,14 @@ class FractalKnowledgeOrchestrator:
         )
         
         # Use the first agent's run_subagent capability (shared via fleet)
-        # or assuming LLMClient is available globally
         try:
-             unified_wisdom = self.fleet.agents[agent_names[0]].run_subagent(description, prompt)
+             # Ensure we await the subagent call
+             if valid_names:
+                  unified_wisdom = await self.fleet.agents[valid_names[0]].run_subagent(description, prompt)
+             else:
+                  unified_wisdom = "No agents available."
         except Exception:
-             unified_wisdom = " | ".join(raw_insights.values())
+             unified_wisdom = " | ".join([str(v) for v in raw_insights.values()])
         
         resolution_report = {
             "topic": topic,
