diff --git a/src/core/base/core/IdentityCore.py b/src/core/base/core/IdentityCore.py
index 553a5c5..4bdb1d8 100644
--- a/src/core/base/core/IdentityCore.py
+++ b/src/core/base/core/IdentityCore.py
@@ -5,8 +5,14 @@ import hmac
 from typing import Dict, Any
 from dataclasses import dataclass
 
+try:
+    import rust_core as rc
+except ImportError:
+    rc = None
+
 @dataclass(frozen=True)
 class AgentIdentity:
+    """Immutable identity representation for a peer agent during discovery."""
     agent_id: str
     public_key: str
     claims: dict[str, Any]
@@ -18,15 +24,30 @@ class IdentityCore:
     
     def generate_agent_id(self, public_key: str, metadata: dict[str, Any]) -> str:
         """Generates a stable, unique agent identifier based on public key and metadata."""
+        if rc:
+            try:
+                return rc.generate_agent_id(public_key, metadata)
+            except Exception:
+                pass
         seed = f"{public_key}_{metadata.get('type', 'generic')}_{metadata.get('birth_cycle', 0)}"
         return hashlib.sha256(seed.encode()).hexdigest()[:16]
 
     def sign_payload(self, payload: str, secret_key: str) -> str:
         """Signs a payload using HMAC-SHA256 (simulating Ed25519 signing for pure-python)."""
+        if rc:
+            try:
+                return rc.sign_payload(payload, secret_key)
+            except Exception:
+                pass
         return hmac.new(secret_key.encode(), payload.encode(), hashlib.sha256).hexdigest()
 
     def verify_signature(self, payload: str, signature: str, public_key: str) -> bool:
         """Verifies a payload signature (simulated verification)."""
+        if rc:
+            try:
+                return rc.verify_signature(payload, signature, public_key)
+            except Exception:
+                pass
         # In a real implementation, this would use asymmetrical crypto.
         # For the Core logic, we simulate it by re-signing with the 'public_key' 
         # as a mock secret for consistency.
