diff --git a/tests/unit/infrastructure/test_strategies.py b/tests/unit/infrastructure/test_strategies.py
index 56629c3..87081ad 100644
--- a/tests/unit/infrastructure/test_strategies.py
+++ b/tests/unit/infrastructure/test_strategies.py
@@ -1,6 +1,6 @@
 """Unit tests for agent execution strategies (Direct, CoT, Reflexion)."""
 import unittest
-from unittest.mock import MagicMock, patch
+from unittest.mock import MagicMock, patch, AsyncMock
 import sys
 import os
 from pathlib import Path
@@ -8,17 +8,19 @@ from pathlib import Path
 # Add src to path
 
 from src.core.base.BaseAgent import BaseAgent
-from src.logic.strategies.plan_executor import DirectStrategy, ChainOfThoughtStrategy, ReflexionStrategy
+from src.logic.strategies.DirectStrategy import DirectStrategy
+from src.logic.strategies.ChainOfThoughtStrategy import ChainOfThoughtStrategy
+from src.logic.strategies.ReflexionStrategy import ReflexionStrategy
 
-class TestStrategies(unittest.TestCase):
-    def setUp(self) -> str:
+class TestStrategies(unittest.IsolatedAsyncioTestCase):
+    def setUp(self) -> None:
         # Create a dummy file so BaseAgent init doesn't fail
         with open("test_file.txt", "w") as f:
             f.write("Original Content")
             
         self.agent = BaseAgent("test_file.txt")
         self.agent.previous_content = "Original Content"
-        self.agent.run_subagent = MagicMock(return_value="Improved Content")
+        self.agent.run_subagent = AsyncMock(return_value="Improved Content")
         
         # Disable cache and retries
         self.agent._config.cache_enabled = False
@@ -27,13 +29,13 @@ class TestStrategies(unittest.TestCase):
         # Mock quality check to always pass
         self.agent._score_response_quality = MagicMock(return_value=MagicMock(value=100)) # High value
 
-    def tearDown(self) -> str:
+    def tearDown(self) -> None:
         if os.path.exists("test_file.txt"):
             os.remove("test_file.txt")
 
-    def test_direct_strategy(self) -> None:
+    async def test_direct_strategy(self) -> None:
         self.agent.set_strategy(DirectStrategy())
-        self.agent.improve_content("Fix bugs")
+        await self.agent.improve_content("Fix bugs")
         
         # Check if run_subagent was called once
         self.agent.run_subagent.assert_called_once()
@@ -42,9 +44,9 @@ class TestStrategies(unittest.TestCase):
         # prompt is at index 1
         self.assertIn("Fix bugs", args[0][1]) 
 
-    def test_cot_strategy(self) -> None:
+    async def test_cot_strategy(self) -> None:
         self.agent.set_strategy(ChainOfThoughtStrategy())
-        self.agent.improve_content("Fix bugs")
+        await self.agent.improve_content("Fix bugs")
         
         # Check if run_subagent was called twice (Reasoning + Implementation)
         self.assertEqual(self.agent.run_subagent.call_count, 2)
@@ -57,19 +59,19 @@ class TestStrategies(unittest.TestCase):
         args2 = self.agent.run_subagent.call_args_list[1]
         self.assertIn("Based on the following reasoning", args2[0][1])
 
-    def test_reflexion_strategy(self) -> None:
+    async def test_reflexion_strategy(self) -> None:
         self.agent.set_strategy(ReflexionStrategy())
         # Mock run_subagent to return different values based on prompt
-        def side_effect(desc, prompt, content) -> str:
+        async def side_effect(desc, prompt, content) -> str:
             if "Critique" in prompt:
                 return "Critique: Good but needs X"
             if "Revise" in prompt:
                 return "Revised Content"
             return "Draft Content"
-            
-        self.agent.run_subagent = MagicMock(side_effect=side_effect)
-        
-        self.agent.improve_content("Fix bugs")
+
+        self.agent.run_subagent = AsyncMock(side_effect=side_effect)
+
+        await self.agent.improve_content("Fix bugs")
         
         # Should be called 3 times (Draft, Critique, Revise)
         self.assertEqual(self.agent.run_subagent.call_count, 3)
