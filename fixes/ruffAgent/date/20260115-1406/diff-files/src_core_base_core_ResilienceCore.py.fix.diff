diff --git a/src/core/base/core/ResilienceCore.py b/src/core/base/core/ResilienceCore.py
index fe5840d..8ffd7a5 100644
--- a/src/core/base/core/ResilienceCore.py
+++ b/src/core/base/core/ResilienceCore.py
@@ -15,6 +15,11 @@
 from __future__ import annotations
 import random
 
+try:
+    import rust_core as rc
+except ImportError:
+    rc = None
+
 class ResilienceCore:
     """
     Pure logic for Circuit Breaker and Retry mechanisms.
@@ -34,6 +39,14 @@ class ResilienceCore:
         Phase 145: Enhanced backoff with Full Jitter.
         Prevents thundering herd better than standard 10% jitter.
         """
+        if rc:
+            try:
+                # rc.calculate_backoff(failure_count, threshold, base_timeout, multiplier, max_timeout)
+                # Rust version assumes jitter_mode is full for simplicity if not provided.
+                return rc.calculate_backoff(failure_count, threshold, base_timeout, multiplier, max_timeout)
+            except Exception:
+                pass
+
         if failure_count < threshold:
             return 0.0
         
@@ -58,6 +71,11 @@ class ResilienceCore:
         timeout: float
     ) -> bool:
         """Determines if the cooldown period has passed."""
+        if rc:
+            try:
+                return rc.should_attempt_recovery(last_failure_time, current_time, timeout)
+            except Exception:
+                pass
         return (current_time - last_failure_time) > timeout
 
     @staticmethod
@@ -76,6 +94,18 @@ class ResilienceCore:
             HALF_OPEN -> CLOSED (if success_count >= needed)
             HALF_OPEN -> OPEN (if any failure during half-open)
         """
+        if rc:
+            try:
+                return rc.evaluate_state_transition(
+                    current_state,
+                    success_count,
+                    consecutive_successes_needed,
+                    failure_count,
+                    failure_threshold
+                )
+            except Exception:
+                pass
+
         if current_state == "CLOSED":
             if failure_count >= failure_threshold:
                 return "OPEN"
@@ -83,4 +113,48 @@ class ResilienceCore:
             if success_count >= consecutive_successes_needed:
                 return "CLOSED"
         
-        return current_state
\ No newline at end of file
+        return current_state
+
+    @staticmethod
+    def update_state(
+        current_state: str,
+        is_success: bool,
+        failure_count: int,
+        success_count: int,
+        last_failure_time: float,
+        thresholds: dict[str, Any]
+    ) -> tuple[str, int, int]:
+        """
+        Updates state based on outcome.
+        Returns (new_state, new_failure_count, new_success_count).
+        """
+        failure_threshold = thresholds.get("failure_threshold", 5)
+        consecutive_successes_needed = thresholds.get("consecutive_successes_needed", 3)
+        
+        if is_success:
+            new_success_count = success_count + 1
+            if current_state == "HALF_OPEN":
+                 new_state = ResilienceCore.evaluate_state_transition(
+                    current_state, new_success_count, consecutive_successes_needed, failure_count, failure_threshold
+                )
+                 if new_state == "CLOSED":
+                     return "CLOSED", 0, 0
+                 return current_state, failure_count, new_success_count
+            elif current_state == "CLOSED":
+                 return "CLOSED", 0, 0
+            elif current_state == "OPEN":
+                 # Success in OPEN state implies recovery (e.g. via probe or forced call)
+                 return "CLOSED", 0, 0
+            
+            return current_state, failure_count, new_success_count
+
+        else:
+            new_failure_count = failure_count + 1
+            if current_state == "HALF_OPEN":
+                # Single failure trips back to OPEN
+                return "OPEN", new_failure_count, 0
+            
+            new_state = ResilienceCore.evaluate_state_transition(
+                current_state, success_count, consecutive_successes_needed, new_failure_count, failure_threshold
+            )
+            return new_state, new_failure_count, 0
\ No newline at end of file
