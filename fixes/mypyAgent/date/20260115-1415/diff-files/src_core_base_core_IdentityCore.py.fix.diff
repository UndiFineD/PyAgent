diff --git a/src/core/base/core/IdentityCore.py b/src/core/base/core/IdentityCore.py
index 553a5c5..41565b4 100644
--- a/src/core/base/core/IdentityCore.py
+++ b/src/core/base/core/IdentityCore.py
@@ -2,11 +2,17 @@
 from __future__ import annotations
 import hashlib
 import hmac
-from typing import Dict, Any
+from typing import Any
 from dataclasses import dataclass
 
+try:
+    import rust_core as rc
+except ImportError:
+    rc: Any = None  # type: ignore[no-redef]
+
 @dataclass(frozen=True)
 class AgentIdentity:
+    """Immutable identity representation for a peer agent during discovery."""
     agent_id: str
     public_key: str
     claims: dict[str, Any]
@@ -18,15 +24,30 @@ class IdentityCore:
     
     def generate_agent_id(self, public_key: str, metadata: dict[str, Any]) -> str:
         """Generates a stable, unique agent identifier based on public key and metadata."""
+        if rc:
+            try:
+                return rc.generate_agent_id(public_key, metadata)  # type: ignore[attr-defined]
+            except Exception:
+                pass
         seed = f"{public_key}_{metadata.get('type', 'generic')}_{metadata.get('birth_cycle', 0)}"
         return hashlib.sha256(seed.encode()).hexdigest()[:16]
 
     def sign_payload(self, payload: str, secret_key: str) -> str:
         """Signs a payload using HMAC-SHA256 (simulating Ed25519 signing for pure-python)."""
+        if rc:
+            try:
+                return rc.sign_payload(payload, secret_key)  # type: ignore[attr-defined]
+            except Exception:
+                pass
         return hmac.new(secret_key.encode(), payload.encode(), hashlib.sha256).hexdigest()
 
     def verify_signature(self, payload: str, signature: str, public_key: str) -> bool:
         """Verifies a payload signature (simulated verification)."""
+        if rc:
+            try:
+                return rc.verify_signature(payload, signature, public_key)  # type: ignore[attr-defined]
+            except Exception:
+                pass
         # In a real implementation, this would use asymmetrical crypto.
         # For the Core logic, we simulate it by re-signing with the 'public_key' 
         # as a mock secret for consistency.
@@ -35,4 +56,4 @@ class IdentityCore:
 
     def validate_identity(self, identity: AgentIdentity) -> bool:
         """Ensures the agent identity follows fleet standards."""
-        return len(identity.agent_id) == 16 and "@" not in identity.agent_id
\ No newline at end of file
+        return len(identity.agent_id) == 16 and "@" not in identity.agent_id
