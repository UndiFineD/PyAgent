diff --git a/src/infrastructure/dev/scripts/management/debug_evolution.py b/src/infrastructure/dev/scripts/management/debug_evolution.py
index c559d38..89beef2 100644
--- a/src/infrastructure/dev/scripts/management/debug_evolution.py
+++ b/src/infrastructure/dev/scripts/management/debug_evolution.py
@@ -30,25 +30,35 @@ from src.logic.agents.development.InfrastructureRepairAgent import Infrastructur
 
 __version__ = VERSION
 
+
+
+
+
+
+
+
+
+
+
 def test_evolution_and_repair() -> None:
     """Validate self-generation and self-repair features."""
     logging.basicConfig(level=logging.INFO)
     root = Path(str(Path(__file__).resolve().parents[5]) + "")
     fleet = FleetManager(str(root))
-    
+
     print("--- Phase 14: Agent Self-Generation ---")
     generated_path = fleet.evolution.generate_agent("TestGenerated", "Perform complex math and string analysis")
     print(f"Generated Agent Path: {generated_path}")
     if os.path.exists(generated_path):
         print("Generated file exists.")
-    
+
     print("\n--- Phase 14: Cross-Fleet Knowledge Transfer ---")
     dummy_knowledge = {
         "lessons": [{"failure_context": "API timeout", "correction": "Increase retries"}]
     }
     export_file = fleet.knowledge_transfer.export_knowledge("fleet_A", dummy_knowledge)
     print(f"Knowledge exported to: {export_file}")
-    
+
     imported_data = fleet.knowledge_transfer.import_knowledge(export_file)
     print(f"Imported Lesson: {imported_data['lessons'][0]['failure_context']}")
 
@@ -57,7 +67,7 @@ def test_evolution_and_repair() -> None:
     # We won't actually install anything in the test to avoid side effects, but we'll run the audit
     audit = repair_agent.audit_environment()
     print(f"Environment Audit Status: {audit['status']}")
-    
+
     print("\n--- Phase 14: Loop Detection ---")
     # Simulate a loop in FleetManager
     fleet.register_agent("Dummy", InfrastructureRepairAgent) # Just a placeholder
@@ -68,10 +78,20 @@ def test_evolution_and_repair() -> None:
         {"agent": "Dummy", "action": "audit_environment", "args": []}
     ]
     # We expect it to stop after 3 calls to the same action in the history
+
+
+
+
+
     # Note: FleetManager.action_history is per instance, so multiple calls to execute_workflow will accumulate.
     fleet.execute_workflow("Loop Test", workflow)
-    
+
     print("\nEvolution and self-repair validation COMPLETED.")
 
+
+
+
+
+
 if __name__ == "__main__":
-    test_evolution_and_repair()
\ No newline at end of file
+    test_evolution_and_repair()
