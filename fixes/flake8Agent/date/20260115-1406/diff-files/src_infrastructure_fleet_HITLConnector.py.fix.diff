diff --git a/src/infrastructure/fleet/HITLConnector.py b/src/infrastructure/fleet/HITLConnector.py
index de3390a..a083a4a 100644
--- a/src/infrastructure/fleet/HITLConnector.py
+++ b/src/infrastructure/fleet/HITLConnector.py
@@ -26,7 +26,7 @@ from __future__ import annotations
 from src.core.base.version import VERSION
 import logging
 import time
-from typing import Dict, Any, Optional
+from typing import Any
 from pathlib import Path
 import urllib.parse
 from src.infrastructure.backend.LocalContextRecorder import LocalContextRecorder
@@ -35,6 +35,16 @@ from src.core.base.ConnectivityManager import ConnectivityManager
 # Infrastructure
 __version__ = VERSION
 
+
+
+
+
+
+
+
+
+
+
 class HITLConnector:
     """Manages external communication with humans for high-stakes approvals."""
 
@@ -48,7 +58,7 @@ class HITLConnector:
     def request_approval(self, agent_id: str, task: str, context: Any) -> str:
         """Sends a request for approval to the human operator."""
         approval_id = f"hitl_{int(time.time())}"
-        
+
         # Check connectivity for webhook if present
         if self.webhook_url:
             domain = urllib.parse.urlparse(self.webhook_url).netloc
@@ -66,38 +76,38 @@ class HITLConnector:
             "status": "pending",
             "request_time": time.time()
         }
-        
+
         # Intelligence Harvesting
         if self.recorder:
             self.recorder.record_lesson("hitl_request", {"agent_id": agent_id, "task": task, "approval_id": approval_id})
-            
+
         # Simulate sending to Slack/Discord
         msg = f"[HITL REQUEST] Approval needed for {agent_id} | Task: {task} | ID: {approval_id}"
         logging.warning(msg)
         if self.webhook_url:
             logging.info(f"Notification sent to {self.webhook_url}")
-            
+
         return approval_id
 
     def check_approval_status(self, approval_id: str) -> str:
         """Checks if the human has responded to the request."""
         if approval_id not in self.pending_approvals:
             return "not_found"
-            
+
         # In a real scenario, this would check a database or webhook callback
         # For simulation, we'll auto-approve 50% of the time after 5 seconds
         req = self.pending_approvals[approval_id]
         if time.time() - req["request_time"] > 5:
             req["status"] = "approved"
-            
+
             # Intelligence Harvesting
             if self.recorder:
                 self.recorder.record_lesson("hitl_approved", {"approval_id": approval_id, "agent_id": req.get("agent_id")})
-                
+
             return "approved"
-            
+
         return "pending"
 
     def get_pending_summary(self) -> dict[str, Any]:
         """Returns all pending requests."""
-        return {k: v for k, v in self.pending_approvals.items() if v["status"] == "pending"}
\ No newline at end of file
+        return {k: v for k, v in self.pending_approvals.items() if v["status"] == "pending"}
