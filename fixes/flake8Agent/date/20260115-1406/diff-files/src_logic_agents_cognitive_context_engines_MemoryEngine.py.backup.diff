diff --git a/src/logic/agents/cognitive/context/engines/MemoryEngine.py b/src/logic/agents/cognitive/context/engines/MemoryEngine.py
index 0036040..f879c36 100644
--- a/src/logic/agents/cognitive/context/engines/MemoryEngine.py
+++ b/src/logic/agents/cognitive/context/engines/MemoryEngine.py
@@ -26,7 +26,7 @@ import json
 import logging
 from datetime import datetime
 from pathlib import Path
-from typing import Any, Dict, List, Optional
+from typing import Any
 from src.logic.agents.cognitive.context.engines.MemoryCore import MemoryCore
 
 __version__ = VERSION
@@ -37,9 +37,14 @@ try:
 except ImportError:
     HAS_CHROMA = False
 
+
+
+
+
+
 class MemoryEngine:
     """Stores and retrieves historical agent contexts and lessons learned."""
-    
+
     def __init__(self, workspace_root: str) -> None:
         self.workspace_root = Path(workspace_root)
         self.memory_file = self.workspace_root / ".agent_memory.json"
@@ -66,7 +71,7 @@ class MemoryEngine:
         """Records an agent's experience with semantic indexing and utility scoring."""
         episode = self.core.create_episode(agent_name, task, outcome, success, metadata)
         self.episodes.append(episode)
-        
+
         # Add to vector db for semantic recall
         collection = self._init_db()
         if collection:
@@ -75,8 +80,8 @@ class MemoryEngine:
                 collection.add(
                     documents=[doc],
                     metadatas=[{
-                        "agent": episode['agent'], 
-                        "success": str(episode['success']), 
+                        "agent": episode['agent'],
+                        "success": str(episode['success']),
                         "timestamp": episode['timestamp'],
                         "utility_score": float(episode['utility_score'])
                     }],
@@ -84,7 +89,7 @@ class MemoryEngine:
                 )
             except Exception as e:
                 logging.error(f"Failed to index memory: {e}")
-                
+
         self.save()
 
     def update_utility(self, memory_id: str, increment: float) -> None:
@@ -92,7 +97,7 @@ class MemoryEngine:
         collection = self._init_db()
         if not collection:
             return
-        
+
         try:
             # Fetch existing metadata
             result = collection.get(ids=[memory_id])
@@ -101,12 +106,12 @@ class MemoryEngine:
                 old_score = float(meta.get('utility_score', 0.5))
                 new_score = self.core.calculate_new_utility(old_score, increment)
                 meta['utility_score'] = new_score
-                
+
                 collection.update(
                     ids=[memory_id],
                     metadatas=[meta]
                 )
-                
+
                 # Update local list too
                 for ep in self.episodes:
                     # Note: memory_id format check or matching logic here
@@ -120,32 +125,32 @@ class MemoryEngine:
             # Return recent high utility episodes
             candidates = [ep for ep in self.episodes if ep.get("utility_score", 0.5) >= min_utility]
             return candidates[-limit:]
-            
+
         collection = self._init_db()
         if collection:
             try:
                 # Build specific filter for utility if Chroma version supports it
                 where_clause = {"utility_score": {"$gte": min_utility}} if min_utility > 0 else None
                 results = collection.query(
-                    query_texts=[query], 
+                    query_texts=[query],
                     n_results=limit,
                     where=where_clause
                 )
-                
+
                 semantic_results = []
                 for i, doc in enumerate(results.get("documents", [[]])[0]):
                     meta = results['metadatas'][0][i]
                     semantic_results.append({
-                        "task": "Semantic Memory", 
-                        "outcome": doc, 
-                        "success": meta.get("success") == "True", 
+                        "task": "Semantic Memory",
+                        "outcome": doc,
+                        "success": meta.get("success") == "True",
                         "agent": meta.get("agent", "Self"),
                         "utility_score": meta.get("utility_score", 0.5)
                     })
                 return semantic_results
             except Exception as e:
                 logging.error(f"Memory search error: {e}")
-            
+
         # Fallback to simple keyword matching
         relevant = []
         q = query.lower()
@@ -161,9 +166,9 @@ class MemoryEngine:
         collection = self._init_db()
         if not collection:
             # Fallback to simple matching if Chroma is not available
-            return [{"content": ep["outcome"], "metadata": {"file_path": ep.get("metadata", {}).get("file_path", "unknown"), "agent": ep["agent"]}, "score": 0.5} 
+            return [{"content": ep["outcome"], "metadata": {"file_path": ep.get("metadata", {}).get("file_path", "unknown"), "agent": ep["agent"]}, "score": 0.5}
                     for ep in self.get_lessons_learned(query, limit)]
-            
+
         try:
             results = collection.query(query_texts=[query], n_results=limit)
             matches = []
@@ -198,4 +203,4 @@ class MemoryEngine:
         """Wipe memory."""
         self.episodes = []
         if self.memory_file.exists():
-            self.memory_file.unlink()
\ No newline at end of file
+            self.memory_file.unlink()
