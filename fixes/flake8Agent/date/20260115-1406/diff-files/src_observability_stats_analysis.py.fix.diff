diff --git a/src/observability/stats/analysis.py b/src/observability/stats/analysis.py
index b722027..435dbe8 100644
--- a/src/observability/stats/analysis.py
+++ b/src/observability/stats/analysis.py
@@ -11,7 +11,7 @@ import re
 import time
 from dataclasses import dataclass
 from pathlib import Path
-from typing import Any, Dict, List, Optional, Tuple
+from typing import Any
 from .metrics import (
     DerivedMetric,
     MetricCorrelation,
@@ -33,7 +33,7 @@ try:
     import matplotlib.pyplot as plt
     has_matplotlib = True
 except ImportError:
-    plt = None
+    plt = None  # type: ignore[assignment]
 
 # Model costs for TokenCostEngine
 MODEL_COSTS = {
@@ -46,18 +46,38 @@ MODEL_COSTS = {
     "default": {"input": 0.002, "output": 0.006, "total": 0.004}
 }
 
+
+
+
+
+
+
+
+
+
+
 @dataclass(frozen=True)
 class ProfileStats:
+
+
+
+
+
     function_name: str
     call_count: int
     total_time: float
     per_call: float
 
+
+
+
+
+
 class ProfilingCore:
     """Pure logic for cProfile aggregation and bottleneck analysis."""
     def analyze_stats(self, pstats_obj:
         Any, limit: int = 10) -> list[ProfileStats]:
-        results = []
+        results: list[Any] = []
         pstats_obj.sort_stats('cumulative')
         for func, (cc, nc, tt, ct, callers) in pstats_obj.stats.items():
             if len(results) >= limit:
@@ -68,6 +88,11 @@ class ProfilingCore:
                 total_time=ct,
                 per_call=ct / cc if cc > 0 else 0
             ))
+
+
+
+
+
         return results
 
     def identify_bottlenecks(self, stats:
@@ -75,9 +100,19 @@ class ProfilingCore:
         return [s.function_name for s in stats if s.total_time > (threshold_ms / 1000.0)]
 
     def calculate_optimization_priority(self, stats:
+
+
+
+
+
         ProfileStats) -> float:
         return stats.total_time * stats.call_count
 
+
+
+
+
+
 @dataclass(frozen=True)
 class FleetMetrics:
     avg_error_rate: float
@@ -85,11 +120,21 @@ class FleetMetrics:
     active_agent_count: int
     latency_p95: float
 
+
+
+
+
+
 class StabilityCore:
     """Pure logic for calculating fleet stability and reasoning coherence."""
     def calculate_stability_score(self, metrics:
         FleetMetrics, sae_anomalies: int) -> float:
         score = 1.0
+
+
+
+
+
         score -= (metrics.avg_error_rate * 5.0)
         score -= (sae_anomalies * 0.05)
         latency_penalty = max(0.0, (metrics.latency_p95 - 2000) / 10000)
@@ -110,6 +155,16 @@ class StabilityCore:
             return 0.9
         return 0.5
 
+
+
+
+
+
+
+
+
+
+
 class TracingCore:
     """distributed tracing and latency breakdown logic."""
     def create_span_context(self, trace_id:
@@ -130,6 +185,11 @@ class TracingCore:
         str, attributes: dict[str, Any]) -> dict[str, Any]:
         return {"timestamp": time.time_ns(), "name": name, "attributes": attributes, "kind": "INTERNAL"}
 
+
+
+
+
+
 class DerivedMetricCalculator:
     """Calculate derived metrics from dependencies using safe AST evaluation."""
     def __init__(self) -> None:
@@ -168,6 +228,11 @@ class DerivedMetricCalculator:
             raise TypeError(f"Unsupported function: {node.func}")
         raise TypeError(f"Unsupported operation: {type(node)}")
 
+
+
+
+
+
     def register_derived(self, name:
         str, dependencies: list[str], formula: str, description: str = "") -> DerivedMetric:
         derived = DerivedMetric(name=name, dependencies=dependencies, formula=formula, description=description)
@@ -197,6 +262,21 @@ class DerivedMetricCalculator:
             logger.error(f"Failed to calculate {name}: {e}")
             return None
 
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
 class CorrelationAnalyzer:
     """Analyze correlations between metrics."""
     def __init__(self) -> None:
@@ -226,6 +306,21 @@ class CorrelationAnalyzer:
         self.correlations.append(res)
         return res
 
+
+
+
+
+
+try:
+    import rust_core as rc
+except ImportError:
+    rc = None  # type: ignore[assignment]
+
+
+
+
+
+
 class FormulaEngineCore:
     """Pure logic core for formula calculations."""
     def __init__(self) -> None:
@@ -241,17 +336,45 @@ class FormulaEngineCore:
             return float(node.value)
         elif hasattr(ast, "Num") and isinstance(node, ast.Num):
             return float(node.n)
+
+
+
+
+
         elif isinstance(node, ast.BinOp):
             return self.operators[type(node.op)](self._eval_node(node.left), self._eval_node(node.right))
         elif isinstance(node, ast.UnaryOp):
             return self.operators[type(node.op)](self._eval_node(node.operand))
+
+
+
+
+
         raise TypeError(f"Unsupported operation: {type(node)}")
 
     def calculate_logic(self, formula:
         str, variables: dict[str, Any]) -> float:
+        if rc and "AVG(" not in formula:
+            try:
+                # Convert variables to dict[str, float] for Rust (excludes list/complex types)
+                float_vars = {k: float(v) for k, v in variables.items() if isinstance(v, (int, float))}
+
+
+
+
+
+                return rc.evaluate_formula(formula, float_vars)  # type: ignore[attr-defined]
+            except Exception:
+                pass
+
         if "AVG(" in formula:
             match = re.search(r'AVG\(\{(\w+)\}\)', formula)
             if match and match.group(1) in variables:
+
+
+
+
+
                 vals = variables[match.group(1)]
                 if isinstance(vals, list) and vals:
                     return sum(vals)/len(vals)
@@ -259,6 +382,11 @@ class FormulaEngineCore:
         try:
             eval_f = formula
             for k, v in variables.items():
+
+
+
+
+
                 eval_f = eval_f.replace(f"{{{k}}}", str(v))
             tree = ast.parse(eval_f, mode='eval')
             return self._eval_node(tree.body)
@@ -274,14 +402,39 @@ class FormulaEngineCore:
             for v in re.findall(r'\{(\w+)\}', formula):
                 test_f = test_f.replace(f"{{{v}}}", "1")
             ast.parse(test_f, mode='eval')
+
+
+
+
+
             return {"is_valid": True, "error": None}
         except Exception as e:
             return {"is_valid": False, "error": str(e)}
 
+
+
+
+
+
+
+
+
+
+
 class FormulaEngine:
     def __init__(self) -> None:
         self.formulas: dict[str, str] = {}
+
+
+
+
+
         self.core = FormulaEngineCore()
+
+
+
+
+
     def define(self, name:
         str, formula: str) -> None:
         self.formulas[name] = formula
@@ -290,6 +443,11 @@ class FormulaEngine:
         f = self.formulas.get(f_or_n, f_or_n)
         return self.core.calculate_logic(f, variables or {})
 
+
+
+
+
+
 class TokenCostCore:
     def compute_usd(self, model:
         str, in_t: int, out_t: int) -> float:
@@ -297,6 +455,16 @@ class TokenCostCore:
         p = MODEL_COSTS.get(mk) or next((MODEL_COSTS[k] for k in MODEL_COSTS if k != "default" and k in mk), MODEL_COSTS["default"])
         return round((in_t/1000)*p["input"] + (out_t/1000)*p["output"], 6)
 
+
+
+
+
+
+
+
+
+
+
 class TokenCostEngine:
     def __init__(self) -> None:
         self.core = TokenCostCore()
@@ -304,6 +472,16 @@ class TokenCostEngine:
         str, input_tokens: int = 0, output_tokens: int = 0) -> float:
         return self.core.compute_usd(model_name, input_tokens, output_tokens)
 
+
+
+
+
+
+
+
+
+
+
 class ModelFallbackCore:
     def __init__(self, chains:
         dict[str, list[str]] | None = None) -> None:
@@ -313,12 +491,27 @@ class ModelFallbackCore:
             "economy": ["gpt-4o-mini", "claude-3-haiku", "gemini-1.5-flash"]
         }
     def determine_next_model(self, cur:
+
+
+
+
+
         str) -> str | None:
         for c in self.chains.values():
             if cur in c and c.index(cur)+1 < len(c):
                 return c[c.index(cur)+1]
+
+
+
+
+
         return self.chains["economy"][0]
 
+
+
+
+
+
 class ModelFallbackEngine:
     def __init__(self, cost_engine:
         TokenCostEngine | None = None) -> None:
@@ -328,9 +521,19 @@ class ModelFallbackEngine:
         str, research: str = "") -> str | None:
         return self.core.determine_next_model(current_model)
 
+
+
+
+
+
 class StatsRollupCalculator:
     def __init__(self) -> None:
         self._points: dict[str, list[tuple[float, float]]] = {}
+
+
+
+
+
     def add_point(self, m:
         str, ts: float, v: float) -> None:
         if m not in self._points:
@@ -345,11 +548,23 @@ class StatsRollupCalculator:
         amt = int(interval[:-1]) if interval[:-1].isdigit() else 1
         mult = {"m": 60, "h": 3600, "d": 86400}.get(unit, 3600)
         bucket = mult * amt
+
+        if rc:
+            try:
+                return rc.calculate_stats_rollup(pts, bucket)  # type: ignore[attr-defined]
+            except Exception:
+                pass
+
         bkts: dict[int, list[float]] = {}
         for t, v in pts:
             bkts.setdefault(int(t)//int(bucket), []).append(float(v))
         return [sum(bkts[k])/len(bkts[k]) for k in sorted(bkts.keys())]
 
+
+
+
+
+
 class StatsForecaster:
     def predict(self, hist:
         list[float], periods: int = 3) -> list[float]:
@@ -361,6 +576,11 @@ class StatsForecaster:
         diff = last_val - prev_val
         return [last_val + diff * (i + 1) for i in range(periods)]
 
+
+
+
+
+
 class ABComparator:
     def compare(self, a:
         dict[str, float], b: dict[str, float]) -> ABComparisonResult:
@@ -376,13 +596,23 @@ class ABComparator:
         p = 0.01 if abs(eff) >= 1.0 else 0.5
         return ABSignificanceResult(p, p < alpha, eff)
 
+
+
+
+
+
 class ResourceMonitor:
     def __init__(self, workspace_root:
         str) -> None:
         self.workspace_root = Path(workspace_root)
+
+
+
+
+
     def get_current_stats(self) -> dict[str, Any]:
         stats = {"cpu_usage_pct": 0, "memory_usage_pct": 0, "status": "HEALTHY"}
         if HAS_PSUTIL:
             stats["cpu_usage_pct"] = psutil.cpu_percent()
             stats["memory_usage_pct"] = psutil.virtual_memory().percent
-        return stats
\ No newline at end of file
+        return stats
