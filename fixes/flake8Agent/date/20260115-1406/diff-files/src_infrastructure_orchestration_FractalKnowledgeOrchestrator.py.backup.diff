diff --git a/src/infrastructure/orchestration/FractalKnowledgeOrchestrator.py b/src/infrastructure/orchestration/FractalKnowledgeOrchestrator.py
index 5b7b379..1aaa505 100644
--- a/src/infrastructure/orchestration/FractalKnowledgeOrchestrator.py
+++ b/src/infrastructure/orchestration/FractalKnowledgeOrchestrator.py
@@ -21,37 +21,51 @@
 from __future__ import annotations
 from src.core.base.version import VERSION
 import logging
-from typing import Dict, List, Any
+from typing import Any
 
 __version__ = VERSION
 
+
+
+
+
+
 class FractalKnowledgeOrchestrator:
     """
     Phase 39: Fractal Knowledge Synthesis.
     Synthesizes cross-domain knowledge by recursively merging summaries from specialized agents.
     Resolves conflicting insights into a unified 'Wisdom Layer'.
     """
-    
+
     def __init__(self, fleet) -> None:
         self.fleet = fleet
         self.wisdom_cache: dict[str, Any] = {}
 
-    def synthesize(self, topic: str, agent_names: list[str]) -> dict[str, Any]:
+    async def synthesize(self, topic: str, agent_names: list[str]) -> dict[str, Any]:
         """
         Gathers insights from specific agents and merges them into a fractal summary.
         """
         logging.info(f"FractalKnowledge: Synthesizing wisdom for '{topic}' across {len(agent_names)} agents...")
-        
+
         raw_insights = {}
+        # Use gather for parallel execution
+        import asyncio
+        tasks = []
+        valid_names = []
+
         for name in agent_names:
             if name in self.fleet.agents:
-                # Consult the agent's expertise
                 agent = self.fleet.agents[name]
-                raw_insights[name] = agent.improve_content(f"Analyze data regarding topic: {topic}")
-        
+                tasks.append(agent.improve_content(f"Analyze data regarding topic: {topic}"))
+                valid_names.append(name)
+
+        results = await asyncio.gather(*tasks) if tasks else []
+        for name, res in zip(valid_names, results):
+             raw_insights[name] = res
+
         # Real Conflict Resolution logic using AI
         consultation_text = "\n".join([f"Agent {name}: {insight}" for name, insight in raw_insights.items()])
-        
+
         description = f"Synthesize insights for {topic}"
         prompt = (
             f"You are the Fractal Knowledge Orchestrator. Synthesize the following agent insights regarding '{topic}' "
@@ -59,20 +73,23 @@ class FractalKnowledgeOrchestrator:
             "logical consistency and expert reasoning.\n\n"
             f"### Agent Insights:\n{consultation_text}"
         )
-        
+
         # Use the first agent's run_subagent capability (shared via fleet)
-        # or assuming LLMClient is available globally
         try:
-             unified_wisdom = self.fleet.agents[agent_names[0]].run_subagent(description, prompt)
+             # Ensure we await the subagent call
+             if valid_names:
+                  unified_wisdom = await self.fleet.agents[valid_names[0]].run_subagent(description, prompt)
+             else:
+                  unified_wisdom = "No agents available."
         except Exception:
-             unified_wisdom = " | ".join(raw_insights.values())
-        
+             unified_wisdom = " | ".join([str(v) for v in raw_insights.values()])
+
         resolution_report = {
             "topic": topic,
             "sources": list(raw_insights.keys()),
             "conflicts_resolved": len(raw_insights) // 2, # Heuristic
             "unified_wisdom": unified_wisdom
         }
-        
+
         self.wisdom_cache[topic] = resolution_report
-        return resolution_report
\ No newline at end of file
+        return resolution_report
