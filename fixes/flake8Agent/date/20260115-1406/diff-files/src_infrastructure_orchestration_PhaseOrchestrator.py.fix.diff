diff --git a/src/infrastructure/orchestration/PhaseOrchestrator.py b/src/infrastructure/orchestration/PhaseOrchestrator.py
index c0e359d..130f5c4 100644
--- a/src/infrastructure/orchestration/PhaseOrchestrator.py
+++ b/src/infrastructure/orchestration/PhaseOrchestrator.py
@@ -13,54 +13,67 @@
 # limitations under the License.
 
 from __future__ import annotations
-import logging
 import asyncio
-from typing import Dict, List, Any, TYPE_CHECKING
+import json
+from src.observability.StructuredLogger import StructuredLogger
+from typing import Any, TYPE_CHECKING
 
 if TYPE_CHECKING:
     from ..fleet.FleetManager import FleetManager
 
+logger = StructuredLogger(__name__)
+
+
+
+
+
+
+
+
+
+
+
 class PhaseOrchestrator:
     """High-reliability task orchestrator using a 7-phase scientific method loop."""
-    
+
     def __init__(self, fleet: FleetManager) -> None:
         self.fleet = fleet
         self.current_context: dict[str, Any] = {}
 
     async def execute_task(self, task: str) -> str:
         """Runs the 7-phase cycle for a given task."""
-        logging.info(f"PhaseOrchestrator: Starting 7-phase cycle for task: {task}")
-        
+        logger.info(f"PhaseOrchestrator: Starting 7-phase cycle for task: {task}")
+
         report = [f"# Phase Execution Report: {task}\n"]
-        
+
         # Phase 1: OBSERVE
         observe_res = await self._phase_observe(task)
         report.append(f"## Phase 1: OBSERVE\n{observe_res}\n")
-        
+
         # Phase 2: THINK
         think_res = await self._phase_think(task, observe_res)
         report.append(f"## Phase 2: THINK\n{think_res}\n")
-        
+
         # Phase 3: DEFINE
         criteria = await self._phase_define(task)
         report.append(f"## Phase 3: DEFINE\n{criteria}\n")
-        
+
         # Phase 4: PLAN
         plan = await self._phase_plan(task, think_res)
         report.append(f"## Phase 4: PLAN\n{plan}\n")
-        
+
         # Phase 5: EXECUTE
         exec_res = await self._phase_execute(plan)
         report.append(f"## Phase 5: EXECUTE\n{exec_res}\n")
-        
+
         # Phase 6: VERIFY
         verify_res = await self._phase_verify(exec_res, criteria)
         report.append(f"## Phase 6: VERIFY\n{verify_res}\n")
-        
+
         # Phase 7: LEARN
         learn_res = await self._phase_learn(task, verify_res)
         report.append(f"## Phase 7: LEARN\n{learn_res}\n")
-        
+
         return "\n".join(report)
 
     async def _phase_observe(self, task: str) -> str:
@@ -80,7 +93,6 @@ class PhaseOrchestrator:
         prompt = f"Plan a PyAgent workflow for: {task}\nThought: {thought}\nOutput ONLY a JSON list of steps."
         res = await self.fleet.call_by_capability("Security.improve_content", prompt=prompt)
         # Parse JSON from result
-        import json
         try:
             # Simple extractor for markdown
             if "```json" in res:
@@ -88,8 +100,8 @@ class PhaseOrchestrator:
             elif "```" in res:
                 res = res.split("```")[-1].split("```")[0].strip()
             return json.loads(res)
-        except Exception:
-            logging.warning("Failed to parse JSON plan, using default reasoning step.")
+        except json.JSONDecodeError:
+            logger.warning("Failed to parse JSON plan, using default reasoning step.")
             return [{"agent": "Reasoning", "action": "analyze_tot", "args": [task]}]
 
     async def _phase_execute(self, plan: list[dict[str, Any]]) -> str:
@@ -100,18 +112,18 @@ class PhaseOrchestrator:
         # Parallelization Logic: Group independent steps (shards)
         independent_shards = []
         sequential_steps = []
-        
+
         for step in plan:
             args = step.get("args", [])
             is_dependent = any(isinstance(a, str) and a.startswith("$") for a in args)
-            
+
             if is_dependent:
                 sequential_steps.append(step)
             else:
                 independent_shards.append(step)
 
         if independent_shards:
-            logging.info(f"PhaseOrchestrator: Executing {len(independent_shards)} independent shards in parallel.")
+            logger.info(f"PhaseOrchestrator: Executing {len(independent_shards)} independent shards in parallel.")
             # Execute independent shards concurrently
             shard_tasks = [
                 self.fleet.execute_workflow(f"Parallel Shard: {s.get('agent')}", [s])
@@ -119,13 +131,13 @@ class PhaseOrchestrator:
             ]
             shard_results = await asyncio.gather(*shard_tasks)
             combined_results = "\n".join(shard_results)
-            
+
             # If there are subsequent sequential steps, run them now
             if sequential_steps:
-                logging.info(f"PhaseOrchestrator: Executing remaining {len(sequential_steps)} sequential steps.")
+                logger.info(f"PhaseOrchestrator: Executing remaining {len(sequential_steps)} sequential steps.")
                 seq_results = await self.fleet.execute_workflow("Sequential Follow-up", sequential_steps)
                 return f"{combined_results}\n\n{seq_results}"
-            
+
             return combined_results
 
         # Fallback to standard sequential execution
@@ -141,4 +153,4 @@ class PhaseOrchestrator:
             failure_context=task,
             error_msg="No error detected.",
             lesson=f"Verification results: {verification}"
-        )
\ No newline at end of file
+        )
