diff --git a/src/infrastructure/simulation/HopperSim.py b/src/infrastructure/simulation/HopperSim.py
index 39cf33e..979c4c5 100644
--- a/src/infrastructure/simulation/HopperSim.py
+++ b/src/infrastructure/simulation/HopperSim.py
@@ -27,17 +27,45 @@ from __future__ import annotations
 from src.core.base.version import VERSION
 from dataclasses import dataclass
 from enum import Enum, auto
-import time
+from src.observability.StructuredLogger import StructuredLogger
 from src.infrastructure.simulation.core.SimulationCore import SimulationCore
 
 __version__ = VERSION
 
+logger = StructuredLogger("HopperSim")
+
+
+
+
+
+
+
+
+
+
+
 class Precision(Enum):
+    """Floating point precision modes for simulation."""
+
+
+
+
+
     FP8 = auto()
     FP16 = auto()
     TF32 = auto()
     FP64 = auto()
 
+
+
+
+
+
+
+
+
+
+
 @dataclass
 class HopperConfig:
     """NVIDIA H100 SXM5 specifications."""
@@ -47,9 +75,14 @@ class HopperConfig:
     mem_bandwidth_gb_s: int = 3350
     tma_units_per_sm: int = 1
 
+
+
+
+
+
 class HopperSim:
     """Simulates Hopper architecture performance for GEMM operations."""
-    
+
     def __init__(self, config: HopperConfig = HopperConfig()):
         self.config = config
 
@@ -66,13 +99,13 @@ class HopperSim:
             Precision.TF32: 989.0,  # Dense TFLOPS
             Precision.FP64: 68.0    # Dense TFLOPS
         }
-        
+
         peak_tflops = throughput_map.get(precision, 1979.0)
-        
+
         # Operations count
         ops = 2 * m * n * k
         theoretical_lat = (ops / (peak_tflops * 1e12)) * 1000 # ms
-        
+
         # Memory Roofline
         # Data moved: A (m*k) + B (k*n) + C (m*n)
         byte_map = {
@@ -84,7 +117,7 @@ class HopperSim:
         bytes_per_elem = byte_map.get(precision, 2)
         total_data_gb = (m*k + k*n + m*n) * bytes_per_elem / 1e9
         memory_lat = (total_data_gb / self.config.mem_bandwidth_gb_s) * 1000 # ms
-        
+
         # Return max of compute or memory bound, plus some overhead for TMA/Scheduling
         overhead_factor = 1.15
         return max(theoretical_lat, memory_lat) * overhead_factor
@@ -93,12 +126,12 @@ class HopperSim:
         # QKV Projections: 3 * [B, S, D] * [D, D]
         m, n, k = batch_size * seq_len, d_model, d_model
         latency_qkv = self.estimate_matmul_latency(m, n, k) * 3
-        
+
         # Attention: [B, S, S] * [S, D] (Simplified)
         latency_attn = self.estimate_matmul_latency(batch_size * seq_len, seq_len, d_model)
-        
+
         total_ms = (latency_qkv + latency_attn) / num_gpus # Simplified linear scaling
-        
+
         return {
             "qkv_latency_ms": latency_qkv,
             "m_params": (d_model * d_model * 12) / 1e6, # Parameter count estimate
@@ -106,24 +139,34 @@ class HopperSim:
             "tflops_utilization": 0.45 * 100 # Typical real-world efficiency
         }
 
-    def run_swarm_stress_test(self, agent_count: int, steps: int = 10):
+    def run_swarm_stress_test(self, agent_count: int, steps: int = 10) -> None:
         """Runs a swarm stress test with stochastic failures (Phase 181)."""
-        print(f"=== SWARM STRESS TEST: {agent_count} AGENTS ===")
-        
+
+
+
+
+
+        logger.info(f"=== SWARM STRESS TEST: {agent_count} AGENTS ===")
+
         core = SimulationCore()
         active_agents = agent_count
-        
+
         for step in range(1, steps + 1):
             # Stochastic failures (10%)
             failures = core.calculate_stochastic_failures(active_agents, 0.1)
             active_agents -= len(failures)
-            
+
             bar = core.format_progress_bar(step, steps)
-            print(f"Step {step:02d}: {bar} | Failed: {len(failures)} | Alive: {active_agents}")
-            
-        print(f"=== TEST COMPLETE. Final Resilience: {active_agents/agent_count*100:.1f}% ===")
+            logger.info(f"Step {step:02d}: {bar} | Failed: {len(failures)} | Alive: {active_agents}")
+
+        logger.info(f"=== TEST COMPLETE. Final Resilience: {active_agents/agent_count*100:.1f}% ===")
+
+
+
+
+
 
 if __name__ == "__main__":
     sim = HopperSim()
     result = sim.simulate_distributed_training(32, 2048, 4096, 8)
-    print(f"Hopper Simulation Result: {result}")
\ No newline at end of file
+    print(f"Hopper Simulation Result: {result}")
