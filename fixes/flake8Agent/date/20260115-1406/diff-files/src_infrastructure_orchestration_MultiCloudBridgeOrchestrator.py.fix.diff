diff --git a/src/infrastructure/orchestration/MultiCloudBridgeOrchestrator.py b/src/infrastructure/orchestration/MultiCloudBridgeOrchestrator.py
index 62663ae..240ef17 100644
--- a/src/infrastructure/orchestration/MultiCloudBridgeOrchestrator.py
+++ b/src/infrastructure/orchestration/MultiCloudBridgeOrchestrator.py
@@ -19,13 +19,26 @@
 
 from __future__ import annotations
 from src.core.base.version import VERSION
-from typing import Dict, Any
+from typing import Any
+from src.observability.StructuredLogger import StructuredLogger
 
 __version__ = VERSION
 
+logger = StructuredLogger(__name__)
+
+
+
+
+
+
+
+
+
+
+
 class MultiCloudBridgeOrchestrator:
     """
-    Multi-Cloud Bridge Orchestrator: Manages agent communication and state 
+    Multi-Cloud Bridge Orchestrator: Manages agent communication and state
     synchronization across AWS, Azure, and GCP simulated environments.
     """
     def __init__(self, fleet_manager: Any) -> None:
@@ -35,36 +48,36 @@ class MultiCloudBridgeOrchestrator:
             "Azure": [],
             "GCP": []
         }
-        self.sync_logs = []
+        self.sync_logs: list[Any] = []
 
     def register_cloud_node(self, node_id: str, provider: str, region: str) -> bool:
         """Registers a node belonging to a specific cloud provider."""
         if provider not in self.cloud_nodes:
-            print(f"Bridge: Provider {provider} not supported.")
+            logger.info(f"Bridge: Provider {provider} not supported.")
             return False
-        
+
         node_info = {
             "node_id": node_id,
             "region": region,
             "status": "Linked"
         }
         self.cloud_nodes[provider].append(node_info)
-        print(f"Bridge: Linked {node_id} on {provider} ({region})")
+        logger.info(f"Bridge: Linked {node_id} on {provider} ({region})")
         return True
 
     def sync_state_cross_cloud(self, state_data: dict[str, Any], source_provider: str) -> dict[str, Any]:
         """Synchronizes state data from a source provider to all other linked cloud providers."""
-        print(f"Bridge: Initiating cross-cloud sync from {source_provider}...")
-        
+        logger.info(f"Bridge: Initiating cross-cloud sync from {source_provider}...")
+
         targets = [p for p in self.cloud_nodes if p != source_provider]
         success_count = 0
-        
+
         for target in targets:
             if self.cloud_nodes[target]:
                 # Simulate synchronization latency and success
                 success_count += 1
-                print(f"Bridge: Synced state to {target} (Across {len(self.cloud_nodes[target])} nodes)")
-        
+                logger.info(f"Bridge: Synced state to {target} (Across {len(self.cloud_nodes[target])} nodes)")
+
         sync_event = {
             "source": source_provider,
             "targets": targets,
@@ -72,7 +85,7 @@ class MultiCloudBridgeOrchestrator:
             "timestamp": "2026-01-08" # Simulated
         }
         self.sync_logs.append(sync_event)
-        
+
         return sync_event
 
     def get_bridge_topology(self) -> dict[str, Any]:
@@ -86,7 +99,7 @@ class MultiCloudBridgeOrchestrator:
     def route_message(self, message: str, target_provider: str) -> bool:
         """Routes a message to a specific cloud provider's network."""
         if not self.cloud_nodes[target_provider]:
-            print(f"Bridge: No nodes available on {target_provider} to receive message.")
+            logger.info(f"Bridge: No nodes available on {target_provider} to receive message.")
             return False
-        print(f"Bridge: Routed message to {target_provider}: {message[:20]}...")
-        return True
\ No newline at end of file
+        logger.info(f"Bridge: Routed message to {target_provider}: {message[:20]}...")
+        return True
