diff --git a/src/observability/stats/exporters/OTelManager.py b/src/observability/stats/exporters/OTelManager.py
index d61833e..6b71bd8 100644
--- a/src/observability/stats/exporters/OTelManager.py
+++ b/src/observability/stats/exporters/OTelManager.py
@@ -27,7 +27,7 @@ from src.core.base.version import VERSION
 import logging
 import time
 import uuid
-from typing import Dict, List, Any, Optional
+from typing import Any
 from dataclasses import dataclass, field
 from src.observability.stats.core.TracingCore import TracingCore
 
@@ -40,7 +40,7 @@ try:
         ConsoleSpanExporter,
     )
     from opentelemetry.sdk.resources import Resource
-    
+
     # Initialize Global Tracer
     resource = Resource(attributes={"service.name": "pyagent-fleet"})
     provider = TracerProvider(resource=resource)
@@ -51,22 +51,42 @@ except ImportError:
 
 __version__ = VERSION
 
+
+
+
+
+
+
+
+
+
+
 @dataclass
 class Span:
     name: str
     trace_id: str
     span_id: str
     parent_id: str | None = None
+
+
+
+
+
     start_time: float = field(default_factory=time.time)
     end_time: float | None = None
     attributes: dict[str, Any] = field(default_factory=dict)
     status: str = "unset"
 
+
+
+
+
+
 class OTelManager:
     """Manages OTel-compatible spans and traces for cross-fleet observability.
     Integrated with TracingCore for latency analysis and OTel formatting.
     """
-    
+
     def __init__(self) -> None:
         self.active_spans: dict[str, Any] = {} # Now stores real OTel spans if available
         self.completed_spans: list[Span] = []
@@ -79,7 +99,7 @@ class OTelManager:
     def start_span(self, name: str, parent_id: str | None = None, attributes: dict[str, Any] | None = None) -> str:
         """Starts a new tracing span and returns its ID."""
         span_id = str(uuid.uuid4())
-        
+
         if HAS_OTEL and self.tracer:
             # Use real OTel context if parent_id is managed by OTel
             # For simplicity in this migration, we still track span_id manually for now
@@ -96,7 +116,7 @@ class OTelManager:
                 attributes=attributes or {}
             )
             self.active_spans[span_id] = span
-            
+
         logging.info(f"OTel: Started span {name} ({span_id})")
         return span_id
 
@@ -106,7 +126,7 @@ class OTelManager:
         if not raw_span:
             logging.warning(f"OTel: Attempted to end non-existent span {span_id}")
             return
-            
+
         if HAS_OTEL and not isinstance(raw_span, Span):
             # Real OTel span
             if attributes:
@@ -116,14 +136,14 @@ class OTelManager:
             # Manual Mock span
             raw_span.end_time = time.time()
             raw_span.status = status
-            
+
             if attributes:
                 raw_span.attributes.update(attributes)
-                
+
             total_latency = raw_span.end_time - raw_span.start_time
             # ... existing logic for completed_spans could go here if needed for export_spans()
             self.completed_spans.append(raw_span)
-        
+
         logging.info(f"OTel: Span {span_id} ended (status: {status})")
 
     def export_spans(self) -> list[dict[str, Any]]:
@@ -134,6 +154,11 @@ class OTelManager:
         self.completed_spans = []
         return batch
 
+
+
+
+
+
     def get_trace_context(self, span_id: str) -> dict[str, str]:
         """Generates headers for propagation across HTTP/RPC calls."""
         if span_id in self.active_spans:
@@ -143,6 +168,11 @@ class OTelManager:
             }
         return {}
 
+
+
+
+
+
 if __name__ == "__main__":
     otel = OTelManager()
     root = otel.start_span("Workflow: Fix Code")
@@ -151,4 +181,4 @@ if __name__ == "__main__":
     threading.Event().wait(timeout=0.1)
     otel.end_span(child, status="ok")
     otel.end_span(root, status="ok")
-    print(f"Exported {len(otel.export_spans())} spans.")
\ No newline at end of file
+    print(f"Exported {len(otel.export_spans())} spans.")
