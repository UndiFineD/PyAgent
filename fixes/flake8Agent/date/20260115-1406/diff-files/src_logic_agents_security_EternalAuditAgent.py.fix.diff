diff --git a/src/logic/agents/security/EternalAuditAgent.py b/src/logic/agents/security/EternalAuditAgent.py
index e3be4ab..fa0c816 100644
--- a/src/logic/agents/security/EternalAuditAgent.py
+++ b/src/logic/agents/security/EternalAuditAgent.py
@@ -25,25 +25,35 @@ import json
 import time
 import hashlib
 import os
-from typing import Dict, Any
+from typing import Any
 from src.core.base.BaseAgent import BaseAgent
 from src.core.base.utilities import as_tool
 
 __version__ = VERSION
 
+
+
+
+
+
+
+
+
+
+
 class EternalAuditAgent(BaseAgent):
     """
     Agent that maintains an append-only verifiable audit trail of all swarm activities.
     Uses hashing to ensure temporal integrity (simulated blockchain).
     """
-    
+
     # User requirement: Only record errors, failure, mistakes in general logs
     CRITICAL_ACTIONS = [
-        "error", "failure", "mistake", "security_violation", 
+        "error", "failure", "mistake", "security_violation",
         "vulnerability_found", "exception", "unauthorized_access",
         "quota_exceeded", "blocklist_hit", "safety_violation"
     ]
-    
+
     def __init__(self, file_path: str, selective_logging: bool = True) -> None:
         super().__init__(file_path)
         self.logs_dir = "data/logs/audit_trail"
@@ -73,7 +83,7 @@ class EternalAuditAgent(BaseAgent):
         # Selective pruning: check if action or details contain critical keywords
         is_critical = any(kw in action.lower() for kw in self.CRITICAL_ACTIONS) or \
                       details.get("severity") in ["HIGH", "CRITICAL"]
-                      
+
         if self.selective_logging and not is_critical:
             return "Event skipped (routine/success)."
 
@@ -85,13 +95,13 @@ class EternalAuditAgent(BaseAgent):
             "details": details,
             "previous_hash": self.last_hash
         }
-        
+
         # Generate hash for current entry
         payload_str = json.dumps(payload, sort_keys=True)
         current_hash = hashlib.sha256(payload_str.encode('utf-8')).hexdigest()
         payload["hash"] = current_hash
         self.last_hash = current_hash
-        
+
         # Write to append-only log
         with open(self.current_shard, 'a', encoding='utf-8') as f:
             f.write(json.dumps(payload) + "\n")
@@ -109,31 +119,31 @@ class EternalAuditAgent(BaseAgent):
         """
         if not os.path.exists(self.current_shard):
             return {"status": "error", "message": "No audit trail found."}
-            
+
         errors = []
         expected_prev_hash = "0" * 64
         count = 0
-        
+
         with open(self.current_shard, encoding='utf-8') as f:
             for line in f:
                 count += 1
                 entry = json.loads(line)
                 actual_hash = entry.pop("hash")
-                
+
                 # Check previous hash chain
                 if entry.get("previous_hash") != expected_prev_hash:
                     errors.append(f"Line {count}: Chain broken. Expected {expected_prev_hash}, found {entry.get('previous_hash')}")
-                
+
                 # Verify content hash
                 entry_str = json.dumps(entry, sort_keys=True)
                 recalculated_hash = hashlib.sha256(entry_str.encode('utf-8')).hexdigest()
                 if recalculated_hash != actual_hash:
                     errors.append(f"Line {count}: Hash mismatch.")
-                
+
                 expected_prev_hash = actual_hash
-                
+
         return {
             "status": "success" if not errors else "tampered",
             "entries_processed": count,
             "errors": errors
-        }
\ No newline at end of file
+        }
