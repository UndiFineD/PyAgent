diff --git a/src/logic/agents/cognitive/context/engines/ContextCompressorCore.py b/src/logic/agents/cognitive/context/engines/ContextCompressorCore.py
index 02f3495..4d64655 100644
--- a/src/logic/agents/cognitive/context/engines/ContextCompressorCore.py
+++ b/src/logic/agents/cognitive/context/engines/ContextCompressorCore.py
@@ -28,24 +28,39 @@ from __future__ import annotations
 from src.core.base.version import VERSION
 import re
 import ast
-from typing import List
+
+try:
+    import rust_core
+    HAS_RUST = True
+except ImportError:
+    HAS_RUST = False
 
 __version__ = VERSION
 
+
+
+
+
+
+
+
+
+
+
 class ContextCompressorCore:
     """Pure logic core for code and document compression."""
-    
+
     @staticmethod
     def compress_python(content: str) -> str:
         """Removes function bodies and keeps only class/function signatures using AST."""
         try:
             tree = ast.parse(content)
             compressed_lines: list[str] = []
-            
-            # Use a visitor pattern for cleaner separation if needed, 
-            # but for simple signature extraction, a walk is acceptable 
+
+            # Use a visitor pattern for cleaner separation if needed,
+            # but for simple signature extraction, a walk is acceptable
             # as long as we maintain some structure.
-            
+
             for node in ast.walk(tree):
                 if isinstance(node, ast.ClassDef):
                     bases_str = ""
@@ -55,22 +70,22 @@ class ContextCompressorCore:
                         except Exception:
                             bases_str = "(...)"
                     compressed_lines.append(f"class {node.name}{bases_str}:")
-                        
+
                 elif isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
                     try:
                         args_str = ast.unparse(node.args)
                     except Exception:
                         args_str = "..."
-                    
+
                     prefix = "async " if isinstance(node, ast.AsyncFunctionDef) else ""
-                    # Note: Detecting indentation level in a walk is hard. 
+                    # Note: Detecting indentation level in a walk is hard.
                     # We'll just list them as signatures for now.
                     compressed_lines.append(f"{prefix}def {node.name}({args_str}): ...")
-            
+
             # Deduplicate and sort to provide a stable signature
             unique_signatures = sorted(list(set(compressed_lines)))
             return "\n".join(unique_signatures)
-            
+
         except Exception:
             # Fallback to simple regex if AST fails (e.g. invalid syntax)
             return ContextCompressorCore.regex_fallback_compress(content)
@@ -78,12 +93,22 @@ class ContextCompressorCore:
     @staticmethod
     def regex_fallback_compress(content: str) -> str:
         """Simple regex-based signature extraction for Python."""
+        if HAS_RUST:
+            try:
+                return rust_core.regex_compress_python(content)  # type: ignore[attr-defined]
+            except Exception:
+                pass
         signatures = re.findall(r"^\s*(?:async\s+)?(?:def|class)\s+[a-zA-Z_][a-zA-Z0-9_]*.*?:", content, re.MULTILINE)
         return "\n".join([s.strip() for s in signatures])
 
     @staticmethod
     def summarize_markdown(content: str) -> str:
         """Keeps only headers from markdown files."""
+        if HAS_RUST:
+            try:
+                return rust_core.summarize_markdown(content)  # type: ignore[attr-defined]
+            except Exception:
+                pass
         headers = re.findall(r"^(#+ .*)$", content, re.MULTILINE)
         return "\n".join(headers)
 
@@ -99,4 +124,4 @@ class ContextCompressorCore:
             return "python"
         elif filename.endswith(".md"):
             return "markdown"
-        return "head"
\ No newline at end of file
+        return "head"
