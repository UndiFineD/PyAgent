diff --git a/src/infrastructure/fleet/OrchestratorRegistry.py b/src/infrastructure/fleet/OrchestratorRegistry.py
index 212c397..6f1d1a2 100644
--- a/src/infrastructure/fleet/OrchestratorRegistry.py
+++ b/src/infrastructure/fleet/OrchestratorRegistry.py
@@ -24,31 +24,44 @@ from src.core.base.version import VERSION
 import logging
 import json
 import os
-from typing import Dict, Any, List
+from typing import Any, TYPE_CHECKING
 from pathlib import Path
 from .ResilientStubs import ResilientStub
 from .OrchestratorRegistryCore import OrchestratorRegistryCore
 from .BootstrapConfigs import BOOTSTRAP_ORCHESTRATORS
 from src.core.base.version import SDK_VERSION
 
+if TYPE_CHECKING:
+    from src.infrastructure.fleet.FleetManager import FleetManager
+
 __version__ = VERSION
 
+
+
+
+
+
+
+
+
+
+
 class LazyOrchestratorMap:
     """A dictionary-like object that instantiates orchestrators only when accessed."""
-    def __init__(self, fleet_instance) -> None:
+    def __init__(self, fleet_instance: FleetManager) -> None:
         self.fleet = fleet_instance
         self.workspace_root = Path(fleet_instance.workspace_root)
-        self._instances = {}
+        self._instances: dict[Any, Any] = {}
         self._registry_core = OrchestratorRegistryCore(SDK_VERSION)
-        
+
         # 1. Manifest
         self._manifest_configs = self._load_manifests()
-        
+
         # 2. Dynamic Discovery
         discovered_files = self._scan_workspace_for_orchestrators()
         self._discovered_configs = self._registry_core.process_discovered_files(discovered_files)
         logging.info(f"Registry: Discovered {len(self._discovered_configs)} orchestrators.")
-        
+
         # Combined map: Bootstrap > Manifest > Discovery
         # Convert BOOTSTRAP_ORCHESTRATORS to the 4-tuple format (module, class, needs_fleet, arg)
         boot_configs = {k: (v[0], v[1], True, None) for k, v in BOOTSTRAP_ORCHESTRATORS.items()}
@@ -57,8 +70,8 @@ class LazyOrchestratorMap:
     def _scan_workspace_for_orchestrators(self) -> list[str]:
         """Performs the I/O-bound scanning of the workspace."""
         subdirs = [
-            "src/infrastructure/orchestration", 
-            "src/logic/agents/cognitive", 
+            "src/infrastructure/orchestration",
+            "src/logic/agents/cognitive",
             "src/infrastructure/fleet",
             "src/logic/agents/swarm",
             "src/logic/agents/security"
@@ -95,16 +108,16 @@ class LazyOrchestratorMap:
                     logging.error(f"Failed to load orchestrator manifest {m_path}: {e}")
         return manifest_configs
 
-    def __getattr__(self, name) -> Any:
+    def __getattr__(self, name: str) -> Any:
         if name in self.__dict__:
             return self.__dict__[name]
 
         if name in self._instances:
             return self._instances[name]
-        
+
         if name in self._configs:
             return self._instantiate(name, self._configs[name])
-            
+
         # Case-insensitive and underscore-tolerant fallback
         n_low = name.lower().replace("_", "")
         for k, cfg in self._configs.items():
@@ -117,7 +130,7 @@ class LazyOrchestratorMap:
         """Attempts to reload/re-instantiate a specific orchestrator."""
         if name in self._instances:
             del self._instances[name]
-        
+
         try:
             instance = getattr(self, name)
             # Check if it's still a stub
@@ -127,12 +140,12 @@ class LazyOrchestratorMap:
             logging.error(f"Failed to reload orchestrator '{name}': {e}")
             return False
 
-    def _instantiate(self, key, config) -> Any:
+    def _instantiate(self, key: str, config: tuple[str, str, bool, str | None]) -> Any:
         module_path, class_name, needs_fleet, arg_path_suffix = config
         try:
             import importlib
             module = importlib.import_module(module_path)
-            
+
             # Version Gatekeeping
             min_sdk = getattr(module, "SDK_REQUIRED", getattr(module, "__min_sdk__", "1.0.0"))
             if not self._registry_core.is_compatible(min_sdk):
@@ -143,7 +156,7 @@ class LazyOrchestratorMap:
                 return stub
 
             orchestrator_class = getattr(module, class_name)
-            
+
             # Phase 125: Enhanced Instantiation with Agent Compatibility
             # Some orchestrators (e.g. WeightOrchestrator) inherit from BaseAgent
             # and require a workspace_root string as the first argument.
@@ -188,7 +201,7 @@ class LazyOrchestratorMap:
                     instance = orchestrator_class(str(base_path)) if base_path.exists() else orchestrator_class(arg_path_suffix)
                 else:
                     instance = orchestrator_class()
-                
+
             self._instances[key] = instance
             return instance
         except (ImportError, SyntaxError) as e:
@@ -202,12 +215,23 @@ class LazyOrchestratorMap:
 
     def keys(self) -> list[str]:
         """Returns list of available orchestrators."""
+
+
+
+
+
         return list(self._configs.keys())
 
-    def __contains__(self, key) -> bool:
+    def __contains__(self, key: object) -> bool:
         return key in self._configs
 
+
+
+
+
+
 class OrchestratorRegistry:
+    """Registry for mapping agent types to their corresponding orchestrators."""
     @staticmethod
-    def get_orchestrator_map(fleet_instance) -> LazyOrchestratorMap:
-        return LazyOrchestratorMap(fleet_instance)
\ No newline at end of file
+    def get_orchestrator_map(fleet_instance: FleetManager) -> LazyOrchestratorMap:
+        return LazyOrchestratorMap(fleet_instance)
