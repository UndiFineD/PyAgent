diff --git a/src/logic/agents/swarm/PredictiveSchedulerAgent.py b/src/logic/agents/swarm/PredictiveSchedulerAgent.py
index 9c5022d..dba32d9 100644
--- a/src/logic/agents/swarm/PredictiveSchedulerAgent.py
+++ b/src/logic/agents/swarm/PredictiveSchedulerAgent.py
@@ -21,18 +21,23 @@ from __future__ import annotations
 from src.core.base.version import VERSION
 import time
 import logging
-from typing import Dict, List, Any, Optional
+from typing import Any
 from src.core.base.BaseAgent import BaseAgent
 
 __version__ = VERSION
 
+
+
+
+
+
 class PredictiveSchedulerAgent(BaseAgent):
     """
     Phase 53: Predictive Resource Forecasting.
     Uses historical telemetry to forecast future token usage and compute needs.
     Phase 130: Neural Feedback Loop integration for adaptive weight balancing.
     """
-    
+
     def __init__(self, path: str) -> None:
         super().__init__(path)
         self.usage_history: list[dict[str, Any]] = []
@@ -51,16 +56,16 @@ class PredictiveSchedulerAgent(BaseAgent):
                 "tokens": getattr(m, 'token_count', 0),
                 "agent": getattr(m, 'agent_name', "unknown")
             })
-            
+
         if actual_outcome is not None and len(self.usage_history) > 1:
             # Neural Feedback Loop: Adjust weights based on last prediction error
             error = actual_outcome - self.forecast_usage()["forecasted_tokens"]
             logging.info(f"Neural Feedback: Adjusting weights (error: {error:.2f})")
-            
+
             # Simple gradient descent on weights
             self.weights["trend"] += self.learning_rate * (error / 1000.0) # Normalized update
             self.weights["avg"] = 1.0 - self.weights["trend"]
-            
+
             # Clamp weights
             self.weights["trend"] = max(0.1, min(0.9, self.weights["trend"]))
             self.weights["avg"] = max(0.1, min(0.9, self.weights["avg"]))
@@ -76,16 +81,16 @@ class PredictiveSchedulerAgent(BaseAgent):
         """
         if len(self.usage_history) < 5:
             return {"forecasted_tokens": 0, "confidence": 0.1, "action": "collect_more_data"}
-            
+
         recent_usage = [h["tokens"] for h in self.usage_history[-5:]]
         avg_usage = sum(recent_usage) / len(recent_usage)
-        
+
         # Trend analysis
         trend_val = recent_usage[-1] - recent_usage[0]
-        
+
         # Weighted forecast
         forecast = (avg_usage * self.weights["avg"]) + (max(0, avg_usage + trend_val) * self.weights["trend"])
-        
+
         return {
             "forecasted_tokens": forecast,
             "confidence": 0.8 if len(self.usage_history) > 20 else 0.4,
@@ -97,14 +102,14 @@ class PredictiveSchedulerAgent(BaseAgent):
         """Recommends scaling actions based on predicted load."""
         forecast = self.forecast_usage()
         needed_nodes = current_nodes
-        
+
         if forecast["forecasted_tokens"] > 5000:
             needed_nodes += 2
         elif forecast["forecasted_tokens"] > 2000:
             needed_nodes += 1
-            
+
         return {
             "current_nodes": current_nodes,
             "recommended_nodes": needed_nodes,
             "trigger_scaling": needed_nodes > current_nodes
-        }
\ No newline at end of file
+        }
