#!/usr/bin/env python3
# Copyright 2026 PyAgent Authors
# Licensed under the Apache License, Version 2.0 (the "License")
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
from __future__ import annotations


"""AtomicCounter - Thread-safe counters and related primitives.

This module provides several simple concurrency primitives used in tests
and lightweight parts of the codebase. Implementations favor clarity
and correct behavior over performance; a Rust-accelerated variant may be
plugged in later.
"""

import threading
from typing import Optional


try:
    from rust_core import rust_core as rc  # optional

    RUST_AVAILABLE = True
except Exception:  # pragma: no cover - optional dependency
    rc = None  # type: ignore
    RUST_AVAILABLE = False


class Counter:
    """Simple non-atomic counter for single-threaded use."""

    __slots__ = ("_value",)

    def __init__(self, start: int = 0) -> None:
        self._value = int(start)

    @property
    def value(self) -> int:
        return self._value

    def inc(self, delta: int = 1) -> int:
        self._value += int(delta)
        return self._value

    def dec(self, delta: int = 1) -> int:
        self._value -= int(delta)
        return self._value

    def reset(self, value: int = 0) -> int:
        old = self._value
        self._value = int(value)
        return old

    def __repr__(self) -> str:
        return f"Counter({self._value})"


class AtomicCounter:
    """Thread-safe atomic counter implemented with a lock."""

    __slots__ = ("_value", "_lock", "_use_rust")

    def __init__(self, start: int = 0, use_rust: bool = True) -> None:
        self._value = int(start)
        self._lock = threading.Lock()
        self._use_rust = bool(use_rust and RUST_AVAILABLE)

    @property
    def value(self) -> int:
        with self._lock:
            return self._value

    def inc(self, delta: int = 1) -> int:
        if self._use_rust and rc is not None and hasattr(rc, "atomic_counter_add_rust"):
            # hypothetical rust function
            with self._lock:
                self._value = rc.atomic_counter_add_rust(self._value, int(delta))  # type: ignore
                return self._value

        with self._lock:
            self._value += int(delta)
            return self._value

    def dec(self, delta: int = 1) -> int:
        return self.inc(-int(delta))

    # aliases
    def add(self, delta: int) -> int:
        return self.inc(delta)

    def sub(self, delta: int) -> int:
        return self.dec(delta)

    def reset(self, value: int = 0) -> int:
        with self._lock:
            old = self._value
            self._value = int(value)
            return old

    def compare_and_swap(self, expected: int, new_value: int) -> bool:
        with self._lock:
            if self._value == int(expected):
                self._value = int(new_value)
                return True
            return False

    def get_and_reset(self) -> int:
        return self.reset(0)

    def __repr__(self) -> str:
        return f"AtomicCounter({self.value})"

    def __int__(self) -> int:
        return self.value

    def __eq__(self, other: object) -> bool:
        if isinstance(other, (int, AtomicCounter, Counter)):
            other_val = other.value if hasattr(other, "value") else int(other)  # type: ignore
            return self.value == int(other_val)
        return NotImplemented


class AtomicFlag:
    """Thread-safe atomic boolean flag."""

    __slots__ = ("_flag", "_lock")

    def __init__(self, initial: bool = False) -> None:
        self._flag = bool(initial)
        self._lock = threading.Lock()

    @property
    def value(self) -> bool:
        with self._lock:
            return self._flag

    def set(self) -> bool:
        with self._lock:
            old = self._flag
            self._flag = True
            return old

    def clear(self) -> bool:
        with self._lock:
            old = self._flag
            self._flag = False
            return old

    def toggle(self) -> bool:
        with self._lock:
            self._flag = not self._flag
            return self._flag

    def test_and_set(self) -> bool:
        with self._lock:
            if not self._flag:
                self._flag = True
                return True
            return False

    def __bool__(self) -> bool:
        return self.value

    def __repr__(self) -> str:
        return f"AtomicFlag({self.value})"


class AtomicGauge:
    """Thread-safe gauge that tracks min, max, and current value."""

    __slots__ = ("_value", "_min", "_max", "_lock")

    def __init__(self, initial: float = 0.0) -> None:
        self._value = float(initial)
        self._min = float(initial)
        self._max = float(initial)
        self._lock = threading.Lock()

    @property
    def value(self) -> float:
        with self._lock:
            return self._value

    def set(self, v: float) -> None:
        with self._lock:
            self._value = float(v)
            if self._value < self._min:
                self._min = self._value
            if self._value > self._max:
                self._max = self._value

    def reset(self, v: float = 0.0) -> None:
        with self._lock:
            self._value = float(v)
            self._min = self._value
            self._max = self._value

    def get_min(self) -> float:
        with self._lock:
            return self._min

    def get_max(self) -> float:
        with self._lock:
            return self._max

    def __repr__(self) -> str:
        return f"AtomicGauge(value={self.value}, min={self._min}, max={self._max})"


__all__ = [
    "Counter",
    "AtomicCounter",
    "AtomicFlag",
    "AtomicGauge",
    "RUST_AVAILABLE",
]
