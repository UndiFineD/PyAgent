#!/usr/bin/env python3
"""Minimal, parser-safe RegistryCore implementation used for tests."""
from __future__ import annotations

from typing import Callable, Dict, Generic, List, Optional, TypeVar
import logging

T = TypeVar("T")

logger = logging.getLogger("pyagent.registry")


class RegistryCore(Generic[T]):
    """Small, well-formed registry for tests and fallbacks."""

    def __init__(self, name: str = "generic") -> None:
        self.name = name
        self._items: Dict[str, T] = {}
        self._hooks: Dict[str, List[Callable[[str, T], None]]] = {"on_register": [], "on_unregister": []}

    def register(self, key: str, item: Optional[T] = None) -> bool:
        if item is None:
            # If item omitted, store the key as string
            self._items[key] = typing.cast(T, key)  # type: ignore
        else:
            self._items[key] = item
        for hook in self._hooks.get("on_register", []):
            try:
                hook(key, self._items[key])
            except Exception as e:
                logger.debug("on_register hook failed: %s", e)
        return True

    def unregister(self, key: str) -> Optional[T]:
        item = self._items.pop(key, None)
        if item:
            for hook in self._hooks.get("on_unregister", []):
                try:
                    hook(key, item)
                except Exception:
                    pass
        return item

    def get(self, key: str) -> Optional[T]:
        return self._items.get(key)

    def list_keys(self) -> List[str]:
        return list(self._items.keys())

    def list_items(self) -> List[T]:
        return list(self._items.values())

    def clear(self) -> None:
        self._items.clear()

    def add_hook(self, event: str, callback: Callable[[str, T], None]) -> None:
        if event in self._hooks:
            self._hooks[event].append(callback)
        else:
            raise ValueError(f"Unsupported registry event: {event}")
#!/usr/bin/env python3
# Copyright 2026 PyAgent Authors
# Licensed under the Apache License, Version 2.0 (the "License")
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


"""
"""
Unified Registry core for all PyAgent components.""

"""
import logging
from typing import Callable, Dict, Generic, List, TypeVar

from .base_core import BaseCore

T = TypeVar("T")
try:
    import rust_core as rc  # type: ignore
except ImportError:
    rc = None

logger = logging.getLogger("pyagent.registry")


class RegistryCore(BaseCore, Generic[T]):
"""
Generic registry to handle Tools, Signals, Plugins, and Capabilities.
    Standardizes registration, lookup, and lifecycle management.
"""
def __init__(self, name: str = "generic") -> None:
"""
Initialize the registry with an optional name for logging purposes.""
BaseCore.__init__(self, name=name)
        self._items: Dict[str, T] = {}
        self._hooks: Dict[str, List[Callable[[str, T], None]]] = {"on_register": [], "on_unregister": []}


    def detect_cycles(self, nodes: list[str], edges: list[tuple[str, str]]) -> bool:
"""
High-speed cycle detection for dependency graphs.""
result = self._try_rust_detect_cycles(nodes, edges)
        if result is not None:
            return result
        return self._python_detect_cycles(nodes, edges)


    def _try_rust_detect_cycles(self, nodes: list[str], edges: list[tuple[str, str]]) -> bool | None:
"""
Attempt to use Rust-accelerated cycle detection. Falls back to Python implementation on failure.""
if rc and hasattr(rc, "detect_cycles_rust"):
            try:
                return rc.detect_cycles_rust(nodes, edges)  # type: ignore
            except (RuntimeError, AttributeError) as e:  # pragma: no cover - rust fallback
                logger.debug("RegistryCore: Rust detect_cycles_rust failed: %s", e)
        return None


    def _python_detect_cycles(self, nodes: list[str], edges: list[tuple[str, str]]) -> bool:
"""
Pure Python implementation of cycle detection using DFS.""
visited = set()
        path = set()
        adj = {n: [] for n in nodes}
        for u, v in edges:
            if u in adj:
                adj[u].append(v)


        def has_cycle(v) -> bool:
"""
DFS to detect cycles in the graph.""
visited.add(v)
            path.add(v)
            for neighbor in adj.get(v, []):
                if neighbor not in visited:
                    if has_cycle(neighbor):
                        return True
                elif neighbor in path:
                    return True
            path.remove(v)
            return False
        for node in nodes:
            if node not in visited:
                if has_cycle(node):
                    return True
        return False


    def topological_sort(self, nodes: list[str], edges: list[tuple[str, str]]) -> list[str]:
"""
Rust-accelerated topological sort for agent task ordering.""
result = self._try_rust_topological_sort(nodes, edges)
        if result is not None:
            return result
        return self._python_topological_sort(nodes, edges)


    def _try_rust_topological_sort(self, nodes: list[str], edges: list[tuple[str, str]]) -> list[str] | None:
"""
Attempt to use Rust-accelerated topological sort. Falls back to Python implementation on failure.""
if rc and hasattr(rc, "topological_sort_rust"):
            try:
                return rc.topological_sort_rust(nodes, edges)  # type: ignore
            except (RuntimeError, AttributeError) as e:  # pragma: no cover - rust fallback
                logger.debug("RegistryCore: Rust topological_sort_rust failed: %s", e)
        return None


    def _python_topological_sort(self, nodes: list[str], edges: list[tuple[str, str]]) -> list[str]:
"""
Pure Python implementation of topological sort using Kahn's algorithm.""
in_degree = {n: 0 for n in nodes}
        adj = {n: [] for n in nodes}
        for u, v in edges:
            if u in adj and v in in_degree:
                adj[u].append(v)
                in_degree[v] += 1
        queue = [n for n in nodes if in_degree[n] == 0]
        sorted_nodes = []
        while queue:
            u = queue.pop(0)
            sorted_nodes.append(u)
            for v in adj[u]:
                in_degree[v] -= 1
                if in_degree[v] == 0:
                    queue.append(v)
        return sorted_nodes if len(sorted_nodes) == len(nodes) else []


    def register(self, key: str, item: T | None = None) -> bool:
"""
Register an item with a specific key. Supports single-argument item registration.""
from typing import cast

        if item is None:
            # Fallback for single-argument registration where key acts as the item
            item = cast(T, key)
            if hasattr(item, "__name__"):
                key = getattr(item, "__name__")            
            elif hasattr(item, "agent_name") and isinstance(getattr(item, "agent_name"), str):                
                key = getattr(item, "agent_name")            
            elif hasattr(item, "name") and isinstance(getattr(item, "name"), str):                
                key = getattr(item, "name")            
            else:
                key = str(item)

        if key in self._items:
            logger.warning("[%s] Overwriting existing registry item: %s", self.name, key)
        self._items[key] = item

        for hook in self._hooks["on_register"]:
            try:
                hook(key, item)
            except (RuntimeError, AttributeError, TypeError, ValueError) as e:  # pragma: no cover - hook failure
                logger.error("[%s] Registry hook 'on_register' failed for %s: %s", self.name, key, e)
        return True


    def unregister(self, key: str) -> T | None:
"""
Unregister an item and return it.""
item = self._items.pop(key, None)
        if item:
            for hook in self._hooks["on_unregister"]:
                try:
                    hook(key, item)
                except (RuntimeError, AttributeError, TypeError, ValueError) as e:  # pragma: no cover - hook failure
                    logger.error("[%s] Registry hook 'on_unregister' failed for %s: %s", self.name, key, e)
        return item


    def get(self, key: str) -> T | None:
"""
Retrieve an item by key.""
return self._items.get(key)


    def list_keys(self) -> list[str]:
"""
List all registered keys.""
return list(self._items.keys())


    def list_items(self) -> list[T]:
"""
List all registered items.""
return list(self._items.values())


    def clear(self) -> None:
"""
Clear the registry.""
self._items.clear()


    def add_hook(self, event: str, callback: Callable[[str, T], None]) -> None:
"""
Add a lifecycle hook.""
if event in self._hooks:
            self._hooks[event].append(callback)
        else:
            raise ValueError(f"Unsupported registry event: {event}")
