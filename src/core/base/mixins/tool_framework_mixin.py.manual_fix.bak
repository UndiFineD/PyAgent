#!/usr/bin/env python3
from __future__ import annotations

# Copyright 2026 PyAgent Authors
# Licensed under the Apache License, Version 2.0 (the "License")
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
""
"""
Tool Framework Mixin for BaseAgent.

"""

Provides a minimal, import-safe tool framework used by the tests. This
implementation intentionally keeps behavior simple: register tools via the
`create_tool` decorator and execute them with `execute_tool`.
""
import asyncio
import inspect
import json
import logging
import time
from dataclasses import dataclass
from typing import Any, Callable, Dict, List, Optional

from src.core.base.common.models.communication_models import CascadeContext


@dataclass
class ToolParameter:
    name: str
    type: str
    description: str = ""
    required: bool = True
    default: Any = None

    def to_dict(self) -> Dict[str, Any]:
        return {
            "name": self.name,
            "type": self.type,
            "description": self.description,
            "required": self.required,
            "default": self.default,
        }


@dataclass
class ToolDefinition:
    id: str
    description: str
    parameters: List[ToolParameter]
    execute_function: Callable[..., Any]
    category: str = "general"
    version: str = "1.0"

    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.id,
            "description": self.description,
            "parameters": [p.to_dict() for p in self.parameters],
            "category": self.category,
            "version": self.version,
        }


class ToolExecutionError(Exception):
    pass


class ToolValidationError(Exception):
    pass


class ToolFrameworkMixin:
    def __init__(self, **kwargs: Any) -> None:
        self.registered_tools: Dict[str, ToolDefinition] = {}
        self.tool_usage_stats: Dict[str, Dict[str, Any]] = {}
        self.enable_tool_validation: bool = bool(kwargs.get("enable_tool_validation", True))
        self.max_tool_execution_time: int = int(kwargs.get("max_tool_execution_time", 300))

    def create_tool(
        self, tool_id: str, description: str, parameter_schema: Optional[Dict[str, Any]] = None, category: str = "general", version: str = "1.0",
    ) -> Callable[[Callable[..., Any]], Callable[..., Any]]:
        def decorator(func: Callable[..., Any]) -> Callable[..., Any]:
            sig = inspect.signature(func)
            parameters: List[ToolParameter] = []
            for name, param in sig.parameters.items():
                if name == "self":
                    continue
                ptype = "string"
                parameters.append(ToolParameter(name=name, type=ptype, required=param.default == inspect.Parameter.empty, default=(None if param.default == inspect.Parameter.empty else param.default)))

            tool_def = ToolDefinition(id=tool_id, description=description, parameters=parameters, execute_function=func, category=category, version=version)
            self.registered_tools[tool_id] = tool_def

            async def tool_wrapper(*args, **kwargs):
                return await self.execute_tool(tool_id, kwargs.get("parameters", {}), kwargs.get("cascade_context"))

            tool_wrapper.__name__ = func.__name__
            tool_wrapper.__doc__ = func.__doc__
            return tool_wrapper

        return decorator

    async def execute_tool(self, tool_id: str, parameters: Dict[str, Any], cascade_context: Optional[CascadeContext] = None) -> Dict[str, Any]:
        if tool_id not in self.registered_tools:
            raise ToolExecutionError(f"Tool '{tool_id}' not found")

        tool_def = self.registered_tools[tool_id]

        # Basic validation
        if self.enable_tool_validation:
            for param in tool_def.parameters:
                if param.required and param.name not in parameters:
                    raise ToolValidationError(f"Missing required parameter: {param.name}")

        # Build kwargs for the function call
        call_kwargs = {k: v for k, v in parameters.items()}
        if "cascade_context" in inspect.signature(tool_def.execute_function).parameters:
            call_kwargs.setdefault("cascade_context", cascade_context)

        # Execute, respecting timeout
        try:
            if inspect.iscoroutinefunction(tool_def.execute_function):
                result = await asyncio.wait_for(tool_def.execute_function(**call_kwargs), timeout=self.max_tool_execution_time)
            else:
                # run in thread pool if blocking
                result = await asyncio.get_event_loop().run_in_executor(None, lambda: tool_def.execute_function(**call_kwargs))

            self._update_tool_stats(tool_id, success=True)
            return {"success": True, "result": result, "tool_id": tool_id}

        except asyncio.TimeoutError:
            error_msg = f"Tool '{tool_id}' execution timed out after {self.max_tool_execution_time} seconds"
            self._update_tool_stats(tool_id, success=False, error=error_msg)
            raise ToolExecutionError(error_msg)

        except Exception as e:
            error_msg = f"Tool '{tool_id}' execution failed: {e}"
            self._update_tool_stats(tool_id, success=False, error=error_msg)
            raise ToolExecutionError(error_msg)

    def get_tool_definitions(self) -> Dict[str, Dict[str, Any]]:
        return {tid: td.to_dict() for tid, td in self.registered_tools.items()}

    def get_tool_definition(self, tool_id: str) -> Optional[Dict[str, Any]]:
        td = self.registered_tools.get(tool_id)
        return td.to_dict() if td else None

    def unregister_tool(self, tool_id: str) -> bool:
        if tool_id in self.registered_tools:
            del self.registered_tools[tool_id]
            if tool_id in self.tool_usage_stats:
                del self.tool_usage_stats[tool_id]
            return True
        return False

    def get_tool_stats(self) -> Dict[str, Dict[str, Any]]:
        return self.tool_usage_stats.copy()

    def _update_tool_stats(self, tool_id: str, success: bool, error: Optional[str] = None) -> None:
        if tool_id not in self.tool_usage_stats:
            self.tool_usage_stats[tool_id] = {"calls": 0, "successes": 0, "failures": 0, "last_used": None, "last_error": None}

        stats = self.tool_usage_stats[tool_id]
        stats["calls"] += 1
        stats["last_used"] = time.time()
        if success:
            stats["successes"] += 1
        else:
            stats["failures"] += 1
            if error:
                stats["last_error"] = error