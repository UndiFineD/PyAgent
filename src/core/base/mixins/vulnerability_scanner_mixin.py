#!/usr/bin/env python3
# Copyright 2026 PyAgent Authors
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import concurrent.futures
from collections import namedtuple
from typing import List, Dict, Callable, Optional
import random
import string
import requests
from urllib.parse import urljoin, urlparse

Finding = namedtuple('Finding', ['name', 'url', 'description'])

class VulnerabilityScannerMixin:
    """
    Mixin providing vulnerability scanning capabilities inspired by aem-hacker patterns.
    
    Provides modular check registration and parallel scanning execution.
    """
    
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._vulnerability_checks: Dict[str, Callable] = {}
        self._scan_results: List[Finding] = []
        
    def register_vulnerability_check(self, name: str, check_func: Callable) -> None:
        """
        Register a vulnerability check function.
        
        Args:
            name: Unique name for the check
            check_func: Function that takes (base_url, my_host, debug, proxy) and returns List[Finding]
        """
        self._vulnerability_checks[name] = check_func
        
    def unregister_vulnerability_check(self, name: str) -> None:
        """Remove a registered check."""
        self._vulnerability_checks.pop(name, None)
        
    async def run_vulnerability_scan(self, base_url: str, my_host: str = None, 
                                   debug: bool = False, proxy: Optional[Dict] = None,
                                   workers: int = 4) -> List[Finding]:
        """
        Run all registered vulnerability checks in parallel.
        
        Args:
            base_url: Target URL to scan
            my_host: Host for callbacks (for SSRF detection)
            debug: Enable debug output
            proxy: Proxy configuration
            workers: Number of parallel workers
            
        Returns:
            List of findings
        """
        if not self._vulnerability_checks:
            return []
            
        self._scan_results = []
        
        # Run checks in parallel using ThreadPoolExecutor
        with concurrent.futures.ThreadPoolExecutor(max_workers=workers) as executor:
            futures = []
            for name, check_func in self._vulnerability_checks.items():
                future = executor.submit(check_func, base_url, my_host, debug, proxy)
                futures.append((name, future))
                
            for name, future in futures:
                try:
                    findings = future.result(timeout=30)  # 30 second timeout per check
                    if findings:
                        self._scan_results.extend(findings)
                except concurrent.futures.TimeoutError:
                    if debug:
                        print(f"Check {name} timed out")
                except Exception as e:
                    if debug:
                        print(f"Check {name} failed: {e}")
                        
        return self._scan_results
        
    def get_registered_checks(self) -> List[str]:
        """Get list of registered check names."""
        return list(self._vulnerability_checks.keys())
        
    def clear_scan_results(self) -> None:
        """Clear previous scan results."""
        self._scan_results = []
        
    # Utility methods for checks
    @staticmethod
    def random_string(length: int = 10) -> str:
        """Generate random string for cache busting."""
        return ''.join(random.choices(string.ascii_letters, k=length))
        
    @staticmethod
    def normalize_url(base_url: str, path: str) -> str:
        """Normalize URL by joining base with path."""
        if path.startswith('///'):
            # Handle triple slash bypass
            parsed = urlparse(base_url)
            return f"{parsed.scheme}://{parsed.netloc}{path.replace('///', '/')}"
        return urljoin(base_url.rstrip('/') + '/', path.lstrip('/'))
        
    @staticmethod
    def http_request(url: str, method: str = 'GET', data: Optional[str] = None,
                    headers: Optional[Dict] = None, proxy: Optional[Dict] = None,
                    timeout: int = 10) -> requests.Response:
        """Make HTTP request with proxy support."""
        proxies = proxy if proxy else {}
        return requests.request(method, url, data=data, headers=headers, 
                              proxies=proxies, timeout=timeout, verify=False)
