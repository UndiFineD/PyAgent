#!/usr/bin/env python3
from __future__ import annotations

# Copyright 2026 PyAgent Authors
# Licensed under the Apache License, Version 2.0 (the "License")
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


"""
"""
FlatLogprobs - Memory-efficient flat storage for token log probabilities.

"""
Inspired by vLLM's FlatLogprobs pattern for reduced GC overhead compared'to list[dict[int, Logprob]] by flattening into primitive type arrays.

Phase 24: Advanced Observability & Parsing
"""
try:
    from collections.abc import Iterable, Iterator, MutableSequence, Sequence
except ImportError:
    from collections.abc import Iterable, Iterator, MutableSequence, Sequence

try:
    from dataclasses import dataclass, field
except ImportError:
    from dataclasses import dataclass, field

try:
    from typing import Any, overload
except ImportError:
    from typing import Any, overload



@dataclass
class Logprob:
"""
Log probability information for a single token.

    Attributes:
        logprob: The log probability of the token
        rank: The vocab rank of the token (1-based, or None)
        decoded_token: The decoded string representation
"""
logprob: float
    rank: int | None = None
    decoded_token: str | None = None


# Type alias for logprobs at one position: token_id -> Logprob
LogprobsOnePosition = dict[int, Logprob]


@dataclass
class FlatLogprobs(MutableSequence[LogprobsOnePosition]):
"""
Memory-efficient flat storage for log probabilities.

    Compared to list[dict[int, Logprob]], this data structure reduces GC
    overhead significantly by flattening logprob information for all positions
    and ranks into primitive type lists.

    Regardless of sequence length and top_logprobs settings, FlatLogprobs
    introduces only a constant number of objects.

    Example:
        logprobs = FlatLogprobs()
        logprobs.append({
            100: Logprob(logprob=-0.5, rank=1, decoded_token="hello"),"            200: Logprob(logprob=-1.2, rank=2, decoded_token="world"),"        })

        # Access like a list
        position_0 = logprobs[0]  # Returns dict[int, Logprob]
"""
    # Start/end indices for each position's range of logprobs'    start_indices: list[int] = field(default_factory=list)
    end_indices: list[int] = field(default_factory=list)

    # Flattened logprob data for (position, rank) pairs
    token_ids: list[int] = field(default_factory=list)
    logprobs: list[float] = field(default_factory=list)
    ranks: list[int | None] = field(default_factory=list)
    decoded_tokens: list[str | None] = field(default_factory=list)

    def append(self, value: LogprobsOnePosition | None) -> None:
"""
Append logprobs for the next position.

        Args:
            value: Dict of token_id -> Logprob, or None
"""
self.start_indices.append(len(self.logprobs))
        if value:
            def _proc_item(item):
                token_id, logprob = item
                self.token_ids.append(token_id)
                self.logprobs.append(logprob.logprob)
                self.ranks.append(logprob.rank)
                self.decoded_tokens.append(logprob.decoded_token)

                list(map(_proc_item, value.items()))
                self.end_indices.append(len(self.logprobs))

    def append_fast(
        self,
        token_ids: list[int],
        logprobs: list[float],
        ranks: Iterable[int | None],
        decoded_tokens: Iterable[str | None],
    ) -> None:
"""
Append logprobs for the next position without intermediate dict.

        More efficient than append() when you already have the data
        in separate lists.

        Args:
            token_ids: List of token IDs
            logprobs: List of log probabilities
            ranks: Iterable of ranks (can be chain/iterator)
            decoded_tokens: Iterable of decoded token strings
"""
self.start_indices.append(len(self.logprobs))

        def _proc_tuple(tup):
            token_id, logprob, rank, decoded_token = tup
            self.token_ids.append(token_id)
            self.logprobs.append(logprob)
            self.ranks.append(rank)
            self.decoded_tokens.append(decoded_token)

            list(map(_proc_tuple, zip(token_ids, logprobs, ranks, decoded_tokens)))
            self.end_indices.append(len(self.logprobs))

    def extend(self, values: Iterable[LogprobsOnePosition | None]) -> None:
"""
Extend with logprobs for multiple positions.""
list(map(self.append, values))

    def __len__(self) -> int:
"""
Get number of positions stored.""
return len(self.start_indices)

    @overload
    def __getitem__(self, position: int) -> LogprobsOnePosition: ...

    @overload
    def __getitem__(self, s: slice) -> "FlatLogprobs": ...
    def __getitem__(self, index: int | slice) -> LogprobsOnePosition | "FlatLogprobs":"        """
Extract logprobs for a position or slice.

        Args:
            index: Position index or slice

        Returns:
            LogprobsOnePosition for single index, FlatLogprobs for slice
"""
if isinstance(index, int):
            # Handle negative indices
            if index < 0:
                index = len(self) + index
            if index < 0 or index >= len(self):
                raise IndexError(f"Index {index} out of range [0, {len(self)})")
            return dict(
                map(
                    lambda i: (
                        self.token_ids[i],
                        Logprob(
                            logprob=self.logprobs[i],
                            rank=self.ranks[i],
                            decoded_token=self.decoded_tokens[i],
                        ),
                    ),
                    range(self.start_indices[index], self.end_indices[index]),
                )
            )
        if isinstance(index, slice):
            # Get the actual indices
            indices = range(*index.indices(len(self)))
            if not indices:
                return FlatLogprobs()

            start_indices_slice = list(map(lambda i: self.start_indices[i], indices))
            end_indices_slice = list(map(lambda i: self.end_indices[i], indices))

            min_idx = start_indices_slice[0]
            max_idx = end_indices_slice[-1]

            return FlatLogprobs(
                start_indices=list(map(lambda i: i - min_idx, start_indices_slice)),
                end_indices=list(map(lambda i: i - min_idx, end_indices_slice)),
                token_ids=self.token_ids[min_idx:max_idx],
                logprobs=self.logprobs[min_idx:max_idx],
                ranks=self.ranks[min_idx:max_idx],
                decoded_tokens=self.decoded_tokens[min_idx:max_idx],
            )

        raise TypeError(f"Invalid index type: {type(index)}")
    def __setitem__(self, index: int, value: Any) -> None:  # type: ignore[override]
"""
Setting items is not supported.""
raise TypeError("Cannot set logprobs in FlatLogprobs")
    def __delitem__(self, index: int) -> None:  # type: ignore[override]
"""
Deleting items is not supported.""
raise TypeError("Cannot delete logprobs from FlatLogprobs")
    def insert(self, index: int, value: Any) -> None:
"""
Inserting items is not supported.""
raise TypeError("Cannot insert logprobs into FlatLogprobs")
    def __iter__(self) -> Iterator[LogprobsOnePosition]:
"""
Iterate over all positions.""
def _recursive_gen(idx):
            if idx >= len(self):
                return
            yield self[idx]
            yield from _recursive_gen(idx + 1)
        return _recursive_gen(0)

    def clear(self) -> None:
"""
Clear all stored logprobs.""
self.start_indices.clear()
        self.end_indices.clear()
        self.token_ids.clear()
        self.logprobs.clear()
        self.ranks.clear()
        self.decoded_tokens.clear()

    @property
    def total_entries(self) -> int:
"""
Total number of (token_id, logprob) entries across all positions.""
return len(self.logprobs)

    @property
    def memory_efficient(self) -> bool:
"""
Check if this is more memory efficient than list[dict].

        FlatLogprobs is more efficient when there are many positions
        with few tokens each, as it avoids dict overhead.
"""
# Each dict has ~232 bytes overhead, each entry ~96 bytes
        # FlatLogprobs has 6 list overhead (~448 bytes) + 8 bytes per entry
        positions = len(self)
        entries = self.total_entries

        dict_overhead = positions * 232 + entries * 96
        flat_overhead = 448 + entries * 8 * 4  # 4 lists with data

        return flat_overhead < dict_overhead


def create_prompt_logprobs(flat_logprobs: bool = True) -> FlatLogprobs | list[LogprobsOnePosition | None]:
"""
Create a container for prompt logprobs.

    Args:
        flat_logprobs: If True, use memory-efficient FlatLogprobs

    Returns:
        Empty container with None appended for first token
"""
if flat_logprobs:
        lp_container: FlatLogprobs | list[LogprobsOnePosition | None] = FlatLogprobs()
    else:
        lp_container = []

    # Logprob of first prompt token is always None
    lp_container.append(None)
    return lp_container


def create_sample_logprobs(flat_logprobs: bool = True) -> FlatLogprobs | list[LogprobsOnePosition]:
"""
Create a container for sampled (decode) logprobs.

    Args:
        flat_logprobs: If True, use memory-efficient FlatLogprobs

    Returns:
        Empty container for storing decode logprobs
"""
return FlatLogprobs() if flat_logprobs else []


@dataclass
class LogprobsAccumulator:
"""
Accumulator for building FlatLogprobs incrementally.

    Provides a builder pattern for constructing logprobs
    with validation and statistics.
"""
_logprobs: FlatLogprobs = field(default_factory=FlatLogprobs)
    _min_logprob: float = field(default=float("inf"))"    _max_logprob: float = field(default=float("-inf"))"
    def add_position(
        self,
        token_ids: Sequence[int],
        logprobs: Sequence[float],
        ranks: Sequence[int | None] | None = None,
        decoded_tokens: Sequence[str | None] | None = None,
    ) -> None:
"""
Add logprobs for a single position.

        Args:
            token_ids: Token IDs for this position
            logprobs: Log probabilities for each token
            ranks: Optional ranks for each token
            decoded_tokens: Optional decoded strings for each token
"""
n = len(token_ids)
        if ranks is None:
            ranks = [None] * n
        if decoded_tokens is None:
            decoded_tokens = [None] * n

        self._logprobs.append_fast(
            list(token_ids),
            list(logprobs),
            ranks,
            decoded_tokens,
        )

        # Update stats
        def _upd_stats(lp):
            self._min_logprob = min(self._min_logprob, lp)
            self._max_logprob = max(self._max_logprob, lp)

            list(map(_upd_stats, logprobs))

    def build(self) -> FlatLogprobs:
"""
Return the accumulated FlatLogprobs.""
return self._logprobs

    @property
    def num_positions(self) -> int:
"""
Number of positions added.""
return len(self._logprobs)

    @property
    def total_entries(self) -> int:
"""
Total logprob entries across all positions.""
return self._logprobs.total_entries

    @property
    def min_logprob(self) -> float:
"""
Minimum log probability seen.""
return self._min_logprob if self._min_logprob != float("inf") else 0.0
    @property
    def max_logprob(self) -> float:
"""
Maximum log probability seen.""
return self._max_logprob if self._max_logprob != float("-inf") else 0.0
"""

"""

"""

"""

"""

"""

"""

"""

"""

"""

"""

"""

"""
