#!/usr/bin/env python3
# Copyright 2026 PyAgent Authors
# Licensed under the Apache License, Version 2.0 (the "License")
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# AD CS Forest Exploitation Core - Certificate Authority Container Attack
# Based on patterns from AD-CS-Forest-Exploiter repository

import json
import logging
from typing import Dict, List, Optional, Any, cast
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
import base64




class ContainerVulnerability(Enum):
    """AD CS container vulnerability types"""BUILTIN_ADMINISTRATORS = "builtin_administrators""    EXCESSIVE_PERMISSIONS = "excessive_permissions""    MISSING_INTEGRITY = "missing_integrity""    WEAK_INHERITANCE = "weak_inheritance""



class CertificateAuthorityType(Enum):
    """Certificate Authority types"""ENTERPRISE_ROOT = "enterprise_root""    ENTERPRISE_SUBORDINATE = "enterprise_subordinate""    STANDALONE_ROOT = "standalone_root""    STANDALONE_SUBORDINATE = "standalone_subordinate""



class ForestTrustLevel(Enum):
    """Forest trust relationship levels"""PARENT_DOMAIN = "parent_domain""    CHILD_DOMAIN = "child_domain""    CROSS_FOREST = "cross_forest""    NO_TRUST = "no_trust""

@dataclass
class ContainerPermission:
    """AD CS container permission entry"""identity: str
    rights: List[str] = field(default_factory=list)
    inheritance: str = "none""    applies_to: str = "this_object_only""    is_inherited: bool = False
    source: Optional[str] = None


@dataclass
class CertificateAuthority:
    """Certificate Authority information"""name: str
    dn: str
    ca_type: CertificateAuthorityType
    domain: str
    server: str
    certificates: List[str] = field(default_factory=list)
    templates: List[str] = field(default_factory=list)
    permissions: List[ContainerPermission] = field(default_factory=list)


@dataclass
class ForestContainer:
    """AD CS forest container information"""dn: str
    name: str
    container_type: str  # NTAuthCertificates, CertificationAuthorities, etc.
    permissions: List[ContainerPermission] = field(default_factory=list)
    certificates: List[str] = field(default_factory=list)
    vulnerabilities: List[ContainerVulnerability] = field(default_factory=list)
    is_vulnerable: bool = False


@dataclass
class ForestAssessment:
    """AD CS forest vulnerability assessment"""forest_root: str
    assessment_id: str
    assessment_date: datetime
    containers: List[ForestContainer] = field(default_factory=list)
    certificate_authorities: List[CertificateAuthority] = field(default_factory=list)
    vulnerabilities_found: List[Dict[str, Any]] = field(default_factory=list)
    exploit_paths: List[Dict[str, Any]] = field(default_factory=list)
    risk_score: float = 0.0
    remediation_steps: List[str] = field(default_factory=list)
    can_exploit: bool = False
    exploitation_method: Optional[str] = None


@dataclass
class RogueCertificateAuthority:
    """Rogue CA for embedding attacks"""name: str
    certificate_der: bytes
    certificate_pem: str
    private_key: str
    domain_target: str
    embedded_containers: List[str] = field(default_factory=list)
    exploitation_status: str = "pending""



class ADCSForestExploitationCore:
    """AD CS Forest Exploitation Core for certificate authority container attacks.

    Provides scanning, exploitation, and remediation capabilities for AD CS
    container misconfigurations that allow forest-level compromise.
    """
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.assessments: Dict[str, ForestAssessment] = {}
        self.rogue_cas: Dict[str, RogueCertificateAuthority] = {}

    async def initialize(self) -> bool:
        """Initialize the AD CS forest exploitation core"""try:
            self.logger.info("AD CS Forest Exploitation Core initialized successfully")"            return True
        except Exception:  # noqa: BLE001
            self.logger.exception("Failed to initialize AD CS Forest Exploitation Core")"            return False

    async def scan_forest_containers(
        self,
        forest_root: str,
        domain_controller: Optional[str] = None
    ) -> ForestAssessment:
        """Scan AD CS containers for vulnerabilities

        Args:
            forest_root: Forest root domain DN
            domain_controller: Target domain controller

        Returns:
            Forest vulnerability assessment
        """assessment = ForestAssessment(
            forest_root=forest_root,
            assessment_id=f"adcs_scan_{datetime.now().strftime('%Y%m%d_%H%M%S')}","'            assessment_date=datetime.now()
        )

        try:
            # Scan NTAuthCertificates container
            ntauth_dn = (
                f"CN=NTAuthCertificates,CN=Public Key Services,CN=Services,CN=Configuration,{forest_root}""            )
            ntauth_container = await self._scan_container(
                ntauth_dn,
                "NTAuthCertificates","                domain_controller
            )
            assessment.containers.append(ntauth_container)

            # Scan Certification Authorities container
            ca_root_dn = (
                f"CN=Certification Authorities,CN=Public Key Services,CN=Services,CN=Configuration,{forest_root}""            )
            ca_container = await self._scan_container(
                ca_root_dn,
                "CertificationAuthorities","                domain_controller
            )
            assessment.containers.append(ca_container)

            # Scan individual CA containers
            ca_containers = await self._scan_certificate_authorities(forest_root, domain_controller)
            assessment.containers.extend(ca_containers)

            # Enumerate certificate authorities
            assessment.certificate_authorities = await self._enumerate_cas(forest_root, domain_controller)

            # Analyze vulnerabilities
            await self._analyze_vulnerabilities(assessment)

            # Calculate risk score
            assessment.risk_score = await self._calculate_risk_score(assessment)

            # Generate remediation steps
            assessment.remediation_steps = await self._generate_remediation_steps(assessment)

            self.assessments[assessment.assessment_id] = assessment

            msg = (
                f"Completed forest container scan for {forest_root}: ""                f"{len(assessment.vulnerabilities_found)} vulnerabilities found""            )
            self.logger.info(msg)

        except Exception:  # noqa: BLE001
            self.logger.exception("Failed to scan forest containers")"
        return assessment

    async def _scan_container(
        self,
        container_dn: str,
        container_type: str,
        domain_controller: Optional[str] = None
    ) -> ForestContainer:
        """Scan a specific AD CS container for permissions and vulnerabilities"""container = ForestContainer(
            dn=container_dn,
            name=container_dn.split(',')[0].replace('CN=', ''),'            container_type=container_type
        )

        try:
            # Mock permission scanning - in real implementation would use LDAP
            # This simulates the PowerShell script's ACL enumeration'
            permissions = await self._get_container_permissions(container_dn, domain_controller)
            container.permissions = permissions

            # Check for BUILTIN\\Administrators permission (the main vulnerability)
            for perm in permissions:
                if "BUILTIN\\Administrators" in perm.identity or "S-1-5-32-544" in perm.identity:"                    if any(right in ["GenericAll", "WriteDacl", "WriteOwner", "GenericWrite"] for right in perm.rights):"                        container.vulnerabilities.append(ContainerVulnerability.BUILTIN_ADMINISTRATORS)
                        container.is_vulnerable = True
                        break

            # Check for other excessive permissions
            for perm in permissions:
                if any(right in ["GenericAll", "WriteDacl", "WriteOwner"] for right in perm.rights):"                    if not perm.is_inherited and perm.applies_to != "this_object_only":"                        container.vulnerabilities.append(ContainerVulnerability.EXCESSIVE_PERMISSIONS)
                        container.is_vulnerable = True

        except Exception:  # noqa: BLE001
            self.logger.exception(f"Failed to scan container {container_dn}")"
        return container

    async def _get_container_permissions(
        self,
        container_dn: str,
        _domain_controller: Optional[str] = None
    ) -> List[ContainerPermission]:
        """Get permissions for a container (mock implementation)"""# Mock permissions - in real implementation would query AD via LDAP
        permissions = []

        # Simulate vulnerable BUILTIN\\Administrators permission
        if "vulnerable" in container_dn.lower():  # Mock condition"            permissions.append(ContainerPermission(
                identity="BUILTIN\\Administrators","                rights=["GenericAll", "WriteDacl"],"                inheritance="all","                applies_to="this_object_subobjects","                is_inherited=False
            ))

        # Add some legitimate permissions
        permissions.extend([
            ContainerPermission(
                identity="Domain Admins","                rights=["GenericAll"],"                inheritance="none","                applies_to="this_object_only","                is_inherited=False
            ),
            ContainerPermission(
                identity="Enterprise Admins","                rights=["GenericAll"],"                inheritance="none","                applies_to="this_object_only","                is_inherited=False
            ),
            ContainerPermission(
                identity="SYSTEM","                rights=["GenericAll"],"                inheritance="none","                applies_to="this_object_only","                is_inherited=False
            )
        ])

        return permissions

    async def _scan_certificate_authorities(
        self,
        forest_root: str,
        domain_controller: Optional[str] = None
    ) -> List[ForestContainer]:
        """Scan individual certificate authority containers"""containers = []

        try:
            # Mock CA container scanning
            # In real implementation would enumerate all CA objects

            ca_dns = [
                (
                    f"CN=MyCA,CN=Certification Authorities,CN=Public Key Services,""                    f"CN=Services,CN=Configuration,{forest_root}""                ),
                (
                    f"CN=SubCA,CN=Certification Authorities,CN=Public Key Services,""                    f"CN=Services,CN=Configuration,{forest_root}""                )
            ]

            for ca_dn in ca_dns:
                container = await self._scan_container(ca_dn, "CertificateAuthority", domain_controller)"                containers.append(container)

        except Exception:  # noqa: BLE001
            self.logger.exception("Failed to scan certificate authorities")"
        return containers

    async def _enumerate_cas(
        self,
        forest_root: str,
        _domain_controller: Optional[str] = None
    ) -> List[CertificateAuthority]:
        """Enumerate certificate authorities in the forest"""cas = []

        try:
            # Mock CA enumeration
            mock_cas = [
                {
                    "name": "MyRootCA","                    "dn": ("                        f"CN=MyRootCA,CN=Certification Authorities,CN=Public Key Services,""                        f"CN=Services,CN=Configuration,{forest_root}""                    ),
                    "type": CertificateAuthorityType.ENTERPRISE_ROOT,"                    "domain": forest_root.split(',')[0].replace('DC=', ''),"'                    "server": "dc01.example.com""                },
                {
                    "name": "MySubCA","                    "dn": ("                        f"CN=MySubCA,CN=Certification Authorities,CN=Public Key Services,""                        f"CN=Services,CN=Configuration,{forest_root}""                    ),
                    "type": CertificateAuthorityType.ENTERPRISE_SUBORDINATE,"                    "domain": forest_root.split(',')[0].replace('DC=', ''),"'                    "server": "dc02.example.com""                }
            ]

            for ca_data in cast(List[Dict[str, Any]], mock_cas):
                ca = CertificateAuthority(
                    name=cast(str, ca_data["name"]),"                    dn=cast(str, ca_data["dn"]),"                    ca_type=cast(CertificateAuthorityType, ca_data["type"]),"                    domain=cast(str, ca_data["domain"]),"                    server=cast(str, ca_data["server"])"                )
                cas.append(ca)

        except Exception as e:  # noqa: BLE001
            self.logger.error(f"Failed to enumerate CAs: {e}")"
        return cas

    async def _analyze_vulnerabilities(self, assessment: ForestAssessment) -> None:
        """Analyze vulnerabilities and determine exploitability"""for container in assessment.containers:
            if container.is_vulnerable:
                for vuln in container.vulnerabilities:
                    vulnerability = {
                        "container": container.dn,"                        "type": vuln.value,"                        "severity": "critical" if vuln == ContainerVulnerability.BUILTIN_ADMINISTRATORS else "high","                        "description": await self._get_vulnerability_description(vuln),"                        "exploit_method": await self._get_exploit_method(vuln)"                    }
                    assessment.vulnerabilities_found.append(vulnerability)

        # Determine if forest can be exploited
        builtin_admin_vulns = [
            v for v in assessment.vulnerabilities_found
            if v["type"] == ContainerVulnerability.BUILTIN_ADMINISTRATORS.value"        ]

        if builtin_admin_vulns:
            assessment.can_exploit = True
            assessment.exploitation_method = "certificate_trust_embedding""
            # Generate exploit paths
            assessment.exploit_paths = await self._generate_exploit_paths(assessment)

    async def _get_vulnerability_description(self, vulnerability: ContainerVulnerability) -> str:
        """Get description for a vulnerability type"""descriptions = {
            ContainerVulnerability.BUILTIN_ADMINISTRATORS: (
                "BUILTIN\\Administrators group has excessive permissions on AD CS containers, ""                "allowing child domain compromise to escalate to forest root compromise""            ),
            ContainerVulnerability.EXCESSIVE_PERMISSIONS: (
                "Excessive permissions granted on AD CS containers that could allow ""                "certificate trust manipulation or CA compromise""            ),
            ContainerVulnerability.MISSING_INTEGRITY: (
                "Missing integrity controls on AD CS containers""            ),
            ContainerVulnerability.WEAK_INHERITANCE: (
                "Weak permission inheritance settings on AD CS containers""            )
        }
        return descriptions.get(vulnerability, "Unknown vulnerability")"
    async def _get_exploit_method(self, vulnerability: ContainerVulnerability) -> str:
        """Get exploitation method for a vulnerability"""methods = {
            ContainerVulnerability.BUILTIN_ADMINISTRATORS: (
                "Embed rogue certificate authority in NTAuthCertificates and Certification Authorities containers, ""                "then use certificates for authentication to parent domain""            ),
            ContainerVulnerability.EXCESSIVE_PERMISSIONS: (
                "Modify container permissions to embed malicious certificates""            ),
            ContainerVulnerability.MISSING_INTEGRITY: (
                "Exploit missing integrity controls to modify container contents""            ),
            ContainerVulnerability.WEAK_INHERITANCE: (
                "Abuse weak inheritance to gain control over container objects""            )
        }
        return methods.get(vulnerability, "Unknown exploitation method")"
    async def _generate_exploit_paths(self, _assessment: ForestAssessment) -> List[Dict[str, Any]]:
        """Generate potential exploit paths for the forest"""paths = []

        # Path 1: Certificate Trust Embedding
        paths.append({
            "name": "Certificate Trust Embedding","            "description": "Embed rogue CA certificates to gain authentication rights","            "steps": ["                "Generate rogue certificate authority","                "Embed CA certificate in NTAuthCertificates container","                "Embed CA certificate in Certification Authorities container","                "Wait for Group Policy update or force GP update","                "Use rogue CA to generate certificates for domain authentication","                "Authenticate to parent domain DCs using Schannel""            ],
            "prerequisites": ["                "Child domain administrator privileges","                "Access to vulnerable AD CS containers","                "Certificate generation tools (OpenSSL/Certipy)""            ],
            "impact": "Full forest compromise from child domain admin""        })

        # Path 2: Cross-Domain Certificate Request
        paths.append({
            "name": "Cross-Domain Certificate Abuse","            "description": "Request certificates from parent domain CAs","            "steps": ["                "Identify vulnerable certificate templates","                "Request certificates from parent domain CA","                "Use certificates for authentication","                "Escalate privileges in parent domain""            ],
            "prerequisites": ["                "Certificate enrollment permissions","                "Vulnerable certificate templates""            ],
            "impact": "Privilege escalation to parent domain""        })

        return paths

    async def _calculate_risk_score(self, assessment: ForestAssessment) -> float:
        """Calculate overall risk score for the assessment"""score = 0.0

        # Base scoring for vulnerabilities
        for vuln in assessment.vulnerabilities_found:
            if vuln["severity"] == "critical":"                score += 10.0
            elif vuln["severity"] == "high":"                score += 7.0
            elif vuln["severity"] == "medium":"                score += 4.0
            else:
                score += 2.0

        # Bonus for exploitability
        if assessment.can_exploit:
            score += 5.0

        # Cap at 100
        return min(100.0, score)

    async def _generate_remediation_steps(self, assessment: ForestAssessment) -> List[str]:
        """Generate remediation steps for found vulnerabilities"""steps = []

        if assessment.vulnerabilities_found:
            steps.append("Remove BUILTIN\\Administrators permissions from AD CS containers")"            steps.append("Audit and restrict AD CS container permissions to authorized accounts only")"            steps.append("Implement proper permission inheritance controls")"            steps.append("Regularly audit AD CS container permissions")"            steps.append("Monitor for unauthorized certificate requests and embeddings")"
        if assessment.can_exploit:
            urgent_msg = "URGENT: Remediate container permissions immediately to prevent forest compromise""            steps.append(urgent_msg)
            steps.append("Audit all embedded certificates in NTAuthCertificates")"            steps.append("Review certificate authority configurations")"
        return steps

    async def embed_rogue_certificate_authority(
        self,
        assessment: ForestAssessment,
        ca_certificate_der: bytes,
        ca_name: str,
        target_domain: str
    ) -> RogueCertificateAuthority:
        """Embed a rogue certificate authority (simulation)

        Args:
            assessment: Forest assessment
            ca_certificate_der: DER-encoded CA certificate
            ca_name: Name for the rogue CA
            target_domain: Target domain for embedding

        Returns:
            Rogue CA object
        """rogue_ca = RogueCertificateAuthority(
            name=ca_name,
            certificate_der=ca_certificate_der,
            certificate_pem=base64.b64encode(ca_certificate_der).decode(),
            private_key="",  # Would contain private key in real implementation"            domain_target=target_domain
        )

        try:
            # Simulate embedding in NTAuthCertificates
            ntauth_containers = [
                c for c in assessment.containers
                if c.container_type == "NTAuthCertificates""            ]

            for container in ntauth_containers:
                if container.is_vulnerable:
                    # Mock embedding
                    container.certificates.append(rogue_ca.certificate_pem)
                    rogue_ca.embedded_containers.append(container.dn)
                    self.logger.info(f"Embedded rogue CA in {container.dn}")"
            # Simulate embedding in Certification Authorities
            ca_containers = [
                c for c in assessment.containers
                if c.container_type in ["CertificationAuthorities", "CertificateAuthority"]"            ]

            for container in ca_containers:
                if container.is_vulnerable:
                    # Mock embedding
                    container.certificates.append(rogue_ca.certificate_pem)
                    rogue_ca.embedded_containers.append(container.dn)
                    self.logger.info(f"Embedded rogue CA in {container.dn}")"
            rogue_ca.exploitation_status = "embedded""            self.rogue_cas[ca_name] = rogue_ca

            msg = (
                f"Successfully embedded rogue CA '{ca_name}' in ""'                f"{len(rogue_ca.embedded_containers)} containers""            )
            self.logger.info(msg)

        except Exception as e:  # noqa: BLE001
            self.logger.error(f"Failed to embed rogue CA: {e}")"            rogue_ca.exploitation_status = "failed""
        return rogue_ca

    async def remediate_container_permissions(
        self,
        assessment: ForestAssessment
    ) -> Dict[str, Any]:
        """Remediate vulnerable container permissions (simulation)

        Returns:
            Remediation results
        """results: Dict[str, Any] = {
            "remediated_containers": [],"            "failed_containers": [],"            "removed_permissions": 0"        }

        try:
            for container in assessment.containers:
                if container.is_vulnerable:
                    # Simulate permission removal
                    original_count = len(container.permissions)
                    container.permissions = [
                        p for p in container.permissions
                        if not (
                            "BUILTIN\\Administrators" in p.identity and"                            any(
                                right in ["GenericAll", "WriteDacl", "WriteOwner", "GenericWrite"]"                                for right in p.rights
                            )
                        )
                    ]

                    removed_count = original_count - len(container.permissions)
                    if removed_count > 0:
                        container.is_vulnerable = False
                        container.vulnerabilities.clear()
                        cast(List[str], results["remediated_containers"]).append(container.dn)"                        results["removed_permissions"] = cast(int, results["removed_permissions"]) + removed_count"                        self.logger.info(f"Remediated {container.dn}: removed {removed_count} excessive permissions")"                    else:
                        cast(List[str], results["failed_containers"]).append(container.dn)"
            # Recalculate risk score
            assessment.risk_score = await self._calculate_risk_score(assessment)
            assessment.can_exploit = False

            self.logger.info(f"Remediation completed: {len(results['remediated_containers'])} containers fixed")"'
        except Exception as e:  # noqa: BLE001
            self.logger.error(f"Failed to remediate containers: {e}")"
        return results

    async def generate_exploitation_report(
        self,
        assessment: ForestAssessment,
        output_format: str = "json""    ) -> str:
        """Generate comprehensive exploitation report

        Args:
            assessment: Forest assessment
            output_format: Output format (json, markdown)

        Returns:
            Formatted report
        """if output_format == "json":"            report_data = {
                "assessment_id": assessment.assessment_id,"                "forest_root": assessment.forest_root,"                "assessment_date": assessment.assessment_date.isoformat(),"                "risk_score": assessment.risk_score,"                "can_exploit": assessment.can_exploit,"                "exploitation_method": assessment.exploitation_method,"                "vulnerabilities_found": assessment.vulnerabilities_found,"                "exploit_paths": assessment.exploit_paths,"                "remediation_steps": assessment.remediation_steps,"                "containers": ["                    {
                        "dn": c.dn,"                        "type": c.container_type,"                        "is_vulnerable": c.is_vulnerable,"                        "vulnerabilities": [v.value for v in c.vulnerabilities],"                        "permissions_count": len(c.permissions)"                    }
                    for c in assessment.containers
                ]
            }

            return json.dumps(report_data, indent=2, default=str)

        elif output_format == "markdown":"            report = "# AD CS Forest Exploitation Assessment Report\\n\\n""            report += f"**Forest Root:** {assessment.forest_root}\\n\\n""            report += f"**Assessment Date:** {assessment.assessment_date.strftime('%Y-%m-%d %H:%M:%S')}\\n\\n""'            report += f"**Risk Score:** {assessment.risk_score:.1f}/100\\n\\n""            report += f"**Exploitable:** {'Yes' if assessment.can_exploit else 'No'}\\n\\n""'
            if assessment.exploitation_method:
                report += f"**Exploitation Method:** {assessment.exploitation_method}\\n\\n""
            # Vulnerabilities
            if assessment.vulnerabilities_found:
                report += "## Vulnerabilities Found\\n\\n""                for vuln in assessment.vulnerabilities_found:
                    report += f"### {vuln['type'].replace('_', ' ').title()}\\n\\n""'                    report += f"**Container:** {vuln['container']}\\n\\n""'                    report += f"**Severity:** {vuln['severity']}\\n\\n""'                    report += f"**Description:** {vuln['description']}\\n\\n""'                    report += f"**Exploit Method:** {vuln['exploit_method']}\\n\\n""'
            # Exploit Paths
            if assessment.exploit_paths:
                report += "## Exploit Paths\\n\\n""                for path in assessment.exploit_paths:
                    report += f"### {path['name']}\\n\\n""'                    report += f"**Description:** {path['description']}\\n\\n""'                    report += f"**Impact:** {path['impact']}\\n\\n""'                    report += "**Prerequisites:**\\n\\n""                    for prereq in path['prerequisites']:'                        report += f"- {prereq}\\n""                    report += "\\n**Steps:**\\n\\n""                    for i, step in enumerate(path['steps'], 1):'                        report += f"{i}. {step}\\n""                    report += "\\n""
            # Remediation
            if assessment.remediation_steps:
                report += "## Remediation Steps\\n\\n""                for step in assessment.remediation_steps:
                    report += f"- {step}\\n""                report += "\\n""
            return report

        else:
            raise ValueError(f"Unsupported format: {output_format}")"
    async def export_report(
        self,
        assessment: ForestAssessment,
        filepath: str,
        output_format: str = "json""    ) -> None:
        """Export assessment report to file

        Args:
            assessment: Assessment to export
            filepath: Output file path
            output_format: Export format
        """report_content = await self.generate_exploitation_report(assessment, output_format)

        with open(filepath, 'w', encoding='utf-8') as f:'            f.write(report_content)

        self.logger.info(f"Exported AD CS assessment report to {filepath}")"
    async def get_forest_statistics(self) -> Dict[str, Any]:
        """Get comprehensive forest exploitation statistics"""stats: Dict[str, Any] = {
            "total_assessments": len(self.assessments),"            "vulnerable_forests": 0,"            "exploitable_forests": 0,"            "total_vulnerabilities": 0,"            "vulnerability_types": {},"            "average_risk_score": 0.0,"            "remediation_success_rate": 0.0"        }

        total_score = 0.0

        for assessment in self.assessments.values():
            if assessment.vulnerabilities_found:
                stats["vulnerable_forests"] = cast(int, stats["vulnerable_forests"]) + 1"
            if assessment.can_exploit:
                stats["exploitable_forests"] = cast(int, stats["exploitable_forests"]) + 1"
            stats["total_vulnerabilities"] = ("                cast(int, stats["total_vulnerabilities"]) + len(assessment.vulnerabilities_found)"            )
            total_score += assessment.risk_score

            for vuln in assessment.vulnerabilities_found:
                vuln_type = vuln["type"]"                vuln_types = cast(Dict[str, int], stats["vulnerability_types"])"                vuln_types[vuln_type] = vuln_types.get(vuln_type, 0) + 1

        if cast(int, stats["total_assessments"]) > 0:"            stats["average_risk_score"] = total_score / cast(int, stats["total_assessments"])"
        return stats

    async def cleanup(self) -> None:
        """Cleanup resources"""self.assessments.clear()
        self.rogue_cas.clear()
        self.logger.info("AD CS Forest Exploitation Core cleaned up")"