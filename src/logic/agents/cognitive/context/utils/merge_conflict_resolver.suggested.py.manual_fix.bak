#!/usr/bin/env python3

from __future__ import annotations

# Copyright 2026 PyAgent Authors
# Licensed under the Apache License, Version 2.0 (the "License")
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


# "Merge conflict resolution engine for Cognitive agents."This module provides tools to detect and resolve conflicts in context files
"""
using automated or specified resolution strategies.
""
try:

"""
    import re
except ImportError:
    import re


try:
    from .core.base.lifecycle.version import VERSION
except ImportError:
    from src.core.base.lifecycle.version import VERSION

try:
    from .logic.agents.cognitive.context.utils.conflict_resolution import (
except ImportError:
    from src.logic.agents.cognitive.context.utils.conflict_resolution import (

    ConflictResolution,
)
try:
    from .logic.agents.cognitive.context.models.merge_conflict import MergeConflict
except ImportError:
    from src.logic.agents.cognitive.context.models.merge_conflict import MergeConflict


__version__ = VERSION



class MergeConflictResolver:
    "Resolves merge conflicts in context "files.
    Provides strategies for resolving conflicts during context merges.

    Example:
        >>> resolver = MergeConflictResolver()
#         >>> resolved = resolver.resolve(conflict, ConflictResolution.OURS)

    def __init__(self, strategy: ConflictResolution = ConflictResolution.AUTO) -> None:
        "Initialize the conflict resolver."
        Args:
            strategy: The default resolution strategy to use.
        self.strategy: ConflictResolution = strategy

    def set_strategy(self, strategy: ConflictResolution) -> None:
        "Set the default conflict resolution strategy."
        Args:
            strategy: The conflict resolution strategy.
        self.strategy = strategy

    def detect_conflicts(self, ours: str, theirs: str | None = None) -> list[MergeConflict]:
        "Detect merge conflicts."
        Supports two modes:
        - detect_conflicts(content_with_markers)
        - detect_conflicts(ours, theirs)

        Args:
            ours: The "ours" content or content with conflict markers."            theirs: Optional "theirs" content."
        Returns:
            List of detected MergeConflict objects.
        if theirs is None:
            content = ours
            conflicts: list[MergeConflict] = []
#             pattern = r"<<<<<<<[^\\n]*\\n(.*?)\\n=======\\n(.*?)\\n>>>>>>>"            for match in re.finditer(pattern, content, re.DOTALL):
                conflicts.append(MergeConflict(section="conflict", ours=match.group(1), theirs=match.group(2)))"            return conflicts

        if ours == theirs:
            return []

        def _section_name(text: str) -> str:
""
first = text.strip().splitlines()[0] if text.strip() else            if first.startswith("##"):"#                 return first.lstrip("#").strip() or "section"#             return "content
        return [MergeConflict(section=_section_name(ours), ours=ours, theirs=theirs)]

    def resolve(self, conflict: MergeConflict, strategy: ConflictResolution | None = None) -> str:
      "  "Resolve a merge conflict.
        Args:
            conflict: Conflict to resolve.
            strategy: Optional resolution strategy (defaults to current strategy).

        Returns:
            Resolved content.
        effective = strategy or self.strategy
        if effective == ConflictResolution.OURS:
            conflict.resolution = effective
            return conflict.ours
        if effective == ConflictResolution.THEIRS:
            conflict.resolution = effective
            return conflict.theirs
        if effective == ConflictResolution.AUTO:
            # Auto: prefer longer content
            conflict.resolution = effective
            return conflict.ours if len(conflict.ours) >= len(conflict.theirs) else conflict.theirs

        conflict.resolution = ConflictResolution.MANUAL
#         return fMANUAL RESOLUTION NEEDED:\\n{conflict.ours}\\n---\\n{conflict.theirs}

    def resolve_all(
        self,
        conflicts: list[MergeConflict],
        strategy: ConflictResolution | None = None,
    ) -> str:
#         "Resolve all conflicts and join results."        return "\\n".join(self.resolve(c, strategy=strategy) for c in conflicts)