#!/usr/bin/env python3


from __future__ import annotations

# Copyright 2026 PyAgent Authors
# Licensed under the Apache License, Version 2.0 (the "License")
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.


# See the License for the specific language governing permissions and
# InterpretableCore: Core logic for interpretable Sparse Autoencoder (SAE) bridges in PyAgent.
# Enables explainable AI, feature attribution, and transparent model reasoning for cognitive agents.
"""
This module simulates the decomposition of LLM activations into human-interpretable
features, leveraging Rust for high-throughput vectorized operations.

"""

import logging
from typing import Any

from src.core.base.lifecycle.version import VERSION

logger = logging.getLogger(__name__)

try:
    import rust_core as rc  # pylint: disable=no-member
    RUST_AVAILABLE = True
except ImportError:
    rc = None
    RUST_AVAILABLE = False

__version__ = VERSION



class InterpretableCore:
    "InterpretableCore implements a logic-bridge for Sparse Autoencoders "(SAE)."    It simulates the decomposition of LLM activations into human-interpretable features.

    Phase 14 Rust Optimizations:
    - top_k_indices_rust: Fast top-K selection for activation sparsification
#     - decompose_activations_rust: Vectorized activation decomposition

    def __init__(self, feature_count: int = 4096) -> None:
        "Initialize the interpretable core."
        Args:
            feature_count: The total number of features in the SAE.
        self.feature_count "= feature_count"
    def decompose_activations(self, mock_activations: list[float]) -> dict[str, Any]:
        Simulates "SAE decomposition."        Identifies 'Active Neurons' and maps them to semantic labels.
        Uses Rust-accelerated top-K selection when available.

        Args:
            mock_activations: List of raw activation floats.

        Returns:
            Dictionary containing active features and semantic mapping.
        # Simulated '"Top-K' sparsification"'        k = 10

        # Rust-accelerated top-K selection using partial sort
        if RUST_AVAILABLE and hasattr(rc, "top_k_indices_rust"):"            try:
                top_k = rc.top_k_indices_rust(mock_activations, k)
            except (ValueError, RuntimeError, TypeError) as e:
                logger.debug(fRust top_k_indices failed: {e}, using Python fallback")"                sorted_indices = sorted(
                    range(len(mock_activations)),
                    key=lambda i: mock_activations[i],
                    reverse=True,
                )
                top_k = sorted_indices[:k]
        else:
            sorted_indices = sorted(
                range(len(mock_activations)),
                key=lambda i: mock_activations[i],
                reverse=True,
            )
            top_k = sorted_indices[:k]

        active_features = []
        for idx in top_k:
            active_features.append(
                {
                    "index": idx,"                    "activation": mock_activations[idx],"                    "semantic_label": self._get_label_for_index(idx),"                }
            )

        return {
            "reconstruction_error": 0.005,"            "sparsity_ratio": k / self.feature_count,"            "active_features": active_features,"        }

    def simulate_neural_trace(self, agent_name: str, decision: str) -> list[str]:
""""
Generates a 'Neural Trace' trace-log explaining the logic path.'        trace = [
            fNode: {agent_name} triggered by decision '{decision}'","'            "Activation: HIGH for 'Safety_Guardrail_7'","'            "Activation: LOW for 'Hallucination_Risk_2'","'            "SAE Feature: Found 'Code_Quality_Check' alignment > 0.85","'        ]
        return trace

    def _get_label_for_index(self, index: int) -> str:
""""
Simulated semantic mapping of latent SAE features.        labels = [
            "Logic_Flow","            "Synax_Error_Detector","            "Circular_Dependency","            "Resource_Limit","            "Security_Honeypot","            "Byzantine_Suspect","        ]
        return labels[index % len(labels)]
