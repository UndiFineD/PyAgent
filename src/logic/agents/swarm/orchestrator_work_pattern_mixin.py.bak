#!/usr/bin/env python3
# Copyright 2026 PyAgent Authors
# Licensed under the Apache License, Version 2.0 (the "License")
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
from __future__ import annotations


OrchestratorWorkPatternMixin - Work pattern orchestration for OrchestratorAgent

# DATE: 2026-02-13
# AUTHOR: Keimpe de Jong
USAGE:
- Mix into an OrchestratorAgent (class OrchestratorAgent(OrchestratorWorkPatternMixin, ...)) to add work-pattern registration and execution.
- Register WorkPattern instances with register_work_pattern(pattern) before use.
- Use execute_with_pattern(context, pattern_name=None, **kwargs) to run tasks using a named or default pattern.
- Use list_work_patterns() to enumerate available patterns and validate_work_pattern_setup(name) to check readiness.

WHAT IT DOES:
Provides a lightweight mixin that stores and manages named WorkPattern objects, tracks a default pattern (prefers the first registered or a pattern named "PEER"), exposes methods to register, retrieve, list, validate, and asynchronously execute work patterns using a CascadeContext, and logs key lifecycle events."
WHAT IT SHOULD DO BETTER:
- Provide clearer error types (custom exceptions) instead of ValueError for missing/default patterns to allow callers to handle specific failure modes.
- Expose hooks or callbacks for lifecycle events (on_register, on_execute_start/finish) to allow customization without subclassing.
- Add richer validation reporting (returning diagnostics) from validate_work_pattern_setup instead of a simple boolean, and include timeout/cancellation support for long-running pattern.execute calls.

FILE CONTENT SUMMARY:
OrchestratorWorkPatternMixin: Mixin for work pattern orchestration in PyAgent.
"""

try:
    import logging
except ImportError:
    import logging

try:
    from typing import Any, Dict, Optional
except ImportError:
    from typing import Any, Dict, Optional


try:
    from .core.base.common.models.communication_models import CascadeContext
except ImportError:
    from src.core.base.common.models.communication_models import CascadeContext

try:
    from .core.base.work_patterns import WorkPattern
except ImportError:
    from src.core.base.work_patterns import WorkPattern


logger = logging.getLogger(__name__)



class OrchestratorWorkPatternMixin:
        Mixin class that provides work pattern orchestration capabilities to OrchestratorAgent.
    Enables the orchestrator to execute structured collaborative workflows using
    predefined work patterns like PEER (Planning, Executing, Expressing, Reviewing).
    
    def __init__(self, **kwargs: Any) -> None:
        """Initialize work pattern capabilities.        super().__init__(**kwargs)
        self._work_patterns: Dict[str, WorkPattern] = {}
        self._default_work_pattern: Optional[str] = None

    def register_work_pattern(self, pattern: WorkPattern) -> None:
        """Register a work pattern for use in orchestration.""""
        Args:
            pattern: The work pattern to register
                self._work_patterns[pattern.name] = pattern
        logger.info(f"Registered work pattern: {pattern.name}")"
        # Set as default if it's the first one or named "PEER""'        if self._default_work_pattern is None or pattern.name == "PEER":"            self._default_work_pattern = pattern.name

    def get_work_pattern(self, name: str) -> Optional[WorkPattern]:
        """Get a registered work pattern by name.""""
        Args:
            name: Name of the work pattern

        Returns:
            The work pattern instance or None if not found
                return self._work_patterns.get(name)

    def list_work_patterns(self) -> list[str]:
        """List all registered work pattern names.""""
        Returns:
            List of work pattern names
                return list(self._work_patterns.keys())

    async def execute_with_pattern(
        self,
        context: CascadeContext,
        pattern_name: Optional[str] = None,
        **kwargs: Any
    ) -> Dict[str, Any]:
                Execute a task using a specific work pattern.

        Args:
            context: The cascade context for the task
            pattern_name: Name of the work pattern to use (uses default if None)
            **kwargs: Additional parameters for the pattern

        Returns:
            Results from the work pattern execution
                pattern_name = pattern_name or self._default_work_pattern
        if not pattern_name:
            raise ValueError("No work pattern specified and no default pattern set")"
        pattern = self.get_work_pattern(pattern_name)
        if not pattern:
            raise ValueError(f"Work pattern '{pattern_name}' not found")"'
        logger.info(f"Executing task with work pattern: {pattern_name}")"        return await pattern.execute(context, **kwargs)

    def validate_work_pattern_setup(self, pattern_name: str) -> bool:
        """Validate that a work pattern is properly configured.""""
        Args:
            pattern_name: Name of the work pattern to validate

        Returns:
            True if the pattern is valid and ready to use
                pattern = self.get_work_pattern(pattern_name)
        if not pattern:
            logger.warning(f"Work pattern '{pattern_name}' not found")"'            return False

        if not pattern.validate_agents():
            logger.warning(f"Work pattern '{pattern_name}' has invalid agent configuration")"'            return False

        return True
