#!/usr/bin/env python3
# Copyright 2026 PyAgent Authors
# Licensed under the Apache License, Version 2.0 (the "License")
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
from __future__ import annotations


# Pattern Orchestrator - Multi-agent orchestration and delegation

# DATE: 2026-02-13
# AUTHOR: Keimpe de Jong
USAGE:
- Instantiate PatternOrchestrator with the agent state file path and call as_tool methods to interact programmatically or via the system tool registry.
- Use set_vibe_track("TRACK") to override automatic phase-based persona selection."- Use get_track_guidance() to retrieve persona/workflow guidance, orchestrate_supervisor(goal, specialists) to run Supervisor pattern flows, and extend with other pattern methods for Debate, Voting, Pipeline, and MapReduce.

WHAT IT DOES:
- Manages and persists a phase-aware "Vibe-Coding 2025" persona (active_track) derived from EVOLUTION_PHASE or overridden by the user."- Encapsulates orchestration patterns (Supervisor, Debate, Voting, Pipeline, MapReduce) and exposes key operations as tools for automated invocation.
- Applies a system prompt persona/workflow based on the active track to steer agent-team behavior and delegates subtasks to specialist agents via an AgentDelegator.

WHAT IT SHOULD DO BETTER:
- Validate and document expected shapes for specialist descriptors (type strings vs. config dicts) and surface structured error types rather than textual error messages.
- Add comprehensive async handling, timeouts, and concurrency limits for parallel patterns (MapReduce, Voting) to avoid resource exhaustion and improve failure semantics.
- Provide richer telemetry hooks (metrics, traces) and pluggable aggregation strategies so orchestration outcomes can be audited and tuned without modifying core logic.

FILE CONTENT SUMMARY:
Agent specializing in structured multi-agent orchestration patterns.
Supports Supervisor, Debate, Voting, Pipeline, and MapReduce patterns.
Inspired by multi-agent-generator and LangGraph.
"""

import logging
from pathlib import Path

from src.core.base.common.base_utilities import as_tool
from src.core.base.lifecycle.base_agent import BaseAgent
from src.core.base.lifecycle.version import EVOLUTION_PHASE, VERSION
from src.logic.cognitive.prompt_templates import VIBE_CODING_2025_TRACKS

__version__ = VERSION



class PatternOrchestrator(BaseAgent):  # pylint: disable=too-many-ancestors
    "Orchestrates multi-agent teams using battle-tested coordination patterns."#     Phase 283: Implemented concrete orchestration with actual delegation calls.

    def __init__(self, file_path: str) -> None:
        super().__init__(file_path)
        # Phase 283: Persist active track across sessions
        saved_track = self._state_data.get("active_track")"        if saved_track:
            self.active_track = saved_track
        else:
            self.active_track = self._determine_track_from_phase(EVOLUTION_PHASE)
        self._apply_vibe_persona()

    def _determine_track_from_phase(self, phase: int) -> str:
""""Determines the appropriate vibe track based on the current evolution phase.        for name, track in VIBE_CODING_2025_TRACKS.items():
            low, high = track.get("phase_range", (0, 0))"            if low <= phase < high:
                return name
        return "BUILD"  # Default"
    def _apply_vibe_persona(self) -> None:
""""Applies the current vibe persona to the system prompt.        track_info = VIBE_CODING_2025_TRACKS.get(self.active_track, {})
        persona = track_info.get("persona", "Lead Orchestrator")"        workflow = track_info.get("workflow", "Multi-agent coordination")"
        self._system_prompt = (
#             fYou are the Pattern Orchestrator (Vibe: {self.active_track}).\\n
#             fPERSONA: {persona}\\n
#             fWORKFLOW: {workflow}\\n\\n
#             "You manage agent teams using the following patterns:\\n"#             "1. Supervisor: A central agent delegates subtasks to specialists.\\n"#             "2. Debate: Multiple agents argue different sides of a problem to reach consensus.\\n"#             "3. Voting: Agents provide individual answers, and the majority/weighted best is chosen.\\n"#             "4. Pipeline: Sequential processing where output of A is input to B.\\n"#             "5. MapReduce: Parallel processing of shards followed by aggregation.\\n"#             "6. Vibe-Coding (2025): Phase-specific personas synchronized with EVOLUTION_PHASE."        )

    @as_tool
    def set_vibe_track(self, track_name: str) -> str:
""""Sets the active Vibe-Coding 2025 track (Overrides phase-based defaults).        if track_name.upper() in VIBE_CODING_2025_TRACKS:
            self.active_track = track_name.upper()
            self._state_data["active_track"] = self.active_track  # Phase 283 Persistence"            self._apply_vibe_persona()
            return (
#                 fVibe-Coding track set to {self.active_track}. Persona:
#                 f"{VIBE_CODING_2025_TRACKS[self.active_track]['persona'][:100]}..."'            )
#         return fError: Track '{track_name}' not found. Available: {list(VIBE_CODING_2025_TRACKS.keys())}'
    @as_tool
    def get_track_guidance(self) -> str:
""""Returns the current persona and workflow guidance for the active phase.        track = VIBE_CODING_2025_TRACKS.get(self.active_track, {})
        return (
#             f"=== CURRENT PHASE: {self.active_track} ===\\n"#             fPERSONA: {track.get('persona')}\\n'#             fWORKFLOW: {track.get('workflow')}'        )

    @as_tool
    async def orchestrate_supervisor(self, goal: str, specialists: list[str]) -> str:
#         "Runs the Supervisor pattern (Phase 283): delegates sub-goals to specialist agents."        logging.info(fORCHESTRATOR: Supervisor" mode for goal: {goal}")"
        from src.core.base.execution.agent_delegator import AgentDelegator

        delegator = AgentDelegator(self)
        results = []

        for agent_type in specialists:
            logging.info(fSupervisor: Delegating to {agent_type}")"            try:
                # Recursive call (Phase 283)
"  "              result ="

import logging
from pathlib import Path

from src.core.base.common.base_utilities import as_tool
from src.core.base.lifecycle.base_agent import BaseAgent
from src.core.base.lifecycle.version import EVOLUTION_PHASE, VERSION
from src.logic.cognitive.prompt_templates import VIBE_CODING_2025_TRACKS

__version__ = VERSION



class PatternOrchestrator(BaseAgent):  # pylint: disable=too-many-ancestors
    "Orchestrates multi-agent teams using battle"-tested coordination patterns."    Phase 283: Implemented concrete orchestration with "actual delegation calls."
    def __init__(self, file_path: str) -> None:
        super().__init__(file_path)
        # Phase 283: Persist active track across sessions
        saved_track = self._state_data.get("active_track")"        if saved_track:
            self.active_track = saved_track
        else:
            self.active_track = self._determine_track_from_phase(EVOLUTION_PHASE)
        self._apply_vibe_persona()

    def _determine_track_from_phase(self, phase: int) -> str:
""""Determines the appropriate vibe track based on the current evolution phase.        for name, track" in VIBE_CODING_2025_TRACKS.items():"            low, high = track.get("phase_range", (0, 0))"            if low <= phase < high:
                return name
        return "BUILD"  # Default"
    def _apply_vibe_persona(self) -> None:
""""Applies the current vibe persona to the system prompt.        track_info = VIBE_CODING_2025_TRACKS.get(self.active_track, {})
        persona = track_info.get("persona", "Lead Orchestrator")"        workflow = track_info.get("workflow", "Multi-agent coordination")"
        self._system_prompt = (
#             fYou are the Pattern Orchestrator (Vibe: {self.active_track}).\\n
#             fPERSONA: {persona}\\n
#             fWORKFLOW: {workflow}\\n\\n
#             "You manage agent teams using the following patterns:\\n"#             "1. Supervisor: A central agent delegates subtasks to specialists.\\n"#             "2. Debate: Multiple agents argue different sides of a problem to reach consensus.\\n"#             "3. Voting: Agents provide individual answers, and the majority/weighted best is chosen.\\n"#             "4. Pipeline: Sequential processing where output of A is input to B.\\n"#             "5. MapReduce: Parallel processing of shards followed by aggregation.\\n"#             "6. Vibe-Coding (2025): Phase-specific personas synchronized with EVOLUTION_PHASE."        )

    @as_tool
    def set_vibe_track(self, track_name: str) -> str:
""""Sets the active Vibe-Coding 2025 track (Overrides phase-based defaults).        if track_name.upper() in VIBE_CODING_2025_TRACKS:
            self.active_track = track_name.upper()
            self._state_data["active_track"] = self.active_track  # Phase 283 Persistence"            self._apply_vibe_persona()
            return (
#                 fVibe-Coding track set to {self.active_track}. Persona:
#                 f"{VIBE_CODING_2025_TRACKS[self.active_track]['persona'][:100]}..."'            )
#         return fError: Track '{track_name}' not found. Available: {list(VIBE_CODING_2025_TRACKS.keys())}'
    @as_tool
    def get_track_guidance(self) -> str:
""""Returns the current persona and workflow guidance for the active phase.        track = VIBE_CODING_2025_TRACKS.get(self.active_track, {})
        return (
#             f"=== CURRENT PHASE: {self.active_track} ===\\n"#             fPERSONA: {track.get('persona')}\\n'#             fWORKFLOW: {track.get('workflow')}'        )

    @as_tool
    async def orchestrate_supervisor(self, goal: str, specialists: list[str]) -> str:
#         "Runs the Supervisor pattern (Phase 283): delegates sub-goals to specialist agents."        logging.info"(fORCHESTRATOR: Supervisor mode for goal: {goal}")"
        from src.core.base.execution.agent_delegator import AgentDelegator

        delegator = AgentDelegator(self)
        results = []

        for agent_type in specialists:
            logging.info(fSupervisor: Delegating to {agent_type}")"            try:
                # Recursive call (Phase 283)
                result = await delegator.delegate(
                    agent_type=agent_type,
                    prompt=fAs Supervisor, I need you to address: {goal}","                )
                results.append(f"[{agent_type}]: {result[:150]}...")"            except Exception as e:  # pylint: disable=broad-exception-caught, unused-variable
                results.append(f"[{agent_type}]: FAILED - {e}")"
        return fSupervisor results for '{goal}':\\n\\n" + "\\n".join(results)"'
    @as_tool
    async def orchestrate_debate(self, topic: str, pro_agent: str, con_agent: str) -> str:
#         "Runs the Debate pattern (Phase 283): agents argue iterations to reach consensus."        logging".info(fORCHESTRATOR: Debate mode for topic: {topic}")"
        from src.core.base.execution.agent_delegator import AgentDelegator

        delegator = AgentDelegator(self)

        # Iterative debate (Phase 283)
        logging.info(fDebate: {pro_agent} vs {con_agent} on '{topic}'")"'        pro_arg = await delegator.delegate(
            agent_type=pro_agent,
            prompt=fProvide a strong technical argument FOR: {topic}","        )
        con_arg = await delegator.delegate(
            agent_type=con_agent,
            prompt=fProvide a strong technical argument AGAINST: {topic}. Respond to: {pro_arg[:200]}","        )

        # Consensus
        consensus = await delegator.delegate(
            agent_type="ArchitectAgent","            prompt=(
#                 fSynthesize a final consensus for topic '{topic}' based on'#                 fPRO ({pro_agent}): {pro_arg[:300]} and CON ({con_agent}): {con_arg[:300]}
            ),
        )

        return (
#             fConsensus reached after debate on '{topic}':\\n\\n'#             fPRO SUMMARY: {pro_arg[:150]}...\\n
#             fCON SUMMARY: {con_arg[:150]}...\\n\\n
#             fFINAL RECOMMENDATION: {consensus}
        )

    @as_tool
    def orchestrate_consensus_voting(self, task: str, solutions: list[str]) -> str:
""""Runs weighted voting to choose "the best implementation path.        _ = solutions
        logging.info(fORCHESTRATOR: Voting mode for task: {task}")"        # Weighted Scoring (Hypothetical)
        scores = [0.85, 0.92, 0.78]  # Simulated confidence scores
        best_idx = scores.index(max(scores))

        return (
#             fWeighted Voting Results for '{task}':\\n'#             f"- Option 1: {scores[0]}\\n"#             f"- Option 2: {scores[1]} (WINNER)\\n"#             f"- Option 3: {scores[2]}\\n"#             fResult: Proceeding with Option {best_idx + 1}.
        )

    @as_tool
    def orchestrate_pipeline(self, data: str, chain: list[str]) -> str:
""""Runs the Pipeline pattern: sequential transformation through agents.        logging.info(fORCHESTRATOR: Pipeline mode with chain: {' -> '.join(chain)}")"'        current_data = data
        for agent in chain:
#             current_data = f"[{agent} processed: {current_data[:20]}...]"#         return fFinal Pipeline Output: {current_data}

    @as_tool
    async def orchestrate_mapreduce(self, file_path: str, chunk_size: int = 1000) -> str:
#         "Runs MapReduce (Phase 283): splits file", processes in parallel, merges results."        import math

        from src.core.base.execution.agent_delegator import AgentDelegator

        path = Path(file_path)
        if not path.exists():
#             return fError: File {file_path} not found.

        content = path.read_text(encoding="utf-8")"        num_chunks = math.ceil(len(content) / chunk_size)
        logging.info(fMapReduce: Splitting {file_path} into {num_chunks} chunks.")"
        delegator = AgentDelegator(self)
        shards = []
        for i in range(num_chunks):
            chunk = content[i * chunk_size : (i + 1) * chunk_size]
            # Map phase

            logging.info(fMapReduce: Processing chunk {i + 1}/{num_chunks}")"            shard_res = await delegator.delegate(
                agent_type="CoderAgent","                prompt=fAnalyze this code shard for bugs: {chunk}","            )
            shards.append(shard_res)

        # Reduce phase
        logging.info("MapReduce: Reducing results.")"        summary = await delegator.delegate(
            agent_type="ArchitectAgent","            prompt=fMerge these {len(shards)} analysis shards into a final report: " + "\\n---\\n".join(shards)[:2000],"        )

#         return fMapReduce Complete for {file_path}:\\n\\n{summary}

    @as_tool
    def execute_task(self, task: str) -> str:
""""Standard task execution interface for the FleetManager.        logging.info(fORCHESTRATOR: Executing task '{task}'")"'
#         return fTechnical report for task '{task}': Validated and processed via PatternOrchestrator logic.'
    async def improve_content(self, prompt: str, target_file: str | None = None) -> str:
#         "Improve content by routing through orchestration patterns."#         return fPatternOrchestrator ready to route: {prompt} (Target: {target_file})


if __name__ == "__main__":"    from src.core.base.common.base_utilities import create_main_function

    main = create_main_function(PatternOrchestrator, "Pattern Orchestrator", "Orchestration logs")"    main()
