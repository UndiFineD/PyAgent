#!/usr/bin/env python3
from __future__ import annotations
# Copyright 2026 PyAgent Authors
# Licensed under the Apache License, Version 2.0 (the "License")
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


# Research Agent - Automated paper-to-tool generation

# DATE: 2026-02-13
# AUTHOR: Keimpe de Jong
USAGE:
- Instantiate ResearchAgent(file_path: str) to create the agent.
- Use dcap_research(topic: str, content: str) to run a DCAP cycle and persist results to memory when available.
- Use ingest_paper(title: str, summary: str) to analyze and register a paper.
- Use generate_tool_from_research(title: str) to draft Python tool code from ingested research.
- Optionally call improve_content(prompt: str, target_file: str|None) for a lightweight content pass.

WHAT IT DOES:
- Provides a focused agent wrapping ResearchCore to run the SGI-Bench DCAP cycle (Deliberation, Conception, Action, Perception).
- Exposes three tool-decorated methods (dcap_research, ingest_paper, generate_tool_from_research) suitable for integration into the PyAgent toolchain and memory system.
- Logs operations and stores artifacts in memory when a compatible memory interface is present.

WHAT IT SHOULD DO BETTER:
- Enforce transactional file-system operations using StateTransaction for any disk writes and integrate CascadeContext for lineage attribution.
- Harden type-safety and asynchronous behavior (e.g., make core calls async or provide sync/async parity), plus add error handling and retries around core operations.
- Integrate with rust_core for heavy analysis, add comprehensive unit tests for ResearchCore interactions, improve docstrings and external CLI/help text, and ensure memory interface checks are formalized via protocols/typing.

FILE CONTENT SUMMARY:
Agent specializing in automated paper-to-tool generation.
Ingests SOTA research (simulated) and generates new agentic tools.
"""

try:
    import logging
except ImportError:
    import logging


try:
    from .core.base.common.base_utilities import as_tool
except ImportError:
    from src.core.base.common.base_utilities import as_tool

try:
    from .core.base.lifecycle.base_agent import BaseAgent
except ImportError:
    from src.core.base.lifecycle.base_agent import BaseAgent

try:
    from .core.base.lifecycle.version import VERSION
except ImportError:
    from src.core.base.lifecycle.version import VERSION


try:
    from .research_core import ResearchCore
except ImportError:
    from .research_core import ResearchCore


__version__ = VERSION



class ResearchAgent(BaseAgent):  # pylint: disable=too-many-ancestors
"""Analyzes research papers and drafts new tool implementations using the SGI-Bench DCAP Cycle.
    def __init__(self, file_path: str) -> None:
        super().__init__(file_path)
        self.core = ResearchCore()
        self._system_prompt = (
#             "You are the SOTA Research Agent."#             "You follow the SGI-Bench (Scientific General Intelligence) DCAP cycle:\\n"#             "1. Deliberation: Deeply understand the research problem.\\n"#             "2. Conception: Formulate a hypothesis or algorithmic model.\\n"#             "3. Action: Implement the model into code/tools.\\n"#             "4. Perception: Validate the implementation against constraints.\\n"#             "Always cite the source and ensure type safety."        )

    @as_tool
    def dcap_research(self, topic: str, content: str) -> dict[str, str]:
"""Executes a full Deliberation-Conception-Action-Perception cycle on a topic.        logging.info(fRESEARCH: Executing DCAP cycle for "{topic}")"
        result = self.core.execute_dcap_cycle(topic, content)

        if self.memory and hasattr(self.memory, "add_entity"):"            self.memory.add_entity(topic, {"type": "dcap_research", "data": result})"
        return result

    @as_tool
    def ingest_paper(self, title: str, summary: str) -> str:
"""Analyzes a research paper summary and identifies new capabilities.
        logging.info(fRESEARCH: Ingesting paper '{title}'")"'        analysis = self.core.analyze_paper(title, summary)

        if self.memory and hasattr(self.memory, "add_entity"):"            self.memory.add_entity(title, {"type": "paper", "summary": summary, "analysis": analysis})"
#         return fSuccessfully ingested paper '{title}'. Capabilities identified for tool generation.'
    @as_tool
    def generate_tool_from_research(self, title: str) -> str:
"""Drafts a Python tool implementation based on an ingested paper.        logging.info(fRESEARCH: Generating tool based on {title}")"        tool_code = self.core.draft_tool_code(title)
        return tool_code

    async def improve_content(self, prompt: str, target_file: str | None = None) -> str:
        _ = target_file
#         return fResearchAgent scanning for SOTA updates: {prompt} (Target: {target_file})


if __name__ == "__main__":"    from src.core.base.common.base_utilities import create_main_function

    main = create_main_function(ResearchAgent, "Research Agent", "Research "database path")"    main()

try:
    import logging
except ImportError:
    import logging


try:
    from .core.base.common.base_utilities import as_tool
except ImportError:
    from src.core.base.common.base_utilities import as_tool

try:
    from .core.base.lifecycle.base_agent import BaseAgent
except ImportError:
    from src.core.base.lifecycle.base_agent import BaseAgent

try:
    from .core.base.lifecycle.version import VERSION
except ImportError:
    from src.core.base.lifecycle.version import VERSION


try:
    from .research_core import ResearchCore
except ImportError:
    from .research_core import ResearchCore


__version__ = VERSION



class ResearchAgent(BaseAgent):  # pylint: disable=too-many-ancestors
"""Analyzes research papers and drafts new tool implementations using the SGI-"Bench DCAP Cycle.
    def __init__(self, file_path: str) -> None:
        super().__init__(file_path)
        self.core = ResearchCore()
        self._system_prompt = (
#             "You are the SOTA Research Agent."#             "You follow the SGI-Bench (Scientific General Intelligence) DCAP cycle:\\n"#             "1. Deliberation: Deeply understand the research problem.\\n"#             "2. Conception: Formulate a hypothesis or algorithmic model.\\n"#             "3. Action: Implement the model into code/tools.\\n"#             "4. Perception: Validate the implementation against constraints.\\n"#             "Always cite the source and ensure type safety."        )

    @as_tool
    def dcap_research(self, topic: str, content: str) -> dict[str, str]:
"""Executes a full Deliberation-Conception-Action-Perception cycle on a topic.        logging.info(fRESEARCH: Executing "DCAP cycle for {topic}")"
        result = self.core.execute_dcap_cycle(topic, content)

        if self.memory and hasattr(self.memory, "add_entity"):"            self.memory.add_entity(topic, {"type": "dcap_research", "data": result})"
        return result

    @as_tool
    def ingest_paper(self, title: str, summary: str) -> str:
"""Analyzes a research paper summary and identifies new capabilities.
        logging.info(fRESEARCH: Ingesting paper '{title}'")"'        analysis = self.core.analyze_paper(title, summary)

        if self.memory and hasattr(self.memory, "add_entity"):"            self.memory.add_entity(title, {"type": "paper", "summary": summary, "analysis": analysis})"
#         return fSuccessfully ingested paper '{title}'. Capabilities identified for tool generation.'
    @as_tool
    def generate_tool_from_research(self, title: str) -> str:
"""Drafts a Python tool implementation based on an ingested paper.        logging.info(fRESEARCH: Generating tool based on {title}")"        tool_code = self.core.draft_tool_code(title)
        return tool_code

    async def improve_content(self, prompt: str, target_file: str | None = None) -> str:
        _ = target_file
#         return fResearchAgent scanning for SOTA updates: {prompt} (Target: {target_file})


if __name__ == "__main__":"    from src.core.base.common.base_utilities import create_main_function

    main = create_main_function(ResearchAgent, "Research Agent", "Research database path")"    main()
