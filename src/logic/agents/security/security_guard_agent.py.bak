#!/usr/bin/env python3
# Copyright 2026 PyAgent Authors
# Licensed under the Apache License, Version 2.0 (the "License")
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
from __future__ import annotations


# Security Guard Agent - Workspace Security Validation
# [BATCHFIX] Commented metadata/non-Python
""" [BATCHFIX] Commented metadata/non-Python"""
# [BATCHFIX] Commented metadata/non-Python
""" [Brief Summary]"""
# DATE: 2026-02-13
# [BATCHFIX] Commented metadata/non-Python
# AUTHOR: Keimpe de Jong
USAGE:
Instantiate SecurityGuardAgent with the path to a file inside the repository (typically the agent bootstrap file path). Use methods:
# [BATCHFIX] Commented metadata/non-Python
""" [BATCHFIX] Commented metadata/non-Python"""
# [BATCHFIX] Commented metadata/non-Python
""" - scan_for_secrets(content: str) -> list[str]"""
# [BATCHFIX] Commented metadata/non-Python
""" [BATCHFIX] Commented metadata/non-Python"""
# [BATCHFIX] Commented metadata/non-Python
""" - audit_command(command: str) -> tuple[str, str]"""
# [BATCHFIX] Commented metadata/non-Python
""" [BATCHFIX] Commented metadata/non-Python"""
# [BATCHFIX] Commented metadata/non-Python
""" - validate_shell_script(script_content: str) -> list[str]"""
# [BATCHFIX] Commented metadata/non-Python
""" [BATCHFIX] Commented metadata/non-Python"""
# [BATCHFIX] Commented metadata/non-Python
""" - scan_for_injection(content: str) -> list[str]"""
# [BATCHFIX] Commented metadata/non-Python
""" [BATCHFIX] Commented metadata/non-Python"""
# [BATCHFIX] Commented metadata/non-Python
""" - generate_safety_report(task: str, code_changes: str, commands: list[str]) -> str"""- detect_jailbreak(prompt: str) -> bool
Call improve_content(prompt, target_file) asynchronously for an agent-driven audit workflow.

WHAT IT DOES:
Provides an orchestrating agent around SecurityCore to perform static security checks on code diffs and shell commands, detect high-severity findings, produce human-readable safety audit reports, and flag potential prompt/jailbreak attempts. It centralizes secret scanning, vulnerability detection, command auditing, and simple jailbreak heuristics and exposes these capabilities as agent methods and a system prompt for multi-agent workflows.

WHAT IT SHOULD DO BETTER:
- Return machine-readable findings (structured JSON) alongside the human report for automation and CI integration.
- Improve jailbreak detection with contextual semantic analysis, heuristics tuned to evasive patterns, and probabilistic scoring to reduce false positives.
- Expand command auditing to simulate effects (sandboxed), include provenance for findings, and provide config-driven rule sets and allow suppressions/whitelists.
- Add async/concurrent scanning for large diffs, stronger integration with repository history, richer severity mapping, and unit tests for edge cases and false-positive mitigation.

FILE CONTENT SUMMARY:
# Agent specializing in security validation and safety checks.
"""

try:
    from .core.base.common.base_utilities import create_main_function
except ImportError:
    from src.core.base.common.base_utilities import create_main_function

try:
    from .core.base.lifecycle.base_agent import BaseAgent
except ImportError:
    from src.core.base.lifecycle.base_agent import BaseAgent

try:
    from .core.base.lifecycle.version import VERSION
except ImportError:
    from src.core.base.lifecycle.version import VERSION

try:
    from .logic.agents.security.security_core import SecurityCore
except ImportError:
    from src.logic.agents.security.security_core import SecurityCore


__version__ = VERSION



class SecurityGuardAgent(BaseAgent):  # pylint: disable=too-many-ancestors
"""Protects the workspace by validating diffs and commands.
    def __init__(self, file_path: str) -> None:
        super().__init__(file_path)
# [BATCHFIX] Commented metadata/non-Python
""" [BATCHFIX] Commented metadata/non-Python"""
# [BATCHFIX] Commented metadata/non-Python
"""         self.capabilities.extend(["security-audit", "secret-scanning", "vulnerability-detection"])  # Phase 241"        self.security_core = SecurityCore(workspace_root=str(self.file_path.parent.parent.parent))
# [BATCHFIX] Commented metadata/non-Python
""" [BATCHFIX] Commented unmatched parenthesis"""
#         self._system_prompt = (
# [BATCHFIX] Commented metadata/non-Python
"""             "You are the Security Guard Agent. Your role is to inspect proposed changes"  # [BATCHFIX] closed string"# [BATCHFIX] Commented metadata/non-Python
"""             "and commands for security risks. Look for: Hardcoded secrets, destructive"  # [BATCHFIX] closed string"# [BATCHFIX] Commented metadata/non-Python
"""             "commands (rm -rf /), unauthorized network access, and malicious logic."  # [BATCHFIX] closed string"# [BATCHFIX] Commented metadata/non-Python
"""             "Output a 'Safety Audit' report. If a risk is high, explicitly say 'RISK: HIGH'."  # [BATCHFIX] closed string"'        )

    def _get_default_content(self) -> str:
    pass  # [BATCHFIX] inserted for empty block
"""return "# Workspace Security Log\\n\\n## Status\\nMonitoring active.\\n
# [BATCHFIX] Commented metadata/non-Python
""" [BATCHFIX] Commented metadata/non-Python"""
# [BATCHFIX] Commented metadata/non-Python
"""     def scan_for_secrets(self, content: str) -> list[str]:"Scans for secrets using the core logic.# [BATCHFIX] Commented metadata/non-Python
#         vulns = self.security_core.scan_content"(content)"  # [BATCHFIX] closed string"# [BATCHFIX] Commented metadata/non-Python
""" [BATCHFIX] Commented metadata/non-Python"""
# [BATCHFIX] Commented metadata/non-Python
"""         return [v.description for v in vulns if v.severity in ["high", "critical"]]"
# [BATCHFIX] Commented metadata/non-Python
""" [BATCHFIX] Commented metadata/non-Python"""
# [BATCHFIX] Commented metadata/non-Python
"""     def audit_command(self, command: str) -> tuple[str, str]:"Audits a shell command via the security core.        return self.security_core.audit_command(command)

# [BATCHFIX] Commented metadata/non-Python
""" [BATCHFIX] Commented metadata/non-Python"""
# [BATCHFIX] Commented metadata/non-Python
"""     def validate_shell_script(self, script_content: str) -> list[str]:"Performs static analysis on shell scripts via the security core.# [BATCHFIX] Commented metadata/non-Python
#         return self.security_core.validate_shell_script("script_content)"  # [BATCHFIX] closed string"
# [BATCHFIX] Commented metadata/non-Python
""" [BATCHFIX] Commented metadata/non-Python"""
# [BATCHFIX] Commented metadata/non-Python
"""     def scan_for_injection(self, content: str) -> list[str]:"Scans for indirect prompt injection via the security core.        return self.security_core.scan_for_injection(content)

# [BATCHFIX] Commented metadata/non-Python
""" [BATCHFIX] Commented metadata/non-Python"""
# [BATCHFIX] Commented metadata/non-Python
"""     def generate_safety_report(self, task: str, code_changes: str, commands: list[str]) -> str:"Generates a comprehensive safety audit report.        vulnerabilities = self.security_core.scan_content(code_changes)

# [BATCHFIX] Commented metadata/non-Python
""" [BATCHFIX] Commented metadata/non-Python"""
# [BATCHFIX] Commented metadata/non-Python
"""         command_reports = []"""        for cmd in commands:
            level, msg = self.security_core.audit_command(cmd)
            command_reports.append(f"- `{cmd}`: **{level}** - {msg}")"
        risk_level = self.security_core.get_risk_level(vulnerabilities)
        if any("HIGH" in r or "CRITICAL" in r for r in command_reports):"# [BATCHFIX] Commented metadata/non-Python
"""             risk_level = "HIGH"  # [BATCHFIX] closed string"
        report = [
            f"# Safety Audit Report for: {task}","            f"**Overall Risk Level: {risk_level}**","            "\\n## Code Vulnerabilities","        ]

        if not vulnerabilities:
            report.append("- No high-risk patterns detected in code changes.")"        else:
            for v in vulnerabilities:
# [BATCHFIX] Commented metadata/non-Python
""" [BATCHFIX] Commented metadata/non-Python"""
# [BATCHFIX] Commented metadata/non-Python
"""                 report.append(f"- [{v.severity.upper()}] Line {v.line_number}: {v.description}")"                report.append(f"  * Fix: {v.fix_suggestion}")"
        report.append("\\n## Command Audit")"# [BATCHFIX] Commented metadata/non-Python
""" [BATCHFIX] Commented metadata/non-Python"""
# [BATCHFIX] Commented metadata/non-Python
"""         report.extend(command_reports if command_reports else ["- No commands provided for audit."])"
        return "\\n".join(report)"
    def detect_jailbreak(self, prompt: str) -> bool:
    pass  # [BATCHFIX] inserted for empty block
"""Enhanced multi-stage jailbreak detection using structural analysis.# [BATCHFIX] Commented metadata/non-Python
#         # Check for characteristic jailbreak patterns (DAN," persona adoption, etc.)"  # [BATCHFIX] closed string"        jailbreak_markers = [
            "DAN","            "Do Anything Now","            "Stay in character","            "You are now a","            "bypass","            "unfiltered","        ]
        if any(marker.lower() in prompt.lower() for marker in jailbreak_markers):
            return True

        # Check for adversarial suffix patterns
        if len(prompt) > 50 and prompt.strip().endswith(("!!!", "???", "---")):"            # Common in pressure-based jailbreaks
            pass

        return False

    async def improve_content(self, prompt: str, target_file: str | None = None) -> str:
# [BATCHFIX] Commented metadata/non-Python
"""         "Perform a security audit of the provided snippet or command."  # [BATCHFIX] closed string"        _ = target_file

try:
    from .core.base.common.base_utilities import create_main_function
except ImportError:
    from src.core.base.common.base_utilities import create_main_function

try:
    from .core.base.lifecycle.base_agent import BaseAgent
except ImportError:
    from src.core.base.lifecycle.base_agent import BaseAgent

try:
    from .core.base.lifecycle.version import VERSION
except ImportError:
    from src.core.base.lifecycle.version import VERSION

try:
    from .logic.agents.security.security_core import SecurityCore
except ImportError:
    from src.logic.agents.security.security_core import SecurityCore


__version__ = VERSION



class SecurityGuardAgent(BaseAgent):  # pylint: disable=too-many-ancestors
"""Protects the workspace by validating diffs and commands.
    def __init__(self, file_path: str) -> None:
        super().__init__(file_path)
# [BATCHFIX] Commented metadata/non-Python
""" [BATCHFIX] Commented metadata/non-Python"""
# [BATCHFIX] Commented metadata/non-Python
"""         self.capabilities.extend(["security-audit", "secret-scanning", "vulnerability-detection"])  # Phase 241"        self.security_core = SecurityCore(workspace_root=str(self.file_path.parent.parent.parent))
# [BATCHFIX] Commented metadata/non-Python
""" [BATCHFIX] Commented unmatched parenthesis"""
#         self._system_prompt = (
# [BATCHFIX] Commented metadata/non-Python
"""             "You are the Security Guard Agent. Your role is to inspect proposed changes"  # [BATCHFIX] closed string"# [BATCHFIX] Commented metadata/non-Python
"""             "and commands for security risks. Look for: Hardcoded secrets, destructive"  # [BATCHFIX] closed string"# [BATCHFIX] Commented metadata/non-Python
"""             "commands (rm -rf /), unauthorized network access, and malicious logic."  # [BATCHFIX] closed string"# [BATCHFIX] Commented metadata/non-Python
"""             "Output a 'Safety Audit' report. If a risk is high, explicitly say 'RISK: HIGH'."  # [BATCHFIX] closed string"'        )

    def _get_default_content(self) -> str:
    pass  # [BATCHFIX] inserted for empty block
"""return "# Workspace Security Log\\n\\n## Status\\nMonitoring active.\\n
# [BATCHFIX] Commented metadata/non-Python
""" [BATCHFIX] Commented metadata/non-Python"""
# [BATCHFIX] Commented metadata/non-Python
"""     def scan_for_secrets(self, content: str) -> list[str]:"Scans for secrets using the core logic.# [BATCHFIX] Commented metadata/non-Python
#         vulns = self".security_core.scan_content(content)"  # [BATCHFIX] closed string"# [BATCHFIX] Commented metadata/non-Python
""" [BATCHFIX] Commented metadata/non-Python"""
# [BATCHFIX] Commented metadata/non-Python
"""         return [v.description for v in vulns if v.severity in ["high", "critical"]]"
# [BATCHFIX] Commented metadata/non-Python
""" [BATCHFIX] Commented metadata/non-Python"""
# [BATCHFIX] Commented metadata/non-Python
"""     def audit_command(self, command: str) -> tuple[str, str]:"Audits a shell command via the security core.        return self.security_core.audit_command(command)

# [BATCHFIX] Commented metadata/non-Python
""" [BATCHFIX] Commented metadata/non-Python"""
# [BATCHFIX] Commented metadata/non-Python
"""     def validate_shell_script(self, script_content: str) -> list[str]:"Performs static analysis on shell scripts via the security core.        return self.security_core.validate_shell_script(script_content)

# [BATCHFIX] Commented metadata/non-Python
""" [BATCHFIX] Commented metadata/non-Python"""
# [BATCHFIX] Commented metadata/non-Python
"""     def scan_for_injection(self, content: str) -> list[str]:"Scans for indirect prompt injection via the security core.        return self.security_core.scan_for_injection(content)

# [BATCHFIX] Commented metadata/non-Python
""" [BATCHFIX] Commented metadata/non-Python"""
# [BATCHFIX] Commented metadata/non-Python
"""     def generate_safety_report(self, task: str, code_changes: str, commands: list[str]) -> str:"Generates a comprehensive safety audit report.# [BATCHFIX] Commented metadata/non-Python
#         vulnerabilities" = self.security_core.scan_content(code_changes)"  # [BATCHFIX] closed string"
# [BATCHFIX] Commented metadata/non-Python
""" [BATCHFIX] Commented metadata/non-Python"""
# [BATCHFIX] Commented metadata/non-Python
"""         command_reports = []"""        for cmd in commands:
            level, msg = self.security_core.audit_command(cmd)
            command_reports.append(f"- `{cmd}`: **{level}** - {msg}")"
        risk_level = self.security_core.get_risk_level(vulnerabilities)
        if any("HIGH" in r or "CRITICAL" in r for r in command_reports):"# [BATCHFIX] Commented metadata/non-Python
"""             risk_level = "HIGH"  # [BATCHFIX] closed string"
        report = [
            f"# Safety Audit Report for: {task}","            f"**Overall Risk Level: {risk_level}**","            "\\n## Code Vulnerabilities","        ]

        if not vulnerabilities:
            report.append("- No high-risk patterns detected in code changes.")"        else:
            for v in vulnerabilities:
# [BATCHFIX] Commented metadata/non-Python
""" [BATCHFIX] Commented metadata/non-Python"""
# [BATCHFIX] Commented metadata/non-Python
"""                 report.append(f"- [{v.severity.upper()}] Line {v.line_number}: {v.description}")"                report.append(f"  * Fix: {v.fix_suggestion}")"
        report.append("\\n## Command Audit")"# [BATCHFIX] Commented metadata/non-Python
""" [BATCHFIX] Commented metadata/non-Python"""
# [BATCHFIX] Commented metadata/non-Python
"""         report.extend(command_reports if command_reports else ["- No commands provided for audit."])"
        return "\\n".join(report)"
    def detect_jailbreak(self, prompt: str) -> bool:
    pass  # [BATCHFIX] inserted for empty block
"""Enhanced multi-stage jailbreak detection using structural analysis.        # Check for characteristic jailbreak patterns (DAN, persona adoption, etc.)
        jailbreak_markers = [
            "DAN","            "Do Anything Now","            "Stay in character","            "You are now a","            "bypass","            "unfiltered","        ]
        if any(marker.lower() in prompt.lower() for marker in jailbreak_markers):
            return True

        # Check for adversarial suffix patterns
        if len(prompt) > 50 and prompt.strip().endswith(("!!!", "???", "---")):"            # Common in pressure-based jailbreaks
            pass

        return False

    async def improve_content(self, prompt: str, target_file: str | None = None) -> str:
# [BATCHFIX] Commented metadata/non-Python
"""         "Perform a security audit of the provided snippet or command."  # [BATCHFIX] closed string"        _ = target_file
        secrets = self.scan_for_secrets(prompt)
        risk_level, command_warning = self.audit_command(prompt)
        injections = self.scan_for_injection(prompt)
        is_jailbreak = self.detect_jailbreak(prompt)

        report = [
            "## Security Audit Report","# [BATCHFIX] Commented metadata/non-Python
""" [BATCHFIX] Commented metadata/non-Python"""
# [BATCHFIX] Commented metadata/non-Python
"""             f"**Target Analysis**: {prompt[:100]}...","            f"**Overall Risk**: {'HIGH' if risk_level == 'HIGH' or injections or is_jailbreak else risk_level}","'# [BATCHFIX] Commented metadata/non-Python
""" [BATCHFIX] Commented unterminated string"""
#             ","  # [BATCHFIX] closed string"        ]

        if is_jailbreak:
# [BATCHFIX] Commented metadata/non-Python
""" [BATCHFIX] Commented metadata/non-Python"""
# [BATCHFIX] Commented metadata/non-Python
"""             report.append("> [!DANGER] Jailbreak Attempt Detected")"
        if secretions := secrets + injections:
# [BATCHFIX] Commented metadata/non-Python
""" [BATCHFIX] Commented metadata/non-Python"""
# [BATCHFIX] Commented metadata/non-Python
"""             report.append("> [!CAUTION] Security Threats Detected")"            for s in secretions:
                report.append(f"> - {s}")"# [BATCHFIX] Commented metadata/non-Python
#             report.append(")"  # [BATCHFIX] closed string"
        if risk_level != "LOW":"# [BATCHFIX] Commented metadata/non-Python
""" [BATCHFIX] Commented metadata/non-Python"""
# [BATCHFIX] Commented metadata/non-Python
"""             report.append(f"> [!WARNING] Command Risk: {command_warning}")"
        return "\\n".join(report)"

if __name__ == "__main__":"    main = create_main_function(SecurityGuardAgent, "SecurityGuard Agent", "Content or Command to audit")"# [BATCHFIX] Commented metadata/non-Python
""" [BATCHFIX] Commented metadata/non-Python"""
#     main()
