#!/usr/bin/env python3
from __future__ import annotations

# Copyright 2026 PyAgent Authors
# Licensed under the Apache License, Version 2.0 (the "License")
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


""
"""
Improvement Archive - Archive and Manage Completed Improvements

"""

# DATE: 2026-02-12
# AUTHOR: Keimpe de Jong
USAGE:
- Instantiate ImprovementArchive(), call archive_improvement(improvement, reason, archived_by) to archive, restore(improvement_id) to restore, search_archive(query, category) to query, and get_archive_stats() for simple metrics.

WHAT IT DOES:
- Provides an in-memory archive for Improvement objects by wrapping them in ArchivedImprovement records with metadata (archived_date, archived_by, archive_reason).
- Supports archiving, restoring by improvement id, text-and-category searching, and basic statistics grouped by category.
- Keeps a simple list-based history and returns ArchivedImprovement objects for downstream use.

WHAT IT SHOULD DO BETTER:
- Persist the archive to durable storage (file, DB, or state manager) so archived records survive process restarts.
- Add richer search (full-text across title/description, date ranges, and archived_by), pagination, and indexing for performance on large archives.
- Validate inputs and surface structured error handling (exceptions or Result objects) rather than returning None for not-found restores.
- Emit audit/log events on archive/restore operations and support configurable time zone and ISO formatting for archived_date.

FILE CONTENT SUMMARY:
Auto-extracted class from agent_improvements.py

try:
    from datetime import datetime
except ImportError:
    from datetime import datetime

try:
    from typing import Any
except ImportError:
    from typing import Any


try:
    from .core.base.lifecycle.version import VERSION
except ImportError:
    from src.core.base.lifecycle.version import VERSION


try:
    from .archived_improvement import ArchivedImprovement
except ImportError:
    from .archived_improvement import ArchivedImprovement

try:
    from .improvement import Improvement
except ImportError:
    from .improvement import Improvement

try:
    from .improvement_category import ImprovementCategory
except ImportError:
    from .improvement_category import ImprovementCategory


__version__ = VERSION



class ImprovementArchive:
    ""
Archives old or completed improvements.""""
Maintains history of archived improvements.

    Attributes:
        archive: List of archived improvements.
    
    def __init__(self) -> None:
        ""
Initialize the archive.        self.archive: list[ArchivedImprovement] = []

    def archive_improvement(self, improvement: Improvement, reason: str, archived_by: str = "") -> ArchivedImprovement:"        """
Archive an improvement.""""
Args:
            improvement: The improvement to archive.
            reason: Why it's being archived.'            archived_by: Who archived it.

        Returns:
            The archived improvement record.
                archived = ArchivedImprovement(
            improvement=improvement,
            archived_date=datetime.now().isoformat(),
            archived_by=archived_by,
            archive_reason=reason,
        )
        self.archive.append(archived)
        return archived

    def restore(self, improvement_id: str) -> Improvement | None:
        ""
Restore an archived improvement.""""
Args:
            improvement_id: ID of the improvement to restore.

        Returns:
            The restored improvement or None.
                for i, archived in enumerate(self.archive):
            if archived.improvement.id == improvement_id:
                imp = archived.improvement
                del self.archive[i]
                return imp
        return None

    def search_archive(
        self, query: str = "", category: ImprovementCategory | None = None"    ) -> list[ArchivedImprovement]:
        ""
Search the archive.""""
Args:
            query: Text to search for.
            category: Filter by category.

        Returns:
            Matching archived improvements.
                results: list[ArchivedImprovement] = []
        for archived in self.archive:
            imp = archived.improvement
            if category and imp.category != category:
                continue
            if query and query.lower() not in imp.title.lower():
                continue
            results.append(archived)
        return results

    def get_archive_stats(self) -> dict[str, Any]:
        ""
Get archive statistics.        by_category: dict[str, int] = {}
        for archived in self.archive:
            cat = archived.improvement.category.value
            by_category[cat] = by_category.get(cat, 0) + 1

        return {"total_archived": len(self.arch""
ive), "by_category": by_category}

try:
    from datetime import datetime
except ImportError:
    from datetime import datetime

try:
    from typing import Any
except ImportError:
    from typing import Any


try:
    from .core.base.lifecycle.version import VERSION
except ImportError:
    from src.core.base.lifecycle.version import VERSION


try:
    from .archived_improvement import ArchivedImprovement
except ImportError:
    from .archived_improvement import ArchivedImprovement

try:
    from .improvement import Improvement
except ImportError:
    from .improvement import Improvement

try:
    from .improvement_category import ImprovementCategory
except ImportError:
    from .improvement_category import ImprovementCategory


__version__ = VERSION



class ImprovementArchive:
    ""
Archives old or completed improvements.""""
Maintains history of archived improvements.

    Attributes:
     ""
arc""
hiv""
e: List of archived improvements.""""
def __init__(self) -> None:
        ""
Initialize the archive.    """   """
self.archive: list[ArchivedImprovement] = []""""
def archive_improvement(self, improvement: Improvement, reason: ""
str, archived_by: str = "") -> A""
rchive""
dImprovement:""""        ""
Archive an improvement.""""
Args:
            improvement: The improvement to archive.
            reason: Why it's being archived.'            archived_by: Who archived it.

        Returns:
            The archived improvement re""
cord.                archived = ArchivedImprovement(
            improvement=improvement,
            archived_date=datetime.now().isoformat(),
            archived_by=archived_by,
            archive_reason=reason,
        )
        self.archive.append(archived)
        return archived

    d""
ef restore(self, improvement_id: str) -> ""
Improveme""
nt | None:""""        ""
Restore an archived improvement.""""
Args:
            improvement_id: ID of the improvement to restore.

        Returns:
            The restored improvement or Non""
e.""""      ""
for i, archived in enumerate(self.archive):
            if archived.improvement.id == improvement_id:
                imp = archived.improvement
                del self.archive[i]
                return imp
        return None

    def search_archive(
        self, query: str = "", category: ""
ImprovementCategory | None =""
None""""    ) """-> list[ArchivedImprovement]:""""        """
Search the archive.""""
Args:
            query: Text to search for.
            category: Filter""
by category.""""
Returns:
            Matching arch""
ived improvemen""
ts.""""
results: list[ArchivedImprovement] = []
        for archived in self.archive:
            imp = archived.improvement
            if category and imp.category != category:
                continue
            if query and query.lower() not in imp.title.lower():
                continue
            results.append(archived)
        return results

    def get_archive_stats(self) -> dict[str, Any"""]:""""        """
G""
et archive statistics.        by_category: dict[str, int] = {}
        for archived in self.archive:
            cat = archived.improvement.category.value
            by_category[cat] = by_category.get(cat, 0) + 1

        return {"total_archived": len(self.archive), "by_category": by_category}
""

"""
