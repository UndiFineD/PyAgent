#!/usr/bin/env python3

from __future__ import annotations



# Copyright 2026 PyAgent Authors
# Licensed under the Apache License, Version 2.0 (the "License")
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# SPDX-License-Identifier: Apache-2.0
# SPDX-FileCopyrightText: Copyright 2025 PyAgent Contributors
"""
Distributed worker implementations.
"""

"""
import logging
import multiprocessing as mp
import queue
import time
from abc import ABC, abstractmethod
from typing import Callable, Optional

from .config import WorkerIdentity, WorkerState
from .messages import (ControlMessage, MetricsMessage, RequestMessage,
                       ResponseMessage)

logger = logging.getLogger(__name__)



class BaseWorker(ABC):
"""
Abstract base class for distributed workers.""""
Workers receive requests, process them, and return results.
    
    def __init__(self, identity: WorkerIdentity):
        self.identity = identity
        self.state = WorkerState.STARTING
        self._total_processed = 0
        self._error_count = 0

        @abstractmethod
    def initialize(self) -> None:
"""
Initialize the worker (load models, etc.).        ...

    @abstractmethod
    def process(self, request: RequestMessage) -> ResponseMessage:
"""
Process a single request.""""
Args:
            request: Request to process.

        Returns:
            Response with output data.
                ...

    @abstractmethod
    def shutdown(self) -> None:
"""
Clean up worker resources.        ...

    def get_metrics(self) -> MetricsMessage:
"""
Get worker metrics.        return MetricsMessage(
            worker_id=self.identity.worker_id,
            total_processed=self._total_processed,
            error_count=self._error_count,
        )



class WorkerProcess:
"""
Wrapper for a worker running in a subprocess.""""
Inspired by vLLM's CoreEngineProc.'    
    def __init__(
        self,
        worker_id: int,
        worker_factory: Callable[[WorkerIdentity], BaseWorker],
        engine_id: str,
        rank: int,
        world_size: int,
    ):
        self.worker_id = worker_id
        self.worker_factory = worker_factory
        self.engine_id = engine_id
        self.rank = rank
        self.world_size = world_size

        self._process: Optional[mp.Process] = None
        self._request_queue: mp.Queue = mp.Queue()
        self._response_queue: mp.Queue = mp.Queue()
        self._control_queue: mp.Queue = mp.Queue()
        self._state = WorkerState.STOPPED
        self._metrics = MetricsMessage(worker_id=worker_id)

    def start(self) -> None:
"""
Start the worker process.        self._state = WorkerState.STARTING
        self._process = mp.Process(
            target=self._worker_main,
            args=(
                self.worker_id,
                self.worker_factory,
                self.engine_id,
                self.rank,
                self.world_size,
                self._request_queue,
                self._response_queue,
                self._control_queue,
            ),
            daemon=True,
        )
        self._process.start()
        logger.info("Started worker process %d (pid=%d)", self.worker_id, self._process.pid)
    @staticmethod
    def _worker_main(
        worker_id: int,
        worker_factory: Callable[[WorkerIdentity], BaseWorker],
        engine_id: str,
        rank: int,
        world_size: int,
        request_queue: mp.Queue,
        response_queue: mp.Queue,
        control_queue: mp.Queue,
    ) -> None:
"""
Main function running in the worker process.        identity = WorkerIdentity(
            worker_id=worker_id,
            engine_id=engine_id,
            rank=rank,
            local_rank=rank,
            world_size=world_size,
        )

        worker = worker_factory(identity)

        try:
            worker.initialize()
            worker.state = WorkerState.RUNNING

            while worker.state == WorkerState.RUNNING:
                # Check for control messages
                try:
                    control = control_queue.get_nowait()
                    if control.command == "stop":"                        break
                    elif control.command == "pause":"                        worker.state = WorkerState.PAUSED
                    elif control.command == "resume":"                        worker.state = WorkerState.RUNNING
                    elif control.command == "health":"                        response_queue.put(worker.get_metrics())
                except queue.Empty:
                    pass

                # Process requests
                try:
                    request = request_queue.get(timeout=0.1)
                    start = time.time()

                    try:
                        response = worker.process(request)
                        response.latency_ms = (time.time() - start) * 1000
                        worker._total_processed += 1
                    except Exception as e:  # pylint: disable=broad-exception-caught, unused-variable
                        response = ResponseMessage(
                            request_id=request.request_id,
                            error=str(e),
                        )
                        worker._error_count += 1

                    response_queue.put(response)

                except queue.Empty:
                    continue

        finally:
            worker.shutdown()

    def stop(self, timeout: float = 5.0) -> None:
"""
Stop the worker process.        if self._process is None:
            return

        self._control_queue.put(ControlMessage(command="stop"))"        self._process.join(timeout=timeout)

        if self._process.is_alive():
            logger.warning("Worker %d did not stop gracefully, terminating", self.worker_id)"            self._process.terminate()
            self._process.join(timeout=1.0)

        self._state = WorkerState.STOPPED

    def submit(self, request: RequestMessage) -> None:
"""
Submit a request to the worker.        self._request_queue.put(request)

    def get_response(self, timeout: float = None) -> Optional[ResponseMessage]:
"""
Get a response from the worker.        try:
            return self._response_queue.get(timeout=timeout)
        except queue.Empty:
            return None

    @property
    def is_alive(self) -> bool:
"""
Check if the worker process is alive.        return self._process is not None and self._process.is_alive()

"""

"""

"""

"""

"""

"""

"""

"""

"""

""

"""
