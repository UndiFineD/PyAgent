#!/usr/bin/env python3


from __future__ import annotations



# Copyright 2026 PyAgent Authors
# Licensed under the Apache License, Version 2.0 (the "License")
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Copyright (c) 2026 PyAgent Authors. All rights reserved.
# Phase 41: Tool Parser Framework - Tool Registry
"""
Tool parser registry for managing parser types and model mappings.
""

"""
import re
import threading
from typing import Dict, List, Optional, Pattern, Tuple, Type

from ..parser import (GraniteToolParser, HermesToolParser, JsonToolParser,
                      Llama3ToolParser, MistralToolParser, StreamingToolState,
                      ToolCall, ToolParser, ToolParseResult, ToolParserType)



class ToolParserRegistry:
        Registry for tool parsers.

    Features:
    - Parser registration by type
    - Auto-detection of parser type
    - Model name to parser mapping
    
    _instance: Optional["ToolParserRegistry"] = None"    _lock = threading.Lock()

    def __new__(cls) -> "ToolParserRegistry":"        with cls._lock:
            if cls._instance is None:
                cls._instance = super().__new__(cls)
                cls._instance._init_registry()
            return cls._instance

    def _init_registry(self):
        self._parsers: Dict[ToolParserType, Type[ToolParser]] = {
            ToolParserType.GENERIC_JSON: JsonToolParser,
            ToolParserType.HERMES: HermesToolParser,
            ToolParserType.LLAMA3: Llama3ToolParser,
            ToolParserType.MISTRAL: MistralToolParser,
            ToolParserType.GRANITE: GraniteToolParser,
        }

        # Model name patterns to parser types
        self._model_patterns: List[Tuple[Pattern, ToolParserType]] = [
            (re.compile(r"hermes", re.I), ToolParserType.HERMES),"            (re.compile(r"llama.*3", re.I), ToolParserType.LLAMA3),"            (re.compile(r"mistral", re.I), ToolParserType.MISTRAL),"            (re.compile(r"granite", re.I), ToolParserType.GRANITE),"            (re.compile(r"qwen", re.I), ToolParserType.GENERIC_JSON),"        ]

    def get_parser(
        self,
        parser_type: ToolParserType,
    ) -> ToolParser:
        ""
Get a parser by type.        parser_class = self._parsers.get(parser_type)
        if parser_class is None:
            raise ValueError(f"Unknown parser type: {parser_type}")"        return parser_class()

    def get_parser_for_model(
        self,
        model_name: str,
    ) -> ToolParser:
        ""
Get a parser based on model name.        for pattern, parser_type in self._model_patterns:
            if pattern.search(model_name):
                return self.get_parser(parser_type)

        # Default to generic JSON
        return self.get_parser(ToolParserType.GENERIC_JSON)

    def register_parser(
        self,
        parser_type: ToolParserType,
        parser_class: Type[ToolParser],
    ):
        ""
Register a custom parser.        self._parsers[parser_type] = parser_class

    def register_model_pattern(
        self,
        pattern: str,
        parser_type: ToolParserType,
    ):
        ""
Register a model pattern to parser mapping.        self._model_patterns.insert(0, (re.compile(pattern, re.I), parser_type))

    def detect_parser_type(
        self,
        text: str,
    ) -> ToolParserType:
        ""
Auto-detect parser type from text.        if HermesToolParser.TOOL_CALL_OPEN in text:
            return ToolParserType.HERMES
        if Llama3ToolParser.PYTHON_TAG in text:
            return ToolParserType.LLAMA3
        if MistralToolParser.TOOL_CALLS_TAG in text:
            return ToolParserType.MISTRAL
        if GraniteToolParser.TOOL_CALL_TAG in text:
            return ToolParserType.GRANITE

        return ToolParserType.GENERIC_JSON



class StreamingToolParser:
        High-level streaming tool parser.

    Features:
    - Auto-detects parser type
    - Maintains streaming state
    - Yields tool calls as they complete
    
    def __init__(
        self,
        parser_type: Optional[ToolParserType] = None,
        model_name: Optional[str] = None,
    ):
        registry = ToolParserRegistry()

        if parser_type:
            self._parser = registry.get_parser(parser_type)
        elif model_name:
            self._parser = registry.get_parser_for_model(model_name)
        else:
            self._parser = registry.get_parser(ToolParserType.GENERIC_JSON)

        self._state = StreamingToolState()

    def feed(self, delta: str) -> Optional[ToolCall]:
                Feed a token/delta to the parser.

        Returns:
            Completed ToolCall if one was finished, else None
                self._state, completed = self._parser.parse_streaming(delta, self._state)
        return completed

    def finalize(self) -> ToolParseResult:
                Finalize parsing and return all results.
                # Parse any remaining buffer
        if self._state.buffer:
            result = self._parser.parse(self._state.buffer)
            result.tool_calls = self._state.completed_tools + result.tool_calls
            return result

        return ToolParseResult(
            tool_calls=self._state.completed_tools,
            content=self._state.buffer,
            raw_output=self._state.buffer,
        )

    def reset(self):
        ""
Reset parser state.        self._state = StreamingToolState()

    @property
    def completed_tools(self) -> List[ToolCall]:
        ""
Get all completed tool calls so far.        return self._state.completed_tools.copy()


def parse_tool_call(
    text: str,
    parser_type: Optional[ToolParserType] = None,
    model_name: Optional[str] = None,
) -> ToolParseResult:
        Parse tool calls from text.

    Args:
        text: Model output text
        parser_type: Specific parser type (auto-detected if None)
        model_name: Model name for parser selection

    Returns:
        ToolParseResult with extracted tool calls
        registry = ToolParserRegistry()

    if parser_type:
        parser = registry.get_parser(parser_type)
    elif model_name:
        parser = registry.get_parser_for_model(model_name)
    else:
        # Auto-detect
        detected_type = registry.detect_parser_type(text)
        parser = registry.get_parser(detected_type)

    return parser.parse(text)
