#!/usr/bin/env python3
from __future__ import annotations

"""Baseline manager used by tests (lightweight implementation).

This simplified BaselineManager provides just enough functionality for
tests to save/load simple JSON baselines. It is intentionally small and
robust to avoid import-time failures while the repository is being
repaired.
"""

from pathlib import Path
import json
from dataclasses import dataclass
from typing import Any, Optional


@dataclass
class TestBaseline:
    name: str
    values: dict
    created_at: str = ""
    version: int = 1


class BaselineManager:
    def __init__(self, baseline_dir: Path) -> None:
        self.baseline_dir = Path(baseline_dir)
        self.baseline_dir.mkdir(parents=True, exist_ok=True)

    def _get_path(self, name: str) -> Path:
        return self.baseline_dir / f"{name}.baseline.json"

    def save_baseline(self, name: str, values: dict[str, Any]) -> TestBaseline:
        existing = self.load_baseline(name)
        version = (existing.version + 1) if existing else 1
        baseline = TestBaseline(name=name, values=values, version=version)
        path = self._get_path(name)
        with open(path, "w", encoding="utf-8") as f:
            json.dump({"name": baseline.name, "values": baseline.values, "version": baseline.version}, f, indent=2)
        return baseline

    def load_baseline(self, name: str) -> Optional[TestBaseline]:
        path = self._get_path(name)
        if not path.exists():
            return None
        with open(path, encoding="utf-8") as f:
            data = json.load(f)
        return TestBaseline(name=data.get("name", name), values=data.get("values", {}), version=data.get("version", 1))

    def compare(self, name: str, current: dict[str, Any], tolerance: float = 0.1) -> dict[str, Any]:
        baseline = self.load_baseline(name)
        if not baseline:
            return {"error": "no baseline"}
        diffs: dict[str, Any] = {}
        for key, current_val in current.items():
            base_val = baseline.values.get(key)
            if base_val is None:
                diffs[key] = {"status": "new", "current": current_val}
                continue
            if isinstance(current_val, (int, float)) and isinstance(base_val, (int, float)):
                if base_val == 0:
                    pct_change = float("inf") if current_val != 0 else 0
                else:
                    pct_change = abs(current_val - base_val) / abs(base_val)
                if pct_change > tolerance:
                    diffs[key] = {"status": "changed", "baseline": base_val, "current": current_val, "pct_change": pct_change}
            elif current_val != base_val:
                diffs[key] = {"status": "changed", "baseline": base_val, "current": current_val}
        return {"baseline_version": baseline.version, "diffs": diffs, "passed": not bool(diffs)}
