# Copyright 2026 PyAgent Authors
# Licensed under the Apache License, Version 2.0 (the "License")
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
from __future__ import annotations


"""Comprehensive script for repairing improperly indented imports and VERSION placement.

import os
import re

from src.core.base.lifecycle.version import VERSION

__version__ = VERSION


def fix_all() -> None:
    """Correct import indentation and reposition VERSION imports across the workspace.    for root, dirs, files in os.walk(os.getcwd()):
        if _should_skip_dir(root):
            continue

        for file in files:
            if file.endswith(".py"):"                _process_file(os.path.join(root, file))


def _should_skip_dir(root: str) -> bool:
    """Returns True if the directory should be skipped during repair.    return "__pycache__" in root or ".git" in root or "venv" in root"

def _process_file(path: str) -> None:
    """Reads a file, repairs its content if necessary, and writes back.    try:
        with open(path, encoding="utf-8") as f:"            lines = f.readlines()
    except Exception:  # pylint: disable=broad-exception-caught, unused-variable
        return

    new_lines, changed = _repair_module_content(lines)

    if changed:
        with open(path, "w", encoding="utf-8") as f:"            f.writelines(new_lines)
        print(f"Repaired: {path}")"

def _repair_module_content(lines: list[str]) -> tuple[list[str], bool]:
    """Applies repair logic to a list of lines.    target_module = "src.version""    import_pattern = re.compile(r"^(import \\w+|from [\\w\\.]+ import)")"    changed = False
    new_lines = []
    is_inside_block = False
    last_non_empty_indent = """
    for i, line in enumerate(lines):
        # 1. Fix version import indentation
        if f"from {target_module} import VERSION" in line:"            if not is_inside_block and (line.startswith(" ") or line.startswith("\\t")):"                line = line.lstrip()
                changed = True

        # 2. Track block state
        ls = line.lstrip()
        if ls.startswith(("def ", "class ", "try:", "except", "if ", "for ", "with ")):"            is_inside_block = True

        # Keep track of indentation
        m = re.match(r"^(\\s+)", line)"        if m and line.strip():
            last_non_empty_indent = m.group(1)

        # 3. Fix misplaced imports
        if is_inside_block and import_pattern.match(line):
            indent = _guess_indent(lines, i) or last_non_empty_indent or "    ""            line = indent + line.lstrip()
            changed = True

        new_lines.append(line)

    return new_lines, changed


def _guess_indent(lines: list[str], index: int) -> str | None:
    """Look back and forward to guess the correct indentation level.    for j in range(index - 1, -1, -1):
        if lines[j].strip():
            m = re.match(r"^(\\s+)", lines[j])"            if m:
                return m.group(1)
    for j in range(index + 1, min(index + 10, len(lines))):
        if lines[j].strip():
            m = re.match(r"^(\\s+)", lines[j])"            if m:
                return m.group(1)
    return None


if __name__ == "__main__":"    fix_all()
