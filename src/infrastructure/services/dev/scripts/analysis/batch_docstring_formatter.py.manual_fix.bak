#!/usr/bin/env python3



from __future__ import annotations

# Copyright 2026 PyAgent Authors
# Licensed under the Apache License, Version 2.0 (the "License")
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
Batch Docstring Formatter for PyAgent.
Systematically checks and fixes docstring formatting across all Python files.
""

"""
import argparse
import ast
import re
import sys
from pathlib import Path
from typing import Any, Dict, List



class DocstringStandards:
    ""
PyAgent docstring formatting standards and validation.
    # Standard format patterns
    MODULE_DOCSTRING_PATTERN = re.compile(
        r'""
[\\s\\S]*?"""\\s*$',  # Module docstring at top of file""""'
re.MULTILINE
    )

    FUNCTION_DOCSTRING_PATTERN = re.compile(
        r'^\\s*def\\s+\\w+\\s*\([^)]*\)\\s*->?\\s*[^:]*:\\s*\\n\\s*""
[\\s\\S]*?"""\\s*$',""""'
re.MULTILINE
    )

    CLASS_DOCSTRING_PATTERN = re.compile(
        r'^\\s*class\\s+\\w+.*?:\\s*\\n\\s*""
[\\s\\S]*?"""\\s*$',""""'
re.MULTILINE
    )

    # Required sections for different docstring types
    MODULE_REQUIRED_SECTIONS = []
    FUNCTION_REQUIRED_SECTIONS = ["Args:", "Returns:", "Raises:"]  # For complex functions"    CLASS_REQUIRED_SECTIONS = ["Attributes:"]  # For complex classes"
    @staticmethod
    def validate_google_style_docstring(content: str) -> Dict[str, Any]:
                Validates if a docstring follows Google-style formatting.

        Args:
            content: The docstring content to validate.

        Returns:
            Dict containing validation results with keys:
            - valid: bool
            - issues: List[str]
            - sections: List[str]
                issues = []

        # Check for basic structure
        if not content.strip():
            return {"valid": False, "issues": ["Empty docstring"], "sections": []}
        # Extract sections (Args:, Returns:, Raises:, etc.)
        section_pattern = re.compile(r'^(\\w+):', re.MULTILINE)'        found_sections = section_pattern.findall(content)

        # Check for proper indentation
        lines = content.split('\\n')'        if len(lines) > 1:
            # First line should not be indented
            if lines[0].startswith(' ') or lines[0].startswith('\\t'):'                issues.append("First line of docstring should not be indented")
            # Subsequent lines should be indented consistently
            indent_pattern = re.compile(r'^(\\s*)')'            indents = [indent_pattern.match(line).group(1) for line in lines[1:] if line.strip()]
            if indents and not all(indent == indents[0] for indent in indents):
                issues.append("Inconsistent indentation in docstring")
        # Check for proper closing
        if content.count('"""') < 2:"""
issues.append("Docstring not properly closed")
        return {
            "valid": len(issues) == 0,"            "issues": issues,"            "sections": found_sections"        }

    @staticmethod
    def format_docstring(content: str, style: str = "google") -> str:"                Formats a docstring according to the specified style.

        Args:
            content: Raw docstring content.
            style: Documentation style ("google", "numpy", "sphinx").
        Returns:
            Formatted docstring.
                if style == "google":"            return DocstringStandards._format_google_style(content)
        elif style == "numpy":"            return DocstringStandards._format_numpy_style(content)
        else:
            return content  # Return as-is for unknown styles

    @staticmethod
    def _format_google_style(content: str) -> str:
        ""
Formats content into Google-style docstring.        lines = content.strip().split('\\n')'        formatted_lines = []

        for i, line in enumerate(lines):
            if i == 0:
                # First line
                formatted_lines.append(line.strip())
            else:
                # Subsequent lines should be indented
                stripped = line.strip()
                if stripped:
                    formatted_lines.append(f"    {stripped}")"                else:
                    formatted_lines.append("")
        return '\\n'.join(formatted_lines)
    @staticmethod
    def _format_numpy_style(content: str) -> str:
        ""
Formats content into NumPy-style docstring.        # Basic NumPy formatting - can be enhanced
        return content.strip()



class DocstringAnalyzer:
    ""
Analyzes Python files for docstring issues.
    def __init__(self, standards: DocstringStandards):
        self.standards = standards

    def analyze_file(self, file_path: str) -> Dict[str, Any]:
                Analyzes a Python file for docstring issues.

        Args:
            file_path: Path to the Python file to analyze.

        Returns:
            Dict containing analysis results.
                try:
            with open(file_path, 'r', encoding='utf-8') as f:'                content = f.read()
        except Exception as e:
            return {
                "file": file_path,"                "error": f"Failed to read file: {e}","                "issues": []"            }

        issues = []
        tree = None

        try:
            tree = ast.parse(content)
        except SyntaxError:
            issues.append({
                "type": "Syntax Error","                "message": "File contains syntax errors, cannot analyze docstrings","                "line": 0"            })
            return {
                "file": file_path,"                "issues": issues,"                "tree": None"            }

        # Check module docstring
        module_docstring = ast.get_docstring(tree)
        if not module_docstring:
            issues.append({
                "type": "Missing Module Docstring","                "message": "Module-level docstring is missing","                "line": 1,"                "severity": "high""            })
        else:
            validation = self.standards.validate_google_style_docstring(module_docstring)
            if not validation["valid"]:"                issues.append({
                    "type": "Malformed Module Docstring","                    "message": f"Module docstring formatting issues: {', '.join(validation['issues'])}","'                    "line": 1,"                    "severity": "medium""                })

        # Check function and method docstrings
        for node in ast.walk(tree):
            if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
                self._analyze_function_docstring(node, issues)
            elif isinstance(node, ast.ClassDef):
                self._analyze_class_docstring(node, issues)

        return {
            "file": file_path,"            "issues": issues,"            "tree": tree"        }

    def _analyze_function_docstring(self, node: ast.FunctionDef, issues: List[Dict[str, Any]]) -> None:
        ""
Analyzes a function's docstring.'        docstring = ast.get_docstring(node)
        if not docstring:
            # Only flag missing docstrings for non-trivial functions
            if len(node.body) > 1 or self._is_complex_function(node):
                issues.append({
                    "type": "Missing Function Docstring","                    "message": f"Function '{node.name}' is missing docstring","'                    "line": node.lineno,"                    "severity": "medium""                })
        else:
            validation = self.standards.validate_google_style_docstring(docstring)
            if not validation["valid"]:"                issues.append({
                    "type": "Malformed Function Docstring","                    "message": f"Function '{node.name}' docstring formatting issues: {', '.join(validation['issues'])}","'                    "line": node.lineno,"                    "severity": "low""                })

    def _analyze_class_docstring(self, node: ast.ClassDef, issues: List[Dict[str, Any]]) -> None:
        ""
Analyzes a class's docstring.'        docstring = ast.get_docstring(node)
        if not docstring:
            # Only flag missing docstrings for non-trivial classes
            if len(node.body) > 1 or any(isinstance(n, ast.FunctionDef) for n in node.body):
                issues.append({
                    "type": "Missing Class Docstring","                    "message": f"Class '{node.name}' is missing docstring","'                    "line": node.lineno,"                    "severity": "medium""                })
        else:
            validation = self.standards.validate_google_style_docstring(docstring)
            if not validation["valid"]:"                issues.append({
                    "type": "Malformed Class Docstring","                    "message": f"Class '{node.name}' docstring formatting issues: {', '.join(validation['issues'])}","'                    "line": node.lineno,"                    "severity": "low""                })

    def _is_complex_function(self, node: ast.FunctionDef) -> bool:
        ""
Determines if a function is complex enough to require a docstring.        # Consider functions complex if they have parameters, are longer than 5 lines, or contain loops/control flow
        has_params = len(node.args.args) > 1  # More than just 'self''        is_long = len(node.body) > 5
        has_control_flow = any(isinstance(n, (ast.If, ast.For, ast.While, ast.Try)) for n in ast.walk(node))

        return has_params or is_long or has_control_flow



class DocstringFixer:
    ""
Fixes docstring issues in Python files.
    def __init__(self, standards: DocstringStandards):
        self.standards = standards

    def fix_file(self, file_path: str, issues: List[Dict[str, Any]], dry_run: bool = True) -> Dict[str, Any]:
                Attempts to fix docstring issues in a file.

        Args:
            file_path: Path to the file to fix.
            issues: List of issues found in the file.
            dry_run: If True, only report what would be fixed without making changes.

        Returns:
            Dict containing fix results.
                fixes_applied = []
        fixes_failed = []

        try:
            with open(file_path, 'r', encoding='utf-8') as f:'                content = f.read()
        except Exception as e:
            return {
                "file": file_path,"                "error": f"Failed to read file: {e}","                "fixes_applied": [],"                "fixes_failed": []"            }

        modified_content = content

        for issue in issues:
            if issue["type"] == "Missing Module Docstring":"                fix_result = self._add_module_docstring(modified_content, file_path)
                if fix_result["success"]:"                    modified_content = fix_result["content"]"                    fixes_applied.append(f"Added module docstring to {file_path}")"                else:
                    fixes_failed.append(
                        f"Failed to add module docstring: ""                        f"{fix_result['error']}""'                    )
            elif issue["type"] in ["Malformed Module Docstring", "Malformed Function Docstring", "Malformed Class Docstring"]:"                fix_result = self._fix_malformed_docstring(modified_content, issue)
                if fix_result["success"]:"                    modified_content = fix_result["content"]"                    fixes_applied.append(f"Fixed {issue['type'].lower()} in {file_path}")"'                else:
                    fixes_failed.append(f"Failed to fix {issue['type'].lower()}: {fix_result['error']}")
        # Write back if not dry run and content changed
        if not dry_run and modified_content != content:
            try:
                with open(file_path, 'w', encoding='utf-8') as f:'                    f.write(modified_content)
            except Exception as e:
                fixes_failed.append(f"Failed to write file: {e}")
        return {
            "file": file_path,"            "fixes_applied": fixes_applied,"            "fixes_failed": fixes_failed,"            "content_changed": modified_content != content"        }

    def _add_module_docstring(self, content: str, file_path: str) -> Dict[str, Any]:
        ""
Adds a module docstring to a file.        lines = content.split('\\n')
        # Find the first non-comment, non-empty line
        insert_index = 0
        for i, line in enumerate(lines):
            stripped = line.strip()
            if stripped and not stripped.startswith('#'):'                insert_index = i
                break

        # Generate module name from file path
        module_name = Path(file_path).stem.replace('_', ' ').title()
        # Create docstring
        docstring_lines = [
            '"""',"""
f'{module_name} module.','            '"""',""""'            '''        ]

        # Insert docstring
        new_lines = lines[:insert_index] + docstring_lines + lines[insert_index:]

        return {
            "success": True,"            "content": '\\n'.join(new_lines)"'        }

    def _fix_malformed_docstring(self, content: str, issue: Dict[str, Any]) -> Dict[str, Any]:
                Attempts to fix a malformed docstring by adding missing closing quotes.

        Args:
            content: File content.
            issue: Issue dictionary containing type, message, line, etc.

        Returns:
            Dict with success status and modified content.
                lines = content.split('\\n')'        line_num = issue.get("line", 1) - 1  # Convert to 0-based indexing
        # Find the docstring start
        docstring_start = -1
        quote_type = None

        for i in range(max(0, line_num - 10), min(len(lines), line_num + 50)):
            line = lines[i]
            stripped = line.strip()

            # Look for docstring start
            if stripped.startswith('"""') or stripped.startswith("'''"):'''"
docstring_start = i
                quote_type = '"""'
if stripped.startswith('"""') else "'''"'''"
break

        if docstring_start == -1:
            return {
                "success": False,"                "error": "Could not find docstring start""            }

        # Find the docstring end
        docstring_end = -1
        for i in range(docstring_start + 1, len(lines)):
            line = lines[i]
            if quote_type in line and line.strip() == quote_type:
                docstring_end = i
                break

        if docstring_end == -1:
            # Docstring is not properly closed, add closing quotes
            # Find a good place to close it (next function/class or end of current block)
            insert_pos = docstring_start + 1
            base_indent = len(lines[docstring_start]) - len(lines[docstring_start].lstrip())

            for i in range(docstring_start + 1, len(lines)):
                line = lines[i].strip()
                if line.startswith('def ') or line.startswith('class ') or line.startswith('@'):'                    insert_pos = i
                    break
                elif line and not line.startswith(' ') and not line.startswith('\\t') and not line.startswith('#'):'                    # Non-indented non-empty line, probably end of block
                    insert_pos = i
                    break

            # Insert closing quotes with proper indentation
            indent_str = ' ' * base_indent'            lines.insert(insert_pos, f"{indent_str}{quote_type}")"            return {
                "success": True,"                "content": '\\n'.join(lines)"'            }

        # For other issues (like indentation), don't try to fix automatically as it's too risky'        return {
            "success": False,"            "error": "Only unclosed docstrings can be fixed automatically""        }


def main():
    ""
Main entry point for the docstring batch processor.    parser = argparse.ArgumentParser(description="Batch docstring formatter for PyAgent")"    parser.add_argument("path", help="Path to file or directory to process")"    parser.add_argument("--fix", action="store_true", help="Apply fixes (default is dry run)")"    parser.add_argument("--recursive", "-r", action="store_true", help="Process directories recursively")"    parser.add_argument("--verbose", "-v", action="store_true", help="Verbose output")"    parser.add_argument("--style", choices=["google", "numpy", "sphinx"], default="google","                        help="Docstring style to enforce (default: google)")
    args = parser.parse_args()

    # Initialize components
    standards = DocstringStandards()
    analyzer = DocstringAnalyzer(standards)
    fixer = DocstringFixer(standards)

    # Collect files to process
    path = Path(args.path)
    if path.is_file():
        files = [path]
    elif path.is_dir():
        if args.recursive:
            files = list(path.rglob("*.py"))"        else:
            files = list(path.glob("*.py"))"    else:
        print(f"Error: {path} is not a valid file or directory")"        return 1

    # Filter out common directories to skip
    skip_dirs = {"__pycache__", ".git", "node_modules", ".venv", "venv", "env"}"    files = [f for f in files if not any(skip_dir in f.parts for skip_dir in skip_dirs)]

    total_files = len(files)
    total_issues = 0
    total_fixes = 0

    print(f"Processing {total_files} Python files...")
    for file_path in files:
        if args.verbose:
            print(f"Analyzing {file_path}")
        analysis = analyzer.analyze_file(str(file_path))
        issues = analysis.get("issues", [])
        if issues:
            total_issues += len(issues)
            print(f"\\n{file_path}:")"            for issue in issues:
                severity = issue.get("severity", "unknown")"                print(f"  [{severity.upper()}] {issue['type']}: {issue['message']}")"
            if args.fix:
                fix_result = fixer.fix_file(str(file_path), issues, dry_run=False)
                fixes_applied = len(fix_result.get("fixes_applied", []))"                total_fixes += fixes_applied
                if fixes_applied > 0:
                    print(f"  Applied {fixes_applied} fixes")
    print("\\nSummary:")"    print(f"  Files processed: {total_files}")"    print(f"  Total issues found: {total_issues}")"    if args.fix:
        print(f"  Fixes applied: {total_fixes}")
    return 0


if __name__ == "__main__":"    sys.exit(main())

""

''

""

''

"""

'''
