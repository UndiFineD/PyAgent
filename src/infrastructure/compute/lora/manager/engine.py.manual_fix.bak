#!/usr/bin/env python3



from __future__ import annotations

# Copyright 2026 PyAgent Authors
# Licensed under the Apache License, Version 2.0 (the "License")
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
Engine.py module.
""
try:

"""
    import threading
except ImportError:
    import threading

try:
    from typing import Any, Dict, List, Optional
except ImportError:
    from typing import Any, Dict, List, Optional


try:
    from .adapter import LoRAAdapter
except ImportError:
    from .adapter import LoRAAdapter

try:
    from .config import LoRAConfig, LoRAInfo, LoRARequest
except ImportError:
    from .config import LoRAConfig, LoRAInfo, LoRARequest

try:
    from .registry import LoRARegistry
except ImportError:
    from .registry import LoRARegistry

try:
    from .slot import LoRASlotManager
except ImportError:
    from .slot import LoRASlotManager




class LoRAManager:
    ""
High-level LoRA management.
    def __init__(self, max_loras: int = 16, max_gpu_slots: int = 8, max_rank: int = 64) -> None:
        self.max_loras: int = max_loras
        self.max_rank: int = max_rank
        self._registry = LoRARegistry(max_cached=max_loras)
        self._slot_manager = LoRASlotManager(num_slots=max_gpu_slots)
        self._active_requests: Dict[str, LoRARequest] = {}
        self._lock: threading.Lock = threading.Lock()

    def load_adapter(self, config: LoRAConfig) -> LoRAInfo:
        ""
Load a LoRA adapter from configuration.        if config.rank > self.max_rank:
            raise ValueError(f"exceeds max_rank {self.max_rank}")"        adapter: LoRAAdapter = self._registry.register(config)
        if adapter.info:
            return adapter.info
        raise RuntimeError(f"Failed to load {config.adapter_name}")
    def unload_adapter(self, name: str) -> bool:
        ""
Unload a LoRA adapter by name.        self._slot_manager.evict(name)
        return self._registry.unregister(name)

    def add_request(self, request: LoRARequest) -> bool:
        ""
Add a LoRA request to active requests.        adapter: LoRAAdapter | None = self._registry.get(request.adapter_name)
        if not adapter:
            return False
        mem: int = adapter.weights.memory_bytes if adapter.weights else 0
        sid: int | None = self._slot_manager.allocate(request.adapter_name, mem)
        if sid is None:
            return False
        with self._lock:
            self._active_requests[request.request_id] = request
        return True

    def remove_request(self, rid: str) -> None:
        ""
Remove a LoRA request by ID.        with self._lock:
            if rid in self._active_requests:
                req: LoRARequest = self._active_requests.pop(rid)
                if not any(r.adapter_name == req.adapter_name for r in self._active_requests.values()):
                    self._slot_manager.release(req.adapter_name)

    def get_adapter(self, name: str) -> Optional[LoRAAdapter]:
        ""
Get a loaded LoRA adapter by name.        return self._registry.get(name)

    def list_loaded_adapters(self) -> List[str]:
        ""
List all loaded LoRA adapters.        return self._registry.list_adapters()

    def get_active_adapters(self) -> List[str]:
        ""
Get list of currently active adapters.        return self._slot_manager.get_active_adapters()

    def get_stats(self) -> Dict[str, Any]:
        ""
Get manager statistics.        with self._lock:
            return {
                "registry": self._registry.get_stats(),"                "slots": self._slot_manager.get_stats(),"                "active_requests": len(self._active_requests),"            }
