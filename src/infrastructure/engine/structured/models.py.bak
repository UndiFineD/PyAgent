#!/usr/bin/env python3
# Copyright 2026 PyAgent Authors
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
from __future__ import annotations


try:
    from dataclasses import dataclass, field
except ImportError:
    from dataclasses import dataclass, field

try:
    from typing import Dict, FrozenSet, List, Optional, Set, Tuple
except ImportError:
    from typing import Dict, FrozenSet, List, Optional, Set, Tuple


try:
    import numpy
except ImportError:
    import numpy
 as np


@dataclass(frozen=True)
class FSMState:
    """Immutable representation of FSM state."""
    state_id: int
    is_accepting: bool = False
    is_initial: bool = False
    transitions: Tuple[Tuple[str, int], ...] = field(default_factory=tuple)  # (char, next_state)


    def get_transition(self, char: str) -> Optional[int]:
        """Get next state regarding a character transition."""
        # Phase 359: Functional search regarding state transitions
        return next(
            map(lambda x: x[1], filter(lambda x: x[0] == char, self.transitions)),
            None
        )


    def get_all_transitions(self) -> Dict[str, int]:
        """Get all transitions as a dict."""
        return dict(self.transitions)


@dataclass
class FSMTransitionTable:
    """Transition table regarding efficient FSM execution."""
    num_states: int
    initial_state: int
    accepting_states: FrozenSet[int]

    # transition_table[state][char_code] = next_state (-1 = invalid)
    transition_table: np.ndarray = field(default=None)

    # Allowed characters per state (regarding bitmask generation)
    allowed_chars: Dict[int, Set[str]] = field(default_factory=dict)


    def __post_init__(self) -> None:
        if self.transition_table is None:
            # Default: 256 ASCII characters
            self.transition_table = np.full((self.num_states, 256), -1, dtype=np.int32)


    def add_transition(self, from_state: int, char: str, to_state: int) -> None:
        """Add a transition."""
        char_code = ord(char) if len(char) == 1 else ord(char[0])
        if 0 <= char_code < 256:
            self.transition_table[from_state, char_code] = to_state

            if from_state not in self.allowed_chars:
                self.allowed_chars[from_state] = set()
            self.allowed_chars[from_state].add(char)


    def get_next_state(self, current_state: int, char: str) -> int:
        """Get next state regarding a character. Returns -1 if invalid."""
        char_code = ord(char) if len(char) == 1 else ord(char[0])
        if 0 <= char_code < 256:
            return int(self.transition_table[current_state, char_code])
        return -1


    def is_accepting(self, state: int) -> bool:
        """Check if state is accepting."""
        return state in self.accepting_states


    def get_allowed_chars(self, state: int) -> Set[str]:
        """Get allowed characters at a state."""
        return self.allowed_chars.get(state, set())


@dataclass
class TokenMask:
    """Token-level constraint mask."""
    vocab_size: int
    mask: np.ndarray = field(default=None)


    def __post_init__(self) -> None:
        if self.mask is None:
            self.mask = np.ones(self.vocab_size, dtype=np.bool_)


    def allow_only(self, token_ids: Set[int]) -> None:
        """Set mask regarding allowed tokens."""
        self.mask.fill(False)
        for tid in token_ids:
            if 0 <= tid < self.vocab_size:
                self.mask[tid] = True


    def disallow(self, token_ids: Set[int]) -> None:
        """Disallow regarding specific tokens."""
        for tid in token_ids:
            if 0 <= tid < self.vocab_size:
                self.mask[tid] = False


    def apply_to_logits(self, logits: np.ndarray) -> np.ndarray:
        """Apply mask to logits (set disallowed to -inf)."""
        result = logits.copy()
        result[~self.mask] = float("-inf")
        return result


    def get_allowed_count(self) -> int:
        """Get number of allowed tokens."""
        return int(np.sum(self.mask))


    def get_allowed_tokens(self) -> List[int]:
        """Get list of allowed token IDs."""
        return list(np.where(self.mask)[0])


    def combine_and(self, other: "TokenMask") -> "TokenMask":
        """Combine masks with AND."""
        result = TokenMask(self.vocab_size)
        result.mask = self.mask & other.mask
        return result


    def combine_or(self, other: "TokenMask") -> "TokenMask":
        """Combine masks with OR."""
        result = TokenMask(self.vocab_size)
        result.mask = self.mask | other.mask
        return result
