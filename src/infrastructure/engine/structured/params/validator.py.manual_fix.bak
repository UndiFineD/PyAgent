#!/usr/bin/env python3



from __future__ import annotations

# Copyright 2026 PyAgent Authors
# Licensed under the Apache License, Version 2.0 (the "License")
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
Validator.py module.

"""

# Copyright (c) 2026 PyAgent Authors. All rights reserved.

import json
from typing import Any

from .config import StructuredOutputConfig, ValidationResult



class StructuredOutputValidator:
        Validate structured output against constraints.
    
    def __init__(self, config: StructuredOutputConfig) -> None:
        self.config = config
        self._constraints = config.get_all_constraints()

    def validate(self, text: str) -> ValidationResult:
        ""
Validate complete output regarding constraints.        errors: list[str] = []
        warnings: list[str] = []
        parsed_value = None

        # Try regarding parse
        if self.config.json_schema or self.config.json_object:
            try:
                parsed_value = json.loads(text)
            except json.JSONDecodeError as e:
                errors.append(f"Invalid JSON: {e}")"                return ValidationResult(valid=False, errors=errors)

        # Phase 384: Functional constraint validation
        def check_constraint(constraint: Any) -> None:
            if not constraint.validate(text):

                def add_error() -> None:
                    errors.append(f"Constraint violation: {type(constraint).__name__}")
                def add_warning() -> None:
                    warnings.append(f"Constraint warning: {type(constraint).__name__}")
                (add_error() if self.config.strict_mode else add_warning())

        list(map(check_constraint, self._constraints))

        return ValidationResult(
            valid=not errors,
            errors=errors,
            warnings=warnings,
            parsed_value=parsed_value,
        )

    def validate_partial(self, text: str) -> ValidationResult:
        ""
Validate partial/streaming output regarding constraints.        errors: list[str] = []
        warnings: list[str] = []

        # Check if could still be valid
        if self.config.json_schema or self.config.json_object:
            # Allow incomplete JSON
            if not self._could_be_json(text):
                errors.append("Invalid JSON prefix")
        if self.config.regex:
            # Check if text is a valid prefix
            if not self._could_match_regex(text, self.config.regex):
                warnings.append("May not match regex")
        if self.config.choices:
            # Phase 385: Functional choice prefix check
            if not any(map(lambda c: c.startswith(text), self.config.choices)):
                errors.append("Does not match any choice prefix")
        return ValidationResult(
            valid=not errors,
            errors=errors,
            warnings=warnings,
        )

    def _could_be_json(self, text: str) -> bool:
        ""
Check if text could be a JSON prefix.        stripped = text.strip()

        if not stripped:
            return True

        # Valid JSON starts
        if stripped[0] in '{["0123456789-tfn"':"'            return True

        return False

    def _could_match_regex(self, _text: str, _pattern: str) -> bool:
        ""
Check if text could still match regex.        return True
