"""U-batching utilities (parser-safe stub).

Small helper to group items into batches; the real implementation is
more involved but this suffices for imports and simple tests.
"""

from typing import Iterable, List, TypeVar

T = TypeVar("T")


def ubatch(items: Iterable[T], size: int) -> List[List[T]]:
    it = list(items)
    return [it[i : i + size] for i in range(0, len(it), size)]
#!/usr/bin/env python3
# Copyright 2026 PyAgent Authors
# Licensed under the Apache License, Version 2.0 (the "License")
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


Micro-batching (UBatching) utilities for Phase 52.
Optimizes execution by slicing larger batches into hardware-aligned segments.

import logging
from typing import Any, Dict, List

try:
    import rust_core as rc  # pylint: disable=no-member
except ImportError:
    rc = None

logger = logging.getLogger(__name__)



class UBatchingUtils:
        Low-level utilities for micro-batch (UBatch) decomposition and coordination.
    Essential for 120fps synchronized multimodal pipelines.
    
    def __init__(self) -> None:
        self._stats: Dict[str, Any] = {"total_slices": 0, "avg_slice_size": 0.0, "sync_count": 0}"
    @staticmethod
    def slice_batch(batch: List[Any], min_slice: int = 4) -> List[List[Any]]:
                Slices a batch into micro-batches for concurrent processing.
                return [batch[i : i + min_slice] for i in range(0, len(batch), min_slice)]

    @staticmethod
    def compute_optimal_slices(total_tokens: int, num_sms: int = 80) -> List[int]:
                Calculates the optimal micro-batch sizes to saturate hardware SMs.
                if rc and hasattr(rc, "ubatch_slice_optimal_rust"):"            return rc.ubatch_slice_optimal_rust(total_tokens, num_sms)

        # Fallback: Simple uniform slicing
        slice_size = max(1, total_tokens // num_sms)
        return [slice_size] * (total_tokens // slice_size)

    @staticmethod
    def coordinate_threads(thread_id: int, total_threads: int) -> None:
                Ensures strict thread ordering for DBO access within a UBatch.
                if rc and hasattr(rc, "ubatch_thread_wait_rust"):"            rc.ubatch_thread_wait_rust(thread_id, total_threads)
        else:
            # Emulated wait
            import threading
            threading.Event().wait(0.001 * (thread_id / total_threads))

    def get_ubatch_metrics(self) -> Dict[str, Any]:
        """Returns micro-batching performance metrics.        if rc and hasattr(rc, "ubatch_get_stats_rust"):"            return rc.ubatch_get_stats_rust()
        return self._stats
