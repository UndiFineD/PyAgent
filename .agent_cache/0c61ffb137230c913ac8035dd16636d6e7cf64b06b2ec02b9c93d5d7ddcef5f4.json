{"key": "0c61ffb137230c913ac8035dd16636d6e7cf64b06b2ec02b9c93d5d7ddcef5f4", "value": "Running edits to apply thread-safety, metadata preservation, registry validation, and relative import handling. Proceeding to apply multiple edits in one operation.\n\nCould not apply edits: filesystem permission denied. Provide permission to modify files or run the edits yourself with the replacement snippets below.\n\nSnippets to apply safely:\n\n1) Replace imports:\nimport importlib\nfrom functools import lru_cache\nfrom typing import Any, Callable, Dict, Optional, Tuple, TypeVar\n\nwith:\n\nimport importlib\nimport threading\nfrom functools import lru_cache, wraps\nfrom typing import Any, Callable, Dict, Optional, Tuple, TypeVar\n\n2) In LazyLoader.__init__, add lock initialization:\nself._cached: Optional[Any] = None\nself._loaded = False\nself.__doc__ = doc or f\"Lazy loader for {module_path}.{attr_name or ''}\"\n\nbecomes:\n\nself._cached: Optional[Any] = None\nself._loaded = False\nself._lock = threading.Lock()\nself.__doc__ = doc or f\"Lazy loader for {module_path}.{attr_name or ''}\"\n\n3) Replace LazyLoader._load implementation with thread-safe version:\n\ndef _load(self) -> Any:\n    \"\"\"Load and cache the module/attribute in a thread-safe manner.\"\"\"\n    if self._loaded:\n        return self._cached\n    with self._lock:\n        if not self._loaded:\n            module = importlib.import_module(self.module_path)\n            if self.attr_name:\n                self._cached = getattr(module, self.attr_name)\n            else:\n                self._cached = module\n            self._loaded = True\n    return self._cached\n\n4) Improve lazy_import to preserve metadata using wraps:\n\nReplace the wrapper block:\n\ncached_func = lru_cache(maxsize=1)(func)\n\ndef wrapper() -> T:\n    return cached_func()\n\nwrapper.__doc__ = func.__doc__\nwrapper.__name__ = func.__name__\nwrapper.__wrapped__ = func  # type: ignore[attr-defined]\nreturn wrapper\n\nwith:\n\ncached_func = lru_cache(maxsize=1)(func)\n\n@wraps(func)\ndef wrapper() -> T:\n    return cached_func()\n\nwrapper.__wrapped__ = func  # type: ignore[attr-defined]\nreturn wrapper\n\n5) Validate registry in ModuleLazyLoader.__init__:\n\nAfter function signature, replace setting of self._registry with:\n\n# Validate registry entries to be tuples of two strings for safety\nfor k, v in registry.items():\n    if not (isinstance(k, str) and isinstance(v, tuple) and len(v) == 2 and all(isinstance(x, str) for x in v)):\n        raise TypeError(\"registry must be mapping of str -> (module_path: str, attr_name: str)\")\nself._registry = dict(registry)\nself._cache: Dict[str, Any] = {}\nself._parent_module = parent_module\n\n6) Make _resolve_module_path return module_path unchanged:\n\ndef _resolve_module_path(self, module_path: str) -> str:\n    \"\"\"Return the module path unchanged; importlib.import_module will handle relative imports using the package parameter.\"\"\"\n    return module_path\n\n7) Use importlib.import_module with package param for relative imports in _load_with_error_handling:\n\ndef _load_with_error_handling(self, name: str, module_path: str, attr_name: str) -> Any:\n    try:\n        if module_path.startswith(\".\") and self._parent_module:\n            module = importlib.import_module(module_path, package=self._parent_module)\n        else:\n            module = importlib.import_module(module_path)\n        attr = getattr(module, attr_name)\n        self._cache[name] = attr\n        return attr\n    except ImportError as e:\n        raise ImportError(f\"Failed to lazy import {name!r} from {module_path}: {e}\") from e\n    except AttributeError as e:\n        raise AttributeError(f\"Module {module_path!r} has no attribute {attr_name!r}: {e}\") from e\n\nApply these minimal, targeted edits to improve thread-safety, metadata preservation, registry validation, and correct handling of relative imports.", "timestamp": 1770943599.2653723}